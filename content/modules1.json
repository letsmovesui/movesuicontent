{
  "curStatus": "ready",
  "description": "",
  "id": "1",
  "lesson": [
    {
      "codeSol": "",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 1,
      "codeDef": "",
      "title": "Meet the SuiFrens",
      "quizTitle": "Check out the SuiFrens below.",
      "content": "In this first lesson, you're going to be building the foundation for a fantasy world where the SuiFrens hang out, play different games, and evolve together.\n\nWe'll create a fren_group Move module with the following features:\n\nCreate new SuiFrens via a function. The first Fren type we’ll start out with is Baby Shark.\nKeep track of all the SuiFrens that have been born.\nEach SuiFren will be unique with its own appearance. You can see various aspects of their appearance can change and create unique SuiFrens - body, ear, belly, emotion, etc.\nEach SuiFren has a level field that denotes the SuiFren’s power. In later courses, we'll make our Sui Fren world more exciting with power upgrades, evolution, and breeding of new Fren types.\nIn order to generate a unique appearance for each SuiFren, we'll randomly generate the properties. There are generally two ways to do this:\n\n1. Generate each SuiFren off-chain and only randomize the id of the SuiFrens people receive. Each Sui Fren is then generated off-chain with unique combination of aspects and associated with a specific id. This allows each person to receive their own unique SuiFren.\n2. Generate a single random number on-chain that can be parsed into different attributes. We'll focus on this in our journey to explore Move together.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 2,
      "codeDef": "// Create the fren_group module here",
      "title": "Module",
      "quizTitle": "Write a module with the address as `0x123` and the module's name as `sui_fren`",
      "content": "Move code is organized into Modules. Each module roughly corresponds to a single smart contract on other blockchains. Move, however, offers a lot more functionalities that make organizing code into smaller and more modular pieces easier.\nEach module offers an API through its entry and public functions. Users can interact with the modules by calling functions from these modules via transactions or via other Move code. Transactions are sent to and processed by the Sui blockchain and once executed, the resulting changes will be saved. This tech stack resembles the Web 2 stack where Move modules act as the server with different routes/APIs, the Sui blockchain acting as the framework to run the server and provides the database for storing data. Developers can then build a UI that connects to this server and database to provide rich functionalities to their users.\n```\nmodule 0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script {\n\n\n}\n```\nDevelopers often deploy modules together as a single package, which gets assigned to an object and has its own address such as `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3`. The module can then be referred to with the object address and its name: `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script`. In this case the module's name is pool_script. Move also allows using an alias for the address by defining it in Move.toml (e.g. cetus=`0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3` and then defining the module as `cetus::pool_script`).\nWhen calling a function on this module, users can send a transaction content that invokes `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script::open_position` where `open_position` is the function's name. This standard format of module and function identifiers makes it easy for applications to deploy, manage, and integrate with Move modules.\nModular design is strongly encouraged on Sui and developers should keep each module as small as possible and in its separate file. This keeps the data structure and code clean, while making it easier for applications to integrate with the modules and for users to more easily understand each transaction that they send. This is similar to principles from Web 2 development such as the Single Responsibility Principle (SRP).\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    struct AdminCap {\r\n        num_frens: u64,\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 3,
      "codeDef": "module 0x123::sui_fren {\r\n    // Create the struct here\r\n}\r\n",
      "title": "Structs",
      "quizTitle": "Add a new struct AdminCap with a single field num_frens of type u64",
      "content": "Data on the Sui blockchain can be organized into structs. Structs can be thought of as a group of related fields, each with its own type such as numbers, booleans, and vectors. Struct is a foundational concept in Sui Move. \n```\nmodule 0x123::my_module {\n   use sui::object::UID;\n\n\n   // All structs that are the core of an object need to have the `key` attribute and an id field of type UID.\n   struct MyObject has key {\n       id: UID,\n       color: u64,\n   }\n}\n```\nIn the example above, we're defining a simple struct MyObject with two fields id and color. Each struct can be defined as having \"abilities\" - key, store, drop, copy. We'll explain more later what these abilities mean.\n# Move types\n\nMove supports multiple different types:\n\n1. Unsigned integers: `u8`, `u16`, `u32`, `u64`, `u128`, `u256` The different types of integers have different maximum values they can store. For example, u8 can store values up to 2^8 - 1 or 255, while `u256` can store values up to 2^256 - 1.\n2. `Booleans: bool`\n3. `Addresses: address`. Address is a core construct in blockchains and represents a user identity. Users can generate addresses from keys that only they have off-chain and use them to sign transactions. This proves that the transactions do come from the users and are not fake.\n4. `String`\n5. `Vector`. An array of u64 would be `vector<u64>`.\n6. Custom struct types such as UID imported with use `sui::object::UID` in the earlier example.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 4,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n\r\n    struct AdminCap {\r\n        num_frens: u64,\r\n    }\r\n}\r\n",
      "title": "Sui Objects",
      "quizTitle": "In the previous lesson, we defined the AdminCap struct but it's not yet a valid Object type. Let's:\n1. Update AdminCap to have the key ability and an id field of type UID.\n2. Add a new private function - fun init that takes an argument ctx of type &mut TxContext and creates the AdminCap object with num_frens set to 1000. An init function is automatically called when the module is deployed to the blockchain.\n3. Share the AdminCap object so anyone can use to create Frens. We'll cover later how to make it so that only specific accounts can have AdminCap and create Frens.\n",
      "content": "A fundamental concept in Sui we first need to explore is objects. In Sui, all data is represented as fields inside distinct objects. This models real life where everything around us is an object - chair, table, light, etc. People go through life interacting with objects, looking at them to understand their characteristics, interacting with them and modifying their states.\n\nOn the Sui blockchain, modules create, read, interact with, and modify objects as part of their flows. As users send transactions to call different functions on the blockchain, the functions they call might need to read data from multiple objects that the users own, and modify them to reflect the results of the user interactions. Object is a core fundamental building block in Sui Move and the core of any application. When building one, the first thing developers should think about is what the application data looks like and which objects need to be created to store them.\n\nFor example, as part of a ticketing application, users might call into a module that first gives you a ticket and allow you to check if it has expired:\n```\nmodule 0x123::ticket_module {\n   use sui::clock::{Self, Clock};\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n \n   struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n   }\n \n   public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n       let ticket = Ticket {\n           id: object::new(ctx),\n           expiration_time: clock::timestamp_ms(clock),\n       };\n       transfer::share_object(ticket);\n   }\n}\n```\nThe steps are:\n\n1. Define the object (we use struct to represent the object). In this case, we define the Ticket object. This object must have the key ability and an id field of type object::UID (see the import statement at the top of the module).\n2. Call object::new with the default &mut TxContext argument passed to all functions when invoked via a transaction. &mut TxContext is required to create a new object to call object::new, which returns the object's unique id which can be assigned to the id field of the object (Ticket in this case).\n3. Call transfer::share_object to make the object shared. This is useful when the data in the object is used for multiple users (global data) and doesn’t belong to any specific user. In this case, technically a ticket is not meant to be shared but we'll make it shared for demonstration purposes. Owned objects are objects owned by a specific user and can only be read or modified with that user’s permission (via signing a transaction). We’ll cover shared and owned object more in subsequent lessons.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n\r\n\r\n    // Add function get_num_frens here\r\n    fun get_num_frens(admin_cap: &AdminCap): u64 {\r\n        admin_cap.num_frens\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 5,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n\r\n\r\n    // Add function get_num_frens here\r\n}\r\n",
      "title": "Reading Object fields",
      "quizTitle": "Add a new function `get_num_frens` that takes an argument `admin_cap` of type `&AdminCap` object and returns the `num_frens` value.",
      "content": "Previously, we wrote a simple ticket application that creates tickets that have an expiration time. Let's introduce a separate function that reads this `expiration_time` field and checks if a ticket has expired:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::TxContext;\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun is_expired(ticket: &Ticket, clock: &Clock): bool {\n     ticket.expiration_time >= clock::timestamp_ms(clock)\n  }\n}\n```\nTo read the data of a `Ticket` object, the `is_expired` function above takes an immutable reference to the `Ticket` object. Move distinguishes between references and object values. When we only need to read the state of existing tickets in is_expired, we use a reference and should not be recreating or copying the entire ticket. This is similar to an electronic ticket where you can have multiple copies on your phone and laptop, but they all point to the same ticket. Immutable references just mean you can’t update the associated structs’ fields and can be represented with type `&StructName`. Note that `is_expired` also takes a `Clock` object reference (`&Clock`). This is another automatic argument, similar to `TxContext` that is passed by the system. We'll cover this more later.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 10^3,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 6,
      "codeDef": "module 0x123::sui_fren {\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n\n\n   struct AdminCap has key {\n       id: UID,\n       num_frens: u64,\n   }\n  \n   fun init(ctx: &mut TxContext) {\n       let admin_cap = AdminCap {\n           id: object::new(ctx),\n           num_frens: 1000,\n       };\n       transfer::share_object(admin_cap);\n   }\n}\n",
      "title": "Math",
      "quizTitle": "Rewrite the default `num_frens` value for `AdminCap` using exponential of 10.",
      "content": "Doing math in Move is easy and very similar to other programming languages:\n* Add: x + y\n* Subtract: x - y\n* Multiply: x * y\n* Divide: x / y\n* Mod: x % y\n* Exponential: x ^ y\nNote that this is integer math, which means results are rounded down. For example, 5 / 2 = 2. We'll learn how to do fractional math in later lessons."
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    const DEFAULT_NUM_FRIENDS: u16 = 1000;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let config = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: (DEFAULT_NUM_FRIENDS as u64),\r\n        };\r\n        transfer::share_object(config);\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 7,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    const DEFAULT_NUM_FRIENDS: u16 = 1000;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let config = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: DEFAULT_NUM_FRIENDS,\r\n        };\r\n        transfer::share_object(config);\r\n    }\r\n}\r\n",
      "title": "Typecasting",
      "quizTitle": "The init function below currently sets `num_frens` in AdminCap to a constant (fixed value) `DEFAULT_NUM_FRIENDS` of type `u16` despite `num_frens` is of type `u64`. This will fail to compile due to type mismatch. Fix this.",
      "content": "In the previous lesson, we've seen different types of integers: `u8`, `u32`, `u64`, `u128`, `u256`. Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different types:\n```\nfun mixed_types_math(): u64 {\n   let x: u8 = 1;\n   let y: u64 = 2;\n   // This will fail to compile as x and y are different types. One is u8, the other is u64.\n   x + y\n}\n```\nTo correct this, we need to cast x to `u64` with `(x as u64)`. Remember that the parentheses () are required when typecasting.\n```\nfun mixed_types_math(): u64 {\n   let x: u8 = 1;\n   let y: u64 = 2;\n   // This will fail to compile as x and y are different types. One is u8, the other is u64.\n   (x as u64) + y\n}\n```\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    // Add the new SuiFren struct here\r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 8,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    // Add the new SuiFren struct here\r\n}\r\n",
      "title": "Vectors",
      "quizTitle": "Define a new `SuiFren` object struct that has the following fields: generation of type `u64`, birthdate of type `u64`, and attributes as a `vector` of strings. Don't forget to add an import statement for `vector`.",
      "content": "When you want a list of values, use vectors. A vector in Move is dynamic by default and doesn't have a fixed size. It can grow and shrink as needed. Vector in Sui is imported by default and doesn't need to be explicitly added. You just need to do `use std::vector` at the top of your module to be able to access it. We’ll talk about other data structures and libraries available for use in a later course. Example:\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n\n\n   struct MyObject has key {\n       id: UID,\n       values: vector<u64>,\n       bool_values: vector<bool>,\n       address_values: vector<address>,\n   }\n}\n```\nYou can also store Objects in vectors by referencing the structs. Note that for an object to be stored in another object's field, its struct needs the store ability:\n\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n\n\n   struct NestedObject has key, store {\n       id: UID,\n       owner: address,\n       balance: u64,\n   }\n\n\n   struct GlobalData has key {\n       id: UID,\n       wrapped_objects: vector<NestedObject>,\n   }\n}\n```\n\nWhen creating an empty vector you can use the following syntax:\n```\nfun init() {\n   // The empty vector does not yet have a type declared. The first value added will determine its type.\n   let empty_vector = vector[];\n   let int_vector = vector[1, 2, 3];\n   let bool_vector = vector[true, true, false];\n}\n```"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    \n    struct AdminCap has key {\n        id: UID,\n        num_frens: u64,\n    }\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    \n    struct AdminCap has key {\n        id: UID,\n        num_frens: u64,\n    }\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\n        SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        }\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 9,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n}\r\n\r\nmodule 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Add the new function here\r\n}\r\n",
      "title": "Public vs Private Functions",
      "quizTitle": "Create a new public function named mint that takes four arguments and returns a SuiFren object:\n1. generation and birthdate of type `u64`\n2. attributes of type `vector<String>`\n3. ctx of type `&mut TxContext`.\n\nHint: You can use the following shortened form when struct field names and values have the same name:\n```\nstruct MyStruct {\n   value: u64,\n}\nlet value = 1;\nMyStruct {\n   value,\n}\n```",
      "content": "In the previous examples, we've only been using the `init` function, which creates the `AdminCap` object. This `init` function must be `private` and is called automatically by the Sui Virtual Machine (VM) when the module is deployed.\n\nIn this lesson, we'll create a `public` function that will be called by the user to create a new Fren. A public function in Move looks like this:\n```module 0x123::my_module {\n   public fun equals_1000(x: u64): bool {\n       x == 1000\n   }\n}\n```\nNote that this function has the keyword public, which means it can be called from any other Move modules and from transactions. Private functions on other hand can only be called in the same module and cannot be called from transactions. When public transactions are called, system objects such as `TxContext` and `Clock` can optionally be passed. It’s up to you to add those objects as arguments if your function needs them.\n**Good Practice**\nSystem objects need to always go at the end of the argument list.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun get_attributes(sui_fren: &SuiFren): vector<String> {\r\n        sui_fren.attributes\r\n    }\r\n\r\n    public fun update_attributes(sui_fren: &mut SuiFren, attributes: vector<String>) {\r\n        sui_fren.attributes = attributes;\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 10,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Add the new functions here\r\n}\r\n",
      "title": "Updating objects",
      "quizTitle": "1. Add a new public function `get_attributes` that takes a `sui_fren` object and return its attributes.\n2. Write a new public function `update_attributes` to allow changing a SuiFren's list of attributes. This function should take two arguments - the `sui_fren` object to modify and the new list of attributes",
      "content": "In this lesson, we'll learn how to modify an existing object by updating the fields of its struct. First we need to talk about mutable references. In a previous lesson on reading object fields, we covered immutable references and how we can pass them to public functions when sending transactions to read the state of an object.\n\nIn order to modify an object, we need to use mutable references instead. The difference in syntax is very simple - `&mut StructName` instead of `&StructName`. When interacting with the Sui blockchain, users can clearly see from a function’s arguments whether the functions only read or also modify objects by checking if it requires immutable objects (read only) or mutable (read and write).\n\nTo write a function that updates an object, we first need to specify the object being modified in a function via a mutable reference and then update its fields. All modified objects are automatically saved to the blockchain at the end of the transaction. Example:\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n\n\n   struct MyObject has key {\n       id: UID,\n       value: u64,\n   }\n\n\n   fun init(ctx: &mut TxContext) {\n       let my_object = MyObject {\n           id: object::new(ctx),\n           value: 10,\n       };\n       transfer::share_object(my_object);\n   }\n\n\n   public fun set_value(my_object: &mut MyObject, value: u64) {\n       my_object.value = value;\n   }\n}\n```\nThat's it! Pretty simple, right? You just need to pass a mutable reference to an object instead of immutable.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::{Self, TxContext};\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 11,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\r\n        SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        }\r\n    }\r\n}\r\n",
      "title": "Owned Objects",
      "quizTitle": "Update mint to send the newly created `SuiFren` to the transaction sender instead of returning it.",
      "content": "In the previous lessons, we learned how to create, read, and modify the `SuiFren` object which is shared among all users.\n\nThere are two types of Objects:\n1. `Shared Objects` can be read and modified by any users. We previous made `AdminCap` a shared object, which would allow any users to create Sui Frens. This might not be the desired behavior.\n2. `Owned Objects` are private objects that only users who own them can read and modify. Ownership is automatically verified as part of executing the transactions on Sui. Note that only direct ownership is allowed, so if user A owns object B and object B owns object C, user A cannot send a transaction that includes object C. There is a workaround for this using `Receiving<T>` but we'll cover this later.\n\nLet’s modify our `Ticket` example in previous lessons to create true tickets that are given to individual users instead of being accessible by all:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::{Self, TxContext};\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n        let ticket = Ticket {\n             id: object::new(ctx),\n             expiration_time: clock::timestamp_ms(clock),\n        };\n        // tx_context::sender(ctx) returns the address of the user who sends this transaction.\n        transfer::transfer(ticket, tx_context::sender(ctx));\n  }\n \n  public fun is_expired(ticket: &Ticket, clock: &Clock): bool {\n     ticket.expiration_time >= clock::timestamp_ms(clock)\n  }\n}\n```\nIn order to make `Ticket` objects owned, we just need to explicitly transfer the object to an address instead of calling `transfer::share` like before. Here, we transfer newly created tickets to the user who sends the transaction that calls `create_ticket`. To get the user's address, we use `tx_context::sender(ctx)`."
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n\r\n    // Add the new burn function here\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 12,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n    \r\n    // Add the new burn function here\r\n}\r\n",
      "title": "Deleting Objects",
      "quizTitle": "Add a new public burn function that takes and destroys a SuiFren :(\n",
      "content": "In previous lessons, we have covered the two type of Object arguments that can be passed to a function from a user transaction: immutable reference `&ObjectStruct` used to read data from an object and mutable reference `&mut ObjectStruct` used to modify an object. There's a third type of object argument we can pass to an entry function - the object value that can be used to delete an object from Sui storage:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::TxContext;\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun clip_ticket(ticket: Ticket) {\n     let Ticket {\n         id,\n         expiration_time: _,\n     } = ticket;\n     object::delete(id);\n  }\n}\n```\nIn the example above, we added a new function `clip_ticket` that takes a `Ticket` object as an argument and deletes it. We are not passing a mutable reference to the object as we're not modifying it. We're instead passing the entire Ticket struct so we can delete it:\n1. Destruct the Ticket struct with let `Ticket { id, expiration_time: _ } = ticket`\n2. Destroy the Ticket object with `object::delete(id)`"
    },
    {
      "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    use sui::event;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    struct MintEvent has copy, drop {\r\n        id: ID,\r\n    }\r\n\r\n    struct BurnEvent has copy, drop {\r\n        id: ID,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let uid = object::new(ctx);\r\n        let id = object::uid_to_inner(&uid);\r\n        let sui_fren = SuiFren {\r\n            id: uid,\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n        event::emit(MintEvent {\r\n            id,\r\n        });\r\n    }\r\n\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n        event::emit(BurnEvent {\r\n            id: object::uid_to_inner(&id),\r\n        });\r\n    }\r\n}\r\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 13,
      "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Define the new events here\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n        // Emit event here\r\n    }\r\n}\r\n",
      "title": "Events",
      "quizTitle": "Emit two events:\n1. `MintEvent` which has the id of the newly minted `SuiFren` object.\n2. `BurnEvent` which has the id of the `SuiFren` being deleted. Hint: Don't forget imports!",
      "content": "Our module is almost finished! Now let's add events. Wait, but what are events? Event is a way for your module to communicate that something happened on the blockchain to your app front-end, which can be 'listening' for certain events and take action when they happen. Without events, it's much harder for an \"off-chain\" component (smart contracts are considered \"on-chain\") to monitor whether tickets are created, extended, or redeemed. They would need to query the results for each transaction and manually go through the results to see what objects are changed and how exactly they changed. This is not easy at all and events can help!\nExample:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::event;\n  use sui::object::{Self, ID, UID};\n  use sui::transfer;\n  use sui::tx_context::{Self, TxContext};\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  struct CreateTicketEvent has copy, drop {\n     id: ID,\n  }\n \n  struct ClipTicketEvent has copy, drop {\n     id: ID,\n  }\n \n   public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n     let uid = object::new(ctx);\n     let id = object::uid_to_inner(&uid);\n     let ticket = Ticket {\n           id: uid,\n           expiration_time: clock::timestamp_ms(clock),\n     };\n     transfer::transfer(ticket, tx_context::sender(ctx));\n     event::emit(CreateTicketEvent {\n         id,\n     });\n   }\n \n  public fun clip_ticket(ticket: Ticket) {\n     let Ticket { id, expiration_time: _ } = ticket;\n     object::delete(id);\n     event::emit(ClipTicketEvent {\n        id: object::uid_to_inner(&id),\n     });\n  }\n}\n```\nIn order to emit an event on Sui, you just need to do two things:\n1. Define the event struct like `ClipTicketEvent`.\n2. Call `event::emit` to emit the event defined in (1) Note that if we want to include the object id (essentially an address) in the event, we need to use `object::uid_to_inner` to convert the original UID type to an ID type yet. UID cannot be copied or stored."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Owned objects need to go through consensus before transactions using them are finalized.",
          "isCorrect": false
        },
        {
          "answer": "B. Shared objects can be converted into owned objects but not the opposite.",
          "isCorrect": false
        },
        {
          "answer": "C. Owned objects can shared when they're created. Shared objects cannot be converted to owned objects.",
          "isCorrect": true
        }
      ],
      "lessonId": 14,
      "codeDef": "",
      "title": "Shared Objects vs Owned Objects",
      "quizTitle": "What's the difference between Shared objects and Owned objects?",
      "content": "In previous lessons, we got familiar with Shared and Owned Objects:\n```\nstruct SharedObject has key {\n   id: UID,\n}\n\n\nstruct OwnedObject has key {\n   id: UID,\n}\n\n\npublic fun create_shared_object(ctx: &mut TxContext) {\n let shared_object = SharedObject {\n     id: object::new(ctx),\n };\n transfer::share_object(shared_object);\n}\n\n\npublic fun create_owned_object(ctx: &mut TxContext) {\n let owned_object = OwnedObject {\n     id: object::new(ctx),\n };\n transfer::transfer(owned_object, tx_context::sender(ctx));\n}\n```\nA key benefit of using Owned Objects is that they can be processed in parallel as transactions touching them don’t overlap with one another (they don’t read or modify the same data). Shared objects, however, cannot be processed in parallel if they’re modified and would need to go through a more rigorous execution process, which is slower and less scalable.\nAnother important thing to note with Shared Objects is that they can only be shared in the same transaction where they’re created. This would not work:\n```\nstruct SharedObject has key {\n   id: UID,\n}\n\n\npublic fun create_object(tx_context: &mut TxContext) {\n let object = SharedObject {\n     id: object::new(ctx),\n };\n transfer::transfer(object, tx_context::sender(ctx));\n}\n\n\npublic fun share_object(object: SharedObject) {\n transfer::share_object(object);\n}\n```\nIf we call `create_object` which creates an initially owned object and then later try to share it with `share_object` in a second transaction, this would fail!"
    },
    {
      "codeSol": "",
      "quizType": "CODING",
      "answers": [],
      "lessonId": 15,
      "codeDef": "",
      "title": "Summary",
      "quizTitle": "",
      "content": "**Module**\n1. Module Organization: Move code is organized into modules, each similar to a single smart contract on other blockchains.\n2. API and Interaction: Modules provide APIs through entry and public functions. Users interact with these modules by calling functions either through transactions or other Move code. This interaction is processed by the Sui blockchain, and any resulting changes are saved.\n3. Modular design is emphasized in Sui. Developers are encouraged to keep modules small and in separate files, adhering to clean data structures and code. This facilitates easier integration for applications and clearer understanding for users. \n\n**Struct**\n1. Struct is a group of related fields, each with its own type such as numbers, booleans, and vectors.\n2. Each struct can be defined as having \"abilities\" - key, store, drop, copy.\n3. MoveSui supports these following data types: unsigned integers, booleans, addresses, string, vector, and custom struct types.\n\n**Objects**\nAfter finishing this module, you should be able to understand:\n1. Life cycle of an object\n2. How to read an object\n3. How to update an object\n4. How to delete an object\n5. Shared objects vs owned objects\n\n**Vectors** could be understood as dynamic arrays, essential for managing lists of items in smart contracts, reflecting the need for flexible data structures in blockchain applications.\n\n**Events** is a way for your module to communicate that something happened on the blockchain to your app front-end, which can be 'listening' for certain events and take action when they happen.\n\n**Functions**\n1. Public function (has keyword public): can be called from any other Move modules and from transactions\n2. Private function (has keyword private): can  be called only in the same module and cannot be called from transactions"
    }
  ],
  "title": "Fundamental concepts"
}

{
  "curStatus": "ready",
  "description": "",
  "id": "3",
  "lesson": [
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has store {\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String) {\n        if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n        }\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "1",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
      "title": "Dynamic Field - SuiFrens and their Hat",
      "quizTitle": "1. Add a new struct Hat with store ability to the sui_fren module. Hat has a single field color of type String. We'll add more fields later on.\n2. Add a new public function color_hat that takes a mutable reference to a SuiFren named sui_fren and a color of type String.\n3. color_hat should add a hat if one doesn't exist for that SuiFren or update the color of the existing one.\n4. You can use string::utf8(HAT_KEY) as the dynamic field key.",
      "content": "In the previous course, we have explored Objects in depth and created SuiFrens as objects that have their own attributes and a Display object that tells Web UI how they should be displayed. We also covered the following topics:\n1. Nested structs - Structs with the store ability can be embedded into another struct. This is often used for non-object structs to divide a long list of fields into logical components.\n2. Object wrapping - Putting a SuiFren into another object. This also uses the store ability but effectively removes the wrapped object from storage. SuiFrens that have been wrapped into GiftBoxes can no longer be looked up when searching by objects.\n\nIn this lesson, we'll cover another way to compose structs and objects together - Dynamic Fields. You can think of Dynamic Fields as invisible fields that are not explicitly defined on an object struct. Let's assume we have a Laptop Object that has the following attributes initially:\n```\nstruct Laptop has key {\n    id: UID,\n    screen_size: u64,\n    model: u64,\n}\n```\nLet's say we want to dynamically add more attributes for this laptop in the future but don't yet know what these attributes are exactly. We can't define them in the struct right away. This is where Dynamic Fields come to the rescue - you don't need to know all the fields you want to add to an object as dynamic fields!\n```\nuse sui::dynamic_field;\n\npublic fun add_attribute(laptop: &mut Laptop, name: String, value: u64) {\n    dynamic_field::add(&mut laptop.id, name, value);\n}\n```\nIn order to add dynamic fields to an object, you need a mutable reference to that object. Remember that for owned objects, only the owner can send transactions that use mutable/immutable references or a value of their object. Shared objects can be mutated by anyone. Adding a dynamic field can be done simply via dynamic_field::add with the mutable object's id, the key and the value.\n\nKey and value can be primitive types (numbers, strings, etc.) or structs. Note that structs used as keys must have the copy, drop, and store abilities while structs used as values must have the store ability.\n```\nstruct StickerName has copy, drop, store {\n    name: String,\n}\n\nstruct Sticker has store {\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, image_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker = Sticker { image_url };\n    dynamic_field::add(&mut laptop.id, sticker_name, sticker);\n}\n```\nDynamic fields are unique by name so you can't add fields of the same name more than once.\n\nTo read or modify a dynamic field, you need an immutable and mutable references to the object respectively and the field name (key). If the field name is a struct, you need the struct value itself, which is why the structs used as keys must have copy and drop abilities.\n```\npublic fun read_image_url(laptop: &Laptop, name: String): String {\n    let sticker_name = StickerName { name };\n    let sticker_reference: &Sticker = dynamic_field::borrow(&laptop.id, sticker_name);\n    sticker_reference.image_url\n}\n\npublic fun set_image_url(laptop: &mut Laptop, name: String, new_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker_mut_reference: &mut Sticker = dynamic_field::borrow_mut(&mut laptop.id, sticker_name);\n    sticker_mut_reference.image_url = new_url;\n}\n```\nNote that if you usually would need to specify the type of the field borrowed (&Sticker and &mut Sticker in the above example)\n\nYou can also remove an existing dynamic field with a mutable object reference and the key:\n```\npublic fun remove_sticker(laptop: &mut Laptop, name: String) {\n    let sticker_name = StickerName { name };\n    dynamic_field::remove(&mut laptop.id, sticker_name);\n}\n```\nYou can check if a dynamic field exists with dynamic_field::exists_(&laptop.id, sticker_name)"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_object_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            let hat = Hat {\n                id: object::new(ctx),\n                color,\n            };\n            dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n        }\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "2",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Update\n    struct Hat has store {\n        color: String,\n    }\n\n    // Update\n    public fun color_hat(sui_fren: &mut SuiFren, color: String) {\n        if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n        }\n    }\n}",
      "title": "Dynamic Object Field - Store objects as dynamic field",
      "quizTitle": "1. Update Hat to be an object\n2. Use dynamic object field to add that Hat instead. Remember you'd need to add a transaction context param to the color_hat function to be able to create Hat objects.",
      "content": "You must have a question about dynamic fields - what if we store an object in a dynamic field. While this is possible, one side effect of storing a Sticker object as a dynamic field on a Laptop is the Sticker object will be removed from storage and cannot be looked up by its id off-chain (for example in a web UI). This is the same side effect we saw with object wrapping.\n```\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, sticker: Sticker) {\n    dynamic_field::add(&mut laptop.id, name, sticker);\n}\n```\nNote that the Sticker object must also have the store ability to be stored in a dynamic fields. Because Sticker is now an object, we also need to explicit pass it via a transaction. If it's an owned object, only the owner can do so (ownership rule).\n\nIf you don't want the Sticker object to be removed from global storage so your web UI can still look it up, you can use the dynamic_object_field module instead of dynamic_field. These two modules and their functions look pretty much the same inside Move - the difference regarding global storage only matters for off chain components such as the web UI.\n```\nuse sui::dynamic_object_field;\n\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, sticker: Sticker) {\n    dynamic_object_field::add(&mut laptop.id, name, sticker);\n}\n```\nIn general, dynamic object fields are preferred over dynamic fields to store objects dynamically. You should only use dynamic fields if you intentionally want to remove the objects from global storage. One example could be when you put a hat on your SuiFren, you want the Hat to be gone from global storage to indicate it has been claimed.\n\nBonus: You might be curious about what happens to the ownership of an object after it has been added as a dynamic field on another object. The answer is that it'd be owned by the <b>dynamic field<b> itself! Behind the scene, when dynamic fields are added, each field is secretly created as a separate object in the global storage tied to the parent object the field is defined on. This dynamic field object would own the object added to it. In the example above, the Laptop owns the sticker dynamic field and the sticker dynamic field owns the Sticker object. Confusing right? Most developers don't really need to know this :)"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. They both don't remove the nested object from global storage",
          "isCorrect": false
        },
        {
          "answer": "B. They both require explicit struct definition",
          "isCorrect": false
        },
        {
          "answer": "C. They both can work for object and non-object structs",
          "isCorrect": true
        }
      ],
      "lessonId": "3",
      "codeDef": "",
      "title": "Dynamic Fields vs Dynamic Object Fields vs Wrapping",
      "quizTitle": "What is the similarity between object wrapping and dynamic fields?",
      "content": "Let's summarize the different approaches to combining objects we have learnt so far:\n1. Object wrapping: Store objects within another objects (for example SuiFrens in GiftBoxes). This removes the wrapped objects (SuiFrens) from global storage. Off-chain web UI cannot look them up after wrapping. The object no longer has any owner. You can think of this almost as converting an object into a normal non-object struct instance.\n2. Dynamic Fields: Can be used to store objects as well. This also removes the object from global storage. Ownership is also removed. Very similar to object wrapping, except that the field is added dynamically instead of explicitly defined in the struct.\n3. Dynamic Object Fields: Does not remove the object from global storage. Ownership is transferred to the special \"dynamic field object\" that is generally not easy to look up for Web UIs. In most cases, this has almost the same effect as forfeiting ownership of the object.\n\n```\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n\n// Dynamic fields\npublic fun color_hat(sui_fren: &mut SuiFren, color: String) {\n    if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n        let hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n        hat.color = color;\n    } else {\n        dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n    }\n}\n\n// Dynamic object fields\npublic fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n    if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n        let hat = dynamic_object_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n        hat.color = color;\n    } else {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n    }\n}\n```\n\nTo choose how to compose objects, developers should pay attention to:\n1. Whether the field should be explicitly defined in the struct. This is a drawback of using dynamic fields as they are not easily seen from looking at the object struct definition. This means other developers will need to read through the entire module's code to find all possible dynamic fields that can be added. It's generally not recommended to add more than 10 separate dynamic fields.\n2. Whether the object should be removed from global storage and thus not visible to web UI."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n\n    public fun update_hat_color(sui_fren: &mut SuiFren, hat: Receiving<Hat>, color: String, ctx: &mut TxContext) {\n        let hat = transfer::receive(&mut sui_fren.id, hat);\n        hat.color = color;\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "4",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    // Update\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n    }\n}",
      "title": "Objects owning Objects",
      "quizTitle": "1. Rewrite the color_hat function to transfer the Hat object to the SuiFren object instead of using dynamic object fields.\nNote that if the hat already exists, we can't easily change its color without adding a Receiving<Hat> to the color_hat function, which doesn't make sense and conflicts with the case when the SuiFren doesn't have a hat!\n2. Instead, add a separate public function update_hat_color that updates the color of an existing hat.",
      "content": "Yet another way to compose objects is to have objects own other objects. With the other three approaches - object wrapping, dynamic fields, dynamic object fields, ownership is forfeited or set to a hidden object (dynamic field object). In some cases, it can be desired to have the parent object own the child object (for example SuiFren owning the Hat it wears). This can be seen as a clear indication of object hierarchy in a complex application design with multiple types of objects.\n\nAnother interesting use case for objects owning objects is composable NFTs - exactly like SuiFrens owning their Hats. This allows for powerful composition of NFTs together that make natural sense to users and is often seen in Web 3 Games that use NFTs.\n\nOne drawback that makes objects owning objects less commonly used compared to the other 3 approaches is that it's harder to remove the owned object later. Therefore, objects owning objects is generally more useful if the relationship is rarely or never changed.\n\n```\nstruct Laptop has key {\n    id: UID,\n}\n\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &Laptop, sticker: Sticker) {\n    transfer::public_transfer(sticker, object::uid_to_address(&laptop.id));\n}\n```\nIn the example above, we explicitly transfer the Sticker object to the Laptop. It's now owned by the Laptop. In order to remove it later, we'd need to use Receiving<T>:\n```\npublic fun remove_sticker(laptop: &mut Laptop, sticker: Receiving<Sticker>) {\n    let sticker = transfer::public_receive(&mut laptop.id, sticker);\n    // Do something with the sticker\n}\n```\nIn order to extract the Sticker object that was transferred to the Laptop object earlier, we need the owner of the Laptop to call the remove_sticker function with a mutable reference to the Laptop and a variable of type Receiving<Sticker>. When sending the transaction, the owner can specify the Sticker object's address, and the Sui VM will automatically convert it into the Receiving<Sticker> type. We can then call transfer::public_transfer to get the underlying Sticker. As you can see, this is a bit harder to do than object wrapping or dynamic fields.\n\nNote that extracting an object owned by another object is also subject to the Transfer Policy (see the corresponding lesson from the previous course):\n1. If the inner object has the store ability, transfer::public_receive can be call to extract it outside of the module where its struct is defined\n2. If the inner object has no store ability, transfer::public_receive cannot be called. Only transfer::receive can be called inside the module where the struct is defined."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Because dynamic object fields removes the structs from object storage",
          "isCorrect": false
        },
        {
          "answer": "B. Because the struct fields don't have to be objects",
          "isCorrect": true
        },
        {
          "answer": "C. Because dynamic fields are faster to read and write than dynamic object fields",
          "isCorrect": false
        }
      ],
      "lessonId": "5",
      "codeDef": "",
      "title": "Using Dynamic Fields for Managing Contract States",
      "quizTitle": "Why do we want to use dynamic fields for the different laptop store configs instead of dynamic object fields?",
      "content": "Another useful application of dynamic fields is to manage contracts states. You might be tempted to use multiple shared objects for each state struct. For example, we can have the following set up for the laptop store's configs:\n```\nstruct PriceConfigs has key {\n    id: UID,\n    price_range: vector<u64>,\n}\n\nstruct StoreHours has key {\n    id: UID,\n    open_hours: vector<vector<u8>>,\n}\n\nstruct SpecConfigs has key {\n    id: UID,\n    specs_range: vector<u64>,\n}\n\nfun init(ctx: &mut TxContext) {\n    let price_configs = PriceConfigs {\n        id: object::new(ctx),\n        price_range: vector[1000, 5000],\n    };\n    let store_hours = StoreHours {\n        id: object::new(ctx),\n        open_hours: vector[vector[9, 12], vector[1, 5]],\n    };\n    let spec_configs = SpecConfigs {\n        id: object::new(ctx),\n        specs_range: vector[1000, 10000],\n    };\n    transfer::share_object(price_configs);\n    transfer::share_object(store_hours);\n    transfer::share_object(spec_configs);\n}\n```\nIt's not a lot of work to create the shared objects. Each object is shared so it can be accessed and/or modified by users when they purchase a laptop for example:\n```\npublic fun purchase_laptop(price_configs: &PriceConfigs, store_hours: &SotreHours, spec_configs: &SpecConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n}\n```\nAs you can see, this function's signature is too long and hard to read. Furthermore the web UI that submits the transactions on the user's behalf would need to track all of these shared objects' addresses. Imagine what would happen if we have 5 or even 10 shared objects! It's also overkill as these different structs are never separated and live independently so they don't really need to be objects.\n\nIt's much cleaner to instead create a single state config object and add dynamic fields there:\n```\nstruct StateConfigs has key {\n    id: UID,\n}\n\nconst PRICE_CONFIGS: vector<u8> = b\"PRICE_CONFIGS\";\nstruct PriceConfigs has store {\n    price_range: vector<u64>,\n}\n\nconst STORE_HOURS: vector<u8> = b\"STORE_HOURS\";\nstruct StoreHours has store {\n    open_hours: vector<vector<u8>>,\n}\n\nconst SPEC_CONFIGS: vector<u8> = b\"SPEC_CONFIGS\";\nstruct SpecConfigs has store {\n    specs_range: vector<u64>,\n}\n\nfun init(ctx: &mut TxContext) {\n    let state_configs = StateConfigs {\n        id: object::new(ctx),\n    };\n    dynamic_fields::add(&mut state_configs.id, PRICE_CONFIGS, PriceConfigs {\n        id: object::new(ctx),\n        price_range: vector[1000, 5000],\n    });\n    dynamic_fields::add(&mut state_configs.id, STORE_HOURS, StoreHours {\n        id: object::new(ctx),\n        open_hours: vector[vector[9, 12], vector[1, 5]],\n    });\n    dynamic_fields::add(&mut state_configs.id, SPEC_CONFIGS, SpecConfigs {\n        id: object::new(ctx),\n        specs_range: vector[1000, 10000],\n    });\n    transfer::share(state_configs);\n}\n```\nThe user transactions would then only need to track and pass a single object's address:\n```\npublic fun purchase_laptop(state_configs: &StateConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n}\n```\nAs you can see, this is much cleaner!"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    const EXTENSION_1: u64 = 1;\n\n    struct HatExtension1 has store {\n        description: String,\n        duration: u64,\n    }\n\n    public fun extend_hat(sui_fren: &mut SuiFren, description: String, duration: u64) {\n        if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_object_field::borrow_mut(sui_fren, string::utf8(HAT_KEY));\n            dynamic_field::add(&mut hat.id, EXTENSION_1, HatExtension1 {\n                description,\n                duration,\n            });\n        };\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "6",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
      "title": "Dynamic Fields for Extensibility and Upgradability",
      "quizTitle": "We want to ExtendHat to also add a description field of type String and duration of type u64.\n1. Add a new struct for the extension, named HatExtension1\n2. Add a new public function extend_hat that takes a SuiFren, a description, a duration and extend the SuiFren's hat if it exists",
      "content": "In earlier lessons on Dynamic Fields and Dynamic Object Fields, we have discussed adding new fields dynamically to an existing object. This is a powerful ability that can be used to extend an existing object especially when upgrading an existing Move module.\n\nWhat is upgrading? When a Move module is deployed to the Sui blockchain, its package is assigned an address as discussed in the first course. If we want to add more code and overriding the code at the address we deployed to, we'd need to upgrade the code instead. Upgrading, however, is subject to specific rules depending on which compatibility policy was specified when you deploy the code the first time:\n\n[Compatibility Policies and Rules from Sui's official documentation](https://docs.sui.io/concepts/sui-move-concepts/packages/custom-policies)\n1. Immutable\tNo one can upgrade the package.\n2. Dependency-only\tYou can modify the dependencies of the package only.\n3. Additive\tYou can add new functionality to the package (e.g., new public functions or structs) but you can't change any of the existing functionality (e.g., the code in existing public functions cannot change).\n4. Compatible\tThe most relaxed policy. In addition to what the more restrictive policies allow, in an upgraded version of the package:\n- You can change all function implementations.\n- You can remove the ability constraints on generic type parameters in function signatures.\n- You can change, remove, or make public any private, public(friend), and entry function signatures.\n- You cannot change public function signatures (except in the case of ability constraints mentioned previously).\n- You cannot change existing types (structs).\n\nAs you can see, when upgrading existing code, you cannot change any existing structs! This means if you cannot add new fields or change the names of existing fields. Dynamic fields are the only way you can dynamically extend existing objects/structs so you just need to add new functions or update existing functions to do this.\n\nAs discussed in a previous lesson, it's generally not recommended to add more than 10 dynamic fields as they can be scattered throughout the code and hard to find. There's a good way to fix this and still be able to easily extend existing objects - Group the newly added fields into a single struct:\n```\nuse sui::dynamic_field;\n\nstruct Laptop has key {\n    id: Id,\n}\n\nconst EXTENSION_1: u64 = 1;\n\nstruct PurchaseDetails has store {\n    customer_name: String,\n    street_address: String,\n    price: u64,\n}\n\npublic fun add_purchase_details(laptop: &mut Laptop, customer_name: String, street_address: String, price: u64) {\n    dynamic_field::add(&mut laptop.id, EXTENSION_1, PurchaseDetails {\n        customer_name,\n        street_address,\n        price,\n    });\n}\n```\nWe're extending an existing Laptop struct with PurchaseDetails with 3 new fields. This means we only need to add a single new dynamic field. Note that:\n1. PurchaseDetails is not an object. We don't intend it to ever live separately outside of Laptop so it doesn't make sense to make it an object.\n2. We use the extension number as the key. This will increment if we need to extend the Laptop object multiple times. You can also use a string or other types if desired. \n\nWe can also use the same pattern to augment an object that has been added as a dynamic object field on another object as well:\n```\nuse sui::dynamic_object_field;\nuse sui::dynamic_field;\n\nstruct Laptop has key {\n    id: Id,\n}\n\nstruct Sticker has key, store {\n    id: Id,\n}\n\nconst EXTENSION_1: u64 = 1;\n\nstruct StickerPurchaseDetails has store {\n    customer_name: String,\n    street_address: String,\n    price: u64,\n}\n\npublic fun add_sticker_purchase_details(laptop: &mut Laptop, sticker_name: String, customer_name: String, street_address: String, price: u64) {\n    let sticker: &mut Sticker = dynamic_object_field::borrow_mut(laptop, sticker_name);\n    dynamic_field::add(&mut sticker.id, EXTENSION_1, StickerPurchaseDetails {\n        customer_name,\n        street_address,\n        price,\n    });\n}\n```"
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    struct GiftBox has key {\n        id: UID,\n        object_bag: ObjectBag,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            object_bag: object_bag::new(ctx),\n        };\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, fren);\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, hat);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "7",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Hat};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Update\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}",
      "title": "Object Data Structure - Bag of Mixed Objects",
      "quizTitle": "1. Update the GiftBox struct to use ObjectBag instead of a single field of type SuiFren.\n2. Update wrap_fren to work with the ObjectBag.\n3. Add a wrap_hat entry function that adds a Hat to a GiftBox's ObjectBag.\n\nThe ObjectBag should use an index as the key (first object added has index 0, second has index 1, etc.)",
      "content": "In the previous course, we covered how to wrap a SuiFren object into a GiftBox object.\n```\nstruct GiftBox has key {\n    id: UID,\n    inner: SuiFren,\n}\n\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n```\n\nLet's say we want to make the GiftBox even more of a pleasant surprise by allowing users who open it to potentially receive between 1 and 5 Frens. You might be tempted to create 5 SuiFren fields:\n```\nstruct GiftBox has key {\n    id: UID,\n    inner_1: SuiFren,\n    inner_2: SuiFren,\n    inner_3: SuiFren,\n    inner_4: SuiFren,\n    inner_5: SuiFren,\n}\n```\nThis just looks messy and doesn't really work! This would force a GiftBox to always contain exact 5 SuiFrens. What if we also allow a GiftBox to be a miss and possibly contain no SuiFrens? A better way would be to use a vector:\n```\nstruct GiftBox has key {\n    id: UID,\n    frens: vector<SuiFren>,\n}\n```\nThis is much cleaner! Now each GiftBox can contain any number of SuiFrens, including zero (empty vector). But what if we want to make it even more fun - each GiftBox can contain some number of Hats as well? We can create a second vector of Hats. But you see where we're going with this. If we want a GiftBox to contain a mixed collection of different types of objects, and vector wouldn't work here as it can only contain a single type of objects. It's better to use Object Bag instead!\n```\nuse sui::object_bag::{Self, ObjectBag};\n\nstruct MyBag has key {\n    id: UID,\n    object_bag: ObjectBag,\n}\n\npublic fun create_bag(ctx: &mut TxContext) {\n    transfer::transfer(MyBag {\n        id: object::new(ctx),\n        object_bag: object_bag::new(ctx),\n    }, tx_context::sender(ctx));\n}\n\npublic fun add_to_bag<SomeObject>(my_bag: &mut MyBag, key: String, object: SomeObject) {\n    object_bag::add(&mut my_bag.object_bag, key, object);\n}\n```\nUnder the hood, an ObjectBag uses dynamic object fields to store the objects of different types. The syntax is very similar to dynamic fields - to add an object to a Bag, you need a key of primitive type (such as index of type u64) or structs with copy/drop/store abilities and a value of struct type with key ability (object struct).\n\nThe object_bag module also offers other functions as well such as borrow, borrow_mut, contains (similar to dynamic_field::exists_), length (returns the number of objects in the bag) and is_empty."
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_table::{Self, ObjectTable};\n\n    struct GiftBox has key {\n        id: UID,\n        sui_frens: ObjectTable<u64, SuiFren>,\n        hats: ObjectTable<u64, Hat>,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            sui_frens: object_table::new(ctx),\n            hats: object_table::new(ctx),\n        };\n        let index = object_table::length(&gift_box.sui_frens);\n        object_table::add(&mut gift_box.sui_frens, index, fren);\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_table::length(&gift_box.hats);\n        object_table::add(&mut gift_box.hats, index, hat);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "8",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_table::{Self, ObjectTable};\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        object_bag: ObjectBag,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            object_bag: object_bag::new(ctx),\n        };\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, fren);\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, hat);\n    }\n}",
      "title": "Object Data Structures - ObjectTable",
      "quizTitle": "Using ObjectBag is still better, but just for the sake of practice:\n1. Replace ObjectBag in GiftBox with two separate ObjectTables, one for SuiFrens and one for Hats. The keys are string u64 (index).\n2. Update all functions to work with ObjectTables",
      "content": "Another cool data structure you can use to store objects is ObjectTable. This is different from ObjectBag and only allows a single type of objects. Although ObjectTable is more limited, it can be still be useful when user wants to assign specific key name for the different objects of the same type in the table.\n```\nuse sui::object_table::{Self, ObjectTable};\n\nstruct MyObject has key, store {\n    id: UID,\n}\n\nstruct MyTable has key {\n    id: UID,\n    table: ObjectTable<String, MyObject>,\n}\n\npublic fun create_table(ctx: &mut TxContext) {\n    transfer::transfer(MyTable {\n        id: object::new(ctx),\n        table: object_table::new(ctx),\n    }, tx_context::sender(ctx));\n}\n\npublic fun add_to_table(my_bag: &mut MyBag, key: String, object: MyObject) {\n    object_table::add(&mut my_bag.object_bag, key, object);\n}\n```\nUnder the hood, ObjectTable also uses dynamic object fields, similar to ObjectBag. When defining the object table field, we also need the exact types for the key and value.\n\nObjectTable also offers the same functions as ObjectHat: add, contains, remove, borrow, borrow_mut, length, and is_empty."
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    entry fun create_gift(ctx: &mut TxContext) {\n        let sui_fren = sui_fren::create_random(ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            sui_fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    public(friend) fun create_random(ctx: &mut TxContext): SuiFren {\n        let object_id = object::new(ctx);\n        let bytes = object::uid_to_bytes(&object_id);\n        let power = bcs::peel_u64(&mut bcs::new(bytes));\n        SuiFren {\n            id: object_id,\n            power,\n        }\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "9",
      "codeDef": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new function here\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    // Add the new function here\n}",
      "title": "Object ids and address",
      "quizTitle": "Let's make the giftbox a bit more fun. Instead of wrapping an existing SuiFren, let's create one randomly when the GiftBox is created!\n1. Add a create_random public friend function to the sui_fren module that generates a SuiFren with a randomly generated power. create_random takes a single context param and returns the SuiFren object created.\n2. Add a new entry function create_gift to fren_summer module to create a gift box, call sui_fren::create_random to create the wrapped SuiFren object, and sends it the transaction's sender.\n3. Only fren_summer::create_gift can call sui_fren::create_random",
      "content": "We have been learning a lot of cool tricks we can do with objects. One fundamental aspect of object that we want to dive deeper into is object id.\n\nHave you wondered how an object's id and address are created? Technically an object's id and address are one and the same - they are unique identifiers that can allow developers to identify and fetch data from the objects. This is the case both on-chain (in Move) and off-chain (via web UI querying all data and fields for an object):\n```\npublic fun get_object_id_from_address(object_addr: address): ID {\n    object::id_from_address(address)\n}\n\npublic fun get_object_address(object: &MyObject): address {\n    object::id_to_address(&object.id)\n}\n```\nNote that the returned type for object's id is ID, which is different from the UID field that every object struct has. However, you can use object::uid_to_inner to convert a UID reference to ID. This allows comparing to check if an object is the same as a stored address.\n\nWhen an object is created, its id field is generated via object::new(ctx) where ctx is a mutable reference of type TxContext passed to the transaction by the Sui Virtual Machine (VM). Here's the code for it:\n```\npublic fun new(ctx: &mut TxContext): UID {\n    UID {\n        id: ID { bytes: tx_context::fresh_object_address(ctx) },\n    }\n}\n```\nAs you can see, behind the scene, a unique address is first generated with tx_context::fresh_object_address(ctx), then converted into bytes to create the object's id. fresh_object_address is a special type of function in Move - native function. Native functions are special as their implementation is written in Rust as part of the Move VM. This allows the function to run faster and have access to inner constructs of the VM. In this case, fresh_object_address can see the user's <b>transaction payload<b> and use it to generate a special address for the object. It also uses a counter that tracks how many objects have been created so far in the same transaction. fresh_object_address then hashes the tx payload and the counter and ensures that the result is unique even among the multiple objects created in the same transaction.\n\nOne interesting use case of the address generation process is to potentially use it as a source of randomness - the bytes generated from a newly created object's id can be used as a random value. This is typically because the hash of the transaction payload and counter often seems random (not following any pattern):\n```\nuse sui::bcs;\n\npublic fun get_random_value(ctx: &mut TxContext): u64 {\n    let object_id = object::new(ctx);\n    let bytes = object::uid_to_bytes(&object_id);\n    let random_number = bcs::peel_u64(&mut bcs::new(bytes));\n    object::delete(object_id);\n    random_number\n}\n```\nget_random_value can be called multiple times to create pseudo-random numbers (seemingly random). This could be used generally as a source of random values depending on use case, but is potentially dangerous to use as it could be manipulated by the user. They can change the expiration timestamp and other fields in the transaction in order to generate desired object ids and the resulting random number (for example to win an on-chain lottery). It could be safer to include the timestamp (from the system object Clock) but this still has risks:\n1. The user can still manipulate the random value to some extend (not as much as before as they have no control over the Clock object).\n2. The validators can partially manipulate the random value as well as they can set the timestamp of the Clock object to a specific value within a small range of margin of error.\n\nWe'll cover safer ways to generate random values in later courses."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Dynamic Fields and Objects owning Objects",
          "isCorrect": false
        },
        {
          "answer": "B. Objects owning Objects and Objects data structures",
          "isCorrect": false
        },
        {
          "answer": "C. Objects data structures and Dynamic Fields",
          "isCorrect": true
        }
      ],
      "lessonId": "10",
      "codeDef": "",
      "title": "Object Design Pitfall: Too Many Objects",
      "quizTitle": "What are some good approaches to reduce the number of objects an application creates?",
      "content": "Similar to what was discussed earlier regarding too many contract state objects, a common pitfall that some developers run into is to create too many objects. For example, in the case of a Laptop, you can technically create a separate object for each Laptop component such as screen, keyboard, hard drive, etc.:\n\n```\nstruct Laptop has key {\n    id: UID,\n    screen: Screen,\n    keyboard: Keyboard,\n    hard_drive: HardDrive,\n}\n\nstruct Screen has key, store {\n    id: UID,\n}\n\nstruct Keyboard has key, store {\n    id: UID,\n}\n\nstruct HardDrive has key, store {\n    id: UID,\n}\n```\nAs you can see, every component is a separate object. This is not necessary as Screen, Keyboard, and HardDrive objects are always wrapped into the Laptop object. They are never separated out into standalone objects. This kind of design only makes sense if we intentionally want to sell Keyboard as a separate component that can be integrated into another Laptop. This could be desired if we're running a hardware store, but this is a laptop store only.\n\nSome other issues with a Move module creating too many objects:\n1. It's hard to understand a transaction if it creates and changes too many objects. To users who view these transactions on an explorer UI, all they see is a very long list of all objects that are updated or have been created, and all of their associated fields/data. This can be overwhelming if the list has 10+ objects.\n2. If users need to interact with multiple of these objects, it can make the transaction complex to construct as the UIs would then need to find and pass the addresses for all of the objects involved.\n\nBeside using dynamic fields similar to what we covered in the lesson on managing state objects, developers can also use data structures such as ObjectBag and ObjectTable as covered earlier to store multiple objects if they really want to create many different types of objects. These can collect many objects into a single container object that can be easily understood and passed around."
    },
    {
      "codeSol": "",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "11",
      "codeDef": "",
      "title": "Summary",
      "quizTitle": "",
      "content": "Different approaches to combine objects \n1. **Object wrapping**\n- Store objects within another objects (for example SuiFrens in GiftBoxes). This removes the wrapped objects (SuiFrens) from global storage. Off-chain web UI cannot look them up after wrapping. The object no longer has any owner. You can think of this almost as converting an object into a normal non-object struct instance.\n\n2. **Dynamic Fields** could be understood as invisible fields that are not explicitly defined on an object struct.\n- Can be used to store objects as well. This also removes the object from global storage. Ownership is also removed. Very similar to object wrapping, except that the field is added dynamically instead of explicitly defined in the struct.\n- In order to add dynamic fields to an object, you need a mutable reference to that object. Adding a dynamic field can be done simply via dynamic_field::add with the mutable object's id, the key and the value.\n- To read or modify a dynamic field, you need an immutable and mutable references to the object respectively and the field name (key). If the field name is a struct, you need the struct value itself, which is why the structs used as keys must have copy and drop abilities.\n- Dynamic object fields are preferred over dynamic fields to store objects dynamically. You should only use dynamic fields if you intentionally want to remove the objects from global storage.\n\n3. **Dynamic Object Fields**\n- Does not remove the object from global storage. Ownership is transferred to the special \"dynamic field object\" that is generally not easy to look up for Web UIs. In most cases, this has almost the same effect as forfeiting ownership of the object.\n\n4. **Objects own other objects**\n- Perfect use case is composable NFTs. This allows for powerful composition of NFTs together that make natural sense to users and is often seen in Web 3 Games that use NFTs.\n- Use when there is clear indication of object hierarchy in a complex application design with multiple types of objects.\n- There is a drawback which is it's harder to remove the owned object later. Therefore, objects owning objects is generally more useful if the relationship is rarely or never changed.\n\nInteresting object data structures: \n1. **Object bag**: a versatile data structure for storing a mixed collection of different object types - useful for applications requiring flexible and varied object compositions, such as randomized or composite NFTs.\n2. **Object table**: a data structure for storing collections of a single object type with specific key names - beneficial for applications that require structured and named collections of similar objects."
    }
  ],
  "title": "Advanced Objects"
}

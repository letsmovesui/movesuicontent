{
  "curStatus": "ready",
  "description": "",
  "id": "5",
  "lesson": [
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Coin has more functions",
          "isCorrect": false
        },
        {
          "answer": "B. Coin has built-in tracking",
          "isCorrect": false
        },
        {
          "answer": "C. Coin offers full implementation developers can use without writing much code",
          "isCorrect": true
        }
      ],
      "lessonId": "1",
      "codeDef": "",
      "title": "Introduction to Tokens, ERC-20, and Coins",
      "quizTitle": "Why is the Coin standard on Sui better than ERC-20 on EVM chains?",
      "content": "In previous courses, we have covered most of the fundamental concepts that developers need to get started in Move. In this lesson, we will dive into a more practical topic and one of the two most common types of core building blocks in blockchains - Tokens.\n\nTokens play a pivotal role in the world of cryptocurrencies, serving as digital representations of value or assets. They are akin to digital certificates that grant ownership or access to various assets, both tangible and virtual, all recorded securely on a blockchain. One prominent standard for these tokens on the Ethereum blockchain is ERC-20.\n\n**Tokens** These digital assets exist solely in electronic form on blockchains, decentralized digital ledgers. They represent something valuable, whether it's a cryptocurrency, a share in a company, a voting right in a decentralized organization, or even a virtual collectible item in a game. Tokens can be transferred or traded on the blockchain, their ownership and transactions transparently recorded. Some tokens, thanks to smart contracts, automate processes like dividend distribution or access to services within specific ecosystems. Initial Coin Offerings (ICOs) often use tokens as a means of fundraising, where investors purchase them with the expectation of future value appreciation.\n\n**ERC-20** One of the first specifications of how a Token should be implemented, the ERC-20 standard defines a set of interface functions that tokens on the Ethereum blockchain must adhere to. These functions provide a common framework for interacting with tokens and ensure interoperability between different applications and wallets. Here's a summary of the most important ERC-20 interface functions:\n\n1. `totalSupply()`: This function returns the total supply of tokens in circulation.\n2. `balanceOf(address _owner)`: It allows you to check the balance of tokens owned by a specific Ethereum address.\n3. `transfer(address _to, uint256 _value)`: This function enables the transfer of a specified amount of tokens from the sender's address to another address.\n\nAlthough the ERC-20 standard is simple to implement, all developers would need to provide their own implementation and end up writing almost the same code again and again. This is due to a limitation in the Ethereum network (and many other EVM networks) that there are no core smart contracts that can serve as libraries for developers to use, similar to the core libraries in many languages such as Java.\n\nSui Move solves this issue by defining the [Coin standard](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move) directly at 0x2 and allowing developers to directly define and manage tokens easily without having to rewrite the implementation every time. A Token on the Sui network is called a Coin.\n\nAnother key design principle in how Coin is designed is to reflect the natural design of money in the real word. When someone receives $1 for example, they can put this $1 into their pocket and retrieve it later. This is not the case with token balances in EVM chains where the balances are all recorded inside the smart contract that defines the USDC token (dollar-pegged token). This centralized balance design more resembles a bank deposit system where all balances are only defined in the bank system. This creates a lot of confusion for users who are new to crypto as they think their wallets (e.g. hardware wallets) actually hold the various tokens inside them.\n\nIn Sui Move, **Coin** is more natural and easier to understand - when a user receives Coins, the Coins are actually stored in an object (can be thought of as a wallet) that belongs to that user. They can later easily retrieve Coins from this object and use them however they want."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "2",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n\n    // Update\n    fun init(ctx: &mut TxContext) {\n    }\n}",
      "title": "SuiFren Candy - Creating a new Coin type",
      "quizTitle": "Let's make SuiFrens more fun and introduce a Candies as a coin that can be fed to SuiFrens to increase their fighting power.\n1. Add a new Candy coin type to the `sui_fren` module\n2. Update the init to create the new Candy Coin. For now, let's send both the metadata and TreasuryCap objects to the sender\nThe Candy coin's metadata is as follows:\n* \"CANDY\" as the symbol\n* SuiFren Candy\" as the name\n* \"Candies to level up SuiFren\" as the description\n* No logo (option::none())",
      "content": "In Sui Move, there's only a single module (smart contract) that developers need to call from their call to create and manage their coins. In order to differentiate between different types of coins that different developers create, Coin uses generics (type arguments):\n\n```\n/// Get immutable reference to the balance of a coin.\npublic fun balance<T>(coin: &Coin<T>): &Balance<T> {\n    &coin.balance\n}\n```\nThe above function is used to check the balance of a user's owned Coin wallet object. Note that there's a ```<T>``` at the end of the function name. This is a type argument that specifies which coin wallet the function is being called for, which can be ```Coin<MYCOIN>``` or ```Coin<YourCoin>```.\n\n In order to create a coin, developers first need to define this Coin type as a struct in their module:\n```\nmodule my_coin::my_coin {\n    struct MYCOIN has drop {}\n}\n```\nThis is similar to [how the SUI coin is also defined](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/sui.move).\n\nThe developers can then create the new coin by calling `coin::create_currency`, usually as part of the init function because you need a one-time witness (otw) object of the Coin type (MYCOIN in this case):\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n```\n`coin::create_currency` returns a metadata object that stores information about the coin: Symbol (what the Coin will be displayed shortly as), name, description and logo URL. This allows off-chain components such as Web UI to look this information up and display them. The developers can choose to freeze the metadata object, which no longer allows the name/symbol/etc. to change or keep it owned and transfer to an account for later management (More on this in a later lesson).\n\n`coin::create_currency` also returns the TreasuryCap object that can be used to manage the coins. We'll talk more about this in a later lesson.\n\nWith the Coin now created, developers can use ```NYCOIN``` as the Coin type argument when calling coin functions, for example:\n \n```\npublic fun my_coin_balance(coin: &Coin<MYCOIN>): &Balance<MYCOIN> {\n    // <MYCOIN> is technically not required here as the type can be inferred.\n    // It's just included explicitly for demonstration purposes.\n    coin::balance<MYCOIN>(coin)\n}"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    entry fun mint(treasury_cap: &mut TreasuryCap<CANDY>, amount: u64, ctx: &mut TxContext) {\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "3",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    // Add the mint function here\n}",
      "title": "Minting SuiFren Candies with the TreasuryCap object",
      "quizTitle": "Add a `mint_candy` entry function to the `sui_fren` module that mints Candy coins to the sender. For now only the `TreasuryCap<Candy>` owner can call it. The mint function should takes the treasury cap object, an amount of type `u64` and any other system object arguments as needed.",
      "content": "In the previous lesson, we created our first `Coin` and temporarily transfer to the `TreasuryCap` object to the sender (deployer of the module). With this `TreasuryCap`, this account can now mint `MYCOIN` coins:\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",\n        option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n\nentry fun mint(treasury_cap: &mut TreasuryCap<MYCOIN>, ctx: &mut TxContext) {\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nThere are four important things to call out:\n1. `coin::mint` creates a new Coin (wallet) object. This means that existing balances in other wallets of the user will not change.\n2. If you recall, owned objects are verified when passed in as arguments to transaction and only their owners can do so. In this case, only the account that owns `TreasuryCap<MYCOIN>` can call mint.\n3. `TreasuryCap` has a type argument too (`MYCOIN`). This specifies which coin type the treasury cap manages.\n4. `coin::mint` doesn't need to specify MyCoin as the type argument as the compiler can infer that from the `treasury_cap` (of type `TreasuryCap<MYCOIN>`).\n\nAlso note that the type of the `TreasuryCap` is a fully qualified type name - `0x123::my_coin::MYCOIN` if our module's address is `0x123` in the example. This means if someone else creates a `MYCOIN` struct in their module, that would be treated as a completely different coin even if the struct name is the same. Beside `coin::mint`, developers can also use `coin::mint_and_transfer` to directly mint to a specific account.\n\nAnother common pattern is to mint the initial allocation of coins in the `init` function:\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    coin::mint_and_transfer(treasury_cap, 1000000, tx_context::sender(ctx), ctx);\n    \n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n```\nThis allows developers to create an initial amount of coins for circulation. They can optionally implement a mint function to create more coins later."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "4",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    // Add the new struct here\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    entry fun mint(treasury_cap: &mut TreasuryCap<Candy>, amount: u64, ctx: &mut TxContext) {\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
      "title": "Programmatic Coin minting",
      "quizTitle": "Create a `CandyTreasuryCapHolder` object struct and update `sui_fren::init` and mint functions to use it to allow users to freely mint candies.",
      "content": "We have learnt how to use the generated `TreasuryCap<CoinType>` object to mint the coins. However, only the `TreasuryCap` owner can call it. What if we want to allow users to freely mint coins (may be up to a certain limit)? How would this work?\n\nIf you look at how the `TreasuryCap` object struct is defined, it has the store ability:\n```\n/// Capability allowing the bearer to mint and burn\n/// coins of type `T`. Transferable\nstruct TreasuryCap<phantom T> has key, store {\n    id: UID,\n    total_supply: Supply<T>\n}\n```\nThis means, it can be stored in other structs and objects! So the solution here would be to wrap it in a shared object that anyone can access and provide as an argument to the mint function:\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct TreasuryCapHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n}\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    \n    let treasury_cap_holder = TreasuryCapHolder {\n        id: object::new(ctx),\n        treasury_cap,\n    };\n    transfer::share_object(treasury_cap_holder);\n}\n\nentry fun mint(treasury_cap_holder: &mut TreasuryCapHolder, ctx: &mut TxContext) {\n    let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nIn the example above, we wrap `TreasuryCap<MYCOIN>` inside a shared `TreasuryCapHolder` object. Anyone can now passes `&mut TreasuryCapHolder` to the mint function and mint `MYCOIN` coins freely. In practice, the developers should add some restrictions such as how many coins can be minted in total, how many each user can mint, allowlist-based control, etc.\n\nAs discussed in the `Object` courses, beside wrapping the `TreasuryCap` object into another holder object, we can also leverage dynamic fields, dynamic object fields or even object ownership to retain the `TreasuryCap`. However, wrapping is generally preferred because of its simplicity when accessing."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    entry fun transfer_half_candies(from: &mut Coin<CANDY>, to: &mut Coin<CANDY>, ctx: &mut TxContext) {\n        let half_coins = coin::take(coin::balance_mut(from), coin::balance(from) / 2, ctx);\n        coin::put(coin::balance_mut(to), half_coins);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "5",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<Candy>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    // Add the new function here\n}",
      "title": "Coin vs Balance - take, put, transfer, zero, destroy_zero",
      "quizTitle": "Add a `transfer_half_candies` entry function that transfers half of the candies in a `Coin` object (named from) to another `Coin` object (named to)",
      "content": "One of the common confusions new developers often have about `Coin` in Sui is that there's a `Balance` object that looks similar:\n```\nstruct Coin<phantom T> has key, store {\n    id: UID,\n    balance: Balance<T>\n}\n\n/// Storable balance - an inner struct of a Coin type.\n/// Can be used to store coins which don't need the key ability.\nstruct Balance<phantom T> has store {\n    value: u64\n}\n```\nWhat exactly is the difference between `Coin` and `Balance` and when should we use either? The best comparison here is:\n1. `Coin` object is more like a wallet. The `Coin` wallet has an inner balance and cash (`Balance`) can be taken out of it and deposited into another `Coin` wallet object.\n2. `Balance` is like cash only. It cannot be stored alone and needs to be put into wallets or pockets. Developers can choose to create their own \"pocket\" objects to store Balance\n\nTechnically, since the `Coin` object  also has the store ability, developers can put the entire `Coin` wallet into their own custom objects as well. However, it is quite strange to do so and `Balance` should be used in that case as `Coin` is already like a container. Furthermore, putting (wrapping Coin wallet objects) into another object effectively removes it from object global storage like we discussed in the `Object` courses. This is generally not desired as it can make wallets \"disappear\".\n\n```\nentry fun transfer_coins(from_wallet: &mut Coin<MYCOIN>, amount: u64, to_wallet: &mut Coin<MYCOIN>, ctx: &mut TxContext) {\n    let cash = coin::take(coin::balance_mut(from_wallet), amount, ctx);\n    coin::put(coin::balance_mut(to_wallet), cash);\n}\n```\nIn the example above, we take some coins from the `from_wallet` Coin object and deposit it into the `to_wallet` Coin object. Note that only the owner of both `from_wallet` and `to_wallet` can call `transfer_coins`. We need to use `coin::balance_mut` to get to the inner balance of a `Coin` object as a struct fields are not visible outside of the defining module (coin in this case).\n\nThe `Coin` module in Sui doesn't offer direct transfer from one `Coin` object to another. Developers would need to manually use take + put to accomplish a transfer.\n\nSome other functions of notes in the coin module are:\n1. `balance(&Coin)`: returns the balance of a `Coin` object.\n2. `zero()` which creates a Coin object with zero balance (empty wallet)\n3. `destroy_zero()` - destroys an empty wallet. A wallet with non-zero balance cannot be destroyed and you'd need to move the coins there somewhere else first."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Coin can be a standalone object but Balance cannot",
          "isCorrect": true
        },
        {
          "answer": "B. Coin doesn't have the store ability while Balance does",
          "isCorrect": false
        },
        {
          "answer": "C. Balance has the key ability while Coin doesn't",
          "isCorrect": false
        }
      ],
      "lessonId": "6",
      "codeDef": "",
      "title": "More Balance functions",
      "quizTitle": "What's the technical difference between `Coin` and `Balance`?",
      "content": "The `sui::balance` module where `Balance` object is defined also offers a few functions of note:\n\nvalue returns the number of coins in a `Balance` object:\n```\n/// Get the amount stored in a `Balance`.\npublic fun value<T>(self: &Balance<T>): u64 {\n    self.value\n}\n```\n\njoin takes a mutable balance and another balance and added the second balance to the first:\n```\n/// Join two balances together.\npublic fun join<T>(self: &mut Balance<T>, balance: Balance<T>): u64 {\n    let Balance { value } = balance;\n    self.value = self.value + value;\n    self.value\n}\n```\n\n`split` extracts an amount of coins from a mutable balance and creates a second balance:\n```\n/// Split a `Balance` and take a sub balance from it.\npublic fun split<T>(self: &mut Balance<T>, value: u64): Balance<T> {\n    assert!(self.value >= value, ENotEnough);\n    self.value = self.value - value;\n    Balance { value }\n}\n```\n\n`withdraw_all` is similar to split but extracts all of the coins from the mutable balance, leaving it empty:\n```\n/// Withdraw all balance. After this the remaining balance must be 0.\npublic fun withdraw_all<T>(self: &mut Balance<T>): Balance<T> {\n    let value = self.value;\n    split(self, value)\n}\n```\n\nWith these different functions, developers can create more complex operations on balances after they're taken from a user's owned `Coin` object. Balances can be split and joint to divide an amount of coins into smaller portions and send them to different wallets. This is commonly seen when processing fees for example:\n\n```\n/// Withdraw all balance. After this the remaining balance must be 0.\npublic fun trade(wallet: &mut Coin<Sui>, amount: u64) {\n    let coins_to_trade = balance::split(coin::balance_mut(wallet), amount);\n    // 1% fee.\n    let fees = balance::split(&mut coins_to_trade, amount / 100);\n    // Deposit the fee somewhere and continue with the trade.\n}\n```"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n        power: u64\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    entry fun feed_candies(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, sui_fren: &mut SuiFren, candies: Coin<CANDY>) {\n        let amount = coin::value(&coins);\n        sui_fren.power = sui_fren.power + amount;\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::burn(treasury_cap, coins);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "7",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n        power: u64\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    // Add the new function here\n}",
      "title": "Burning Coins",
      "quizTitle": "Add a feed_candies function that take a `SuiFren`, a `Coin<CANDY>`, add the amount to the `SuiFren`'s power, and burn the candies.",
      "content": "In the previous lessons, we have discussed how `Coins` can be minted with the `TreasuryCap`.\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct TreasuryCapHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n}\n\nentry fun mint(treasury_cap_holder: &mut TreasuryCapHolder, ctx: &mut TxContext) {\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nWe can burn using `TreasuryCap` as well:\n```\nentry fun burn(treasury_cap_holder: &mut TreasuryCapHolder, coins: Coin<MYCOIN>) {\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    coin::burn(treasury_cap, coins);\n}\n```\n\n`coin::burn` will burn all coins in the given `Coin` object and also destroys the `Coin` object itself. This is equivalent to burning the entire wallet. If developers instead just want to burn a specific amount from a Coin object, they need to extract that amount out first and just burn those specific coins:\n```\nentry fun burn(treasury_cap_holder: &mut TreasuryCapHolder, coins: &mut Coin<MYCOIN>, amount: u64, ctx: &mut TxContext) {\n    let coins_to_burn = coin::take(coin::balance_mut(coins), amount);\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    coin::burn(treasury_cap, coins_to_burn);\n}\n```"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n        metadata: CoinMetadata<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun update_icon_url(holder: &mut CandyTreasuryCapHolder, new_icon_url: String) {\n        let metadata = &mut holder.metadata;\n        let treasury_cap = &holder.treasury_cap;\n        coin::update_icon_url(treasury_cap, metadata, new_icon_url);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "8",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n}",
      "title": "Updating Coin metadata",
      "quizTitle": "Add a metadata field to the `CandyTreasuryCapHolder` object and update the `init` function accordingly. Add a `update_icon_url` entry function that allows changing the Candy coin's icon url.\nHint: You can use `option`",
      "content": "When we created `MyCoin` earlier, we froze the metadata object returned. This would not allow for any changes to the metadata (decimals/symbol/name/description/logo url) in the future.\n\nSpeaking of decimals, we never really explained what it's for. `Decimals` are often used for Coins/tokens in order to reduce rounding errors. Most smart contract languages, including Move, do not have fractional numbers and all math operations are integer-based. This means 5 / 2 = 2 in Move, leading to a rounding error of 1. If there are no decimals, people would be losing a lot of money left and right. A decimals of at least 6 is often used in crypto and can be sometimes as high as 18 (1 coin = 10^18 units). In most cases, 9 is more than sufficient to make the rounding error small and negligible to users.\n\nBack to the metadata object, if you think there could be a chance you might want to change the coin's metadata in the future, you should not freeze it and instead transfer to an admin account for safekeeping. In the future, you can then leverage the different functions in coin to update the metadata you want:\n\n```\n/// Update name of the coin in `CoinMetadata`\npublic entry fun update_name<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, name: string::String\n) {\n    metadata.name = name;\n}\n\n/// Update the symbol of the coin in `CoinMetadata`\npublic entry fun update_symbol<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, symbol: ascii::String\n) {\n    metadata.symbol = symbol;\n}\n\n/// Update the description of the coin in `CoinMetadata`\npublic entry fun update_description<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, description: string::String\n) {\n    metadata.description = description;\n}\n\n/// Update the url of the coin in `CoinMetadata`\npublic entry fun update_icon_url<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, url: ascii::String\n) {\n    metadata.icon_url = option::some(url::new_unsafe(url));\n}\n```\nNote that decimals is a special case and there's no update function for it. This is because decimals is a fundamental property of a coin and can change everyone's balance if it's updated. Therefore, for safety and simplicity, Sui's Coin standard doesn't allow modifying decimals.\n\nIn order to call an update function such as `coin::update_symbol`, the caller needs to have access to both `TreasuryCap` and `metadata` object. Note that both `TreasuryCap` and `Metadata` structs have the store ability so we can store them somewhere that allows programmatic access and modification later on:\n\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct CoinDataHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n    metadata: CoinMetadata<MYCOIN>,\n}\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    \n    let treasury_cap_holder = TreasuryCapHolder {\n        id: object::new(ctx),\n        treasury_cap,\n        metadata,\n    };\n    transfer::share_object(treasury_cap_holder);\n}\n\nentry fun update_symbol(holder: &mut CoinDataHolder, new_symbol: String) {\n    let metadata = &mut holder.metadata;\n    let treasury_cap = &holder.treasury_cap;\n    coin::update_symbol(treasury_cap, metadata, new_symbol);\n}\n```\nIn the example above, we wrap both the `TreasuryCap` and the `Metadata` objects into a shared object that can be accessed by anyone later to update coin metadata. In practice, developers can add logic that require the sender to be a specific admin address to make sure suers don't arbitrarily update coin metadata."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Balances cannot be joint while Coins can",
          "isCorrect": false
        },
        {
          "answer": "B. Coins cannot be joint while Balances can",
          "isCorrect": false
        },
        {
          "answer": "C. Newly created Coins can be sent to accounts while Balances have to be merged",
          "isCorrect": true
        }
      ],
      "lessonId": "9",
      "codeDef": "",
      "title": "Managing multiple Coin objects - join and split",
      "quizTitle": "What's the difference between `Coin` and `Balance` when it comes to merging and splitting?",
      "content": "Image that each time you interact with an application and it creates a new `Coin` object to store the refund or payment to your account. After a day of interacting with them, you end up with 100 different `Coin` objects. Now your coins are both split into 100 different parts and you no longer have enough coins to do more interactions. What do you do now?\n\nThere are two solutions to this:\n1. Applications and developers avoid creating new coins as much as possible unless needs be. They should instead make an attempt to take an existing Coin from the user to combine the refunds/payments into.\n2. Users can merge the coins together, as part of the last step in their PTB (Programmable Transaction Block).\n\nIn Move, coins can also be easily split and joint with `coin::split` and `coin::join`\n```\npublic fun trade(input_coins: &mut Coin<SUI>) {\n    let refund_coins - ...;\n    coin::join(input_coins, refund_coins);\n}\n```\nCoins and also be split. However, remember the created `Coin` either has to merged into some other coins or they need to be sent to an account. This is because `Coin` doesn't have the store ability and cannot be dropped at the end of the function.\n```\npublic fun split_and_send(input_coins: &mut Coin<SUI>, ctx: &TxContext) {\n    let refund_coins = coin::split(input_coins, 1000);\n    transfer::public_transfer(refund_coins, tx_context::sender(ctx));\n}\n```\nYou might also notice that this is similar to `balance::split` and `balance::join` that we learnt about in previous lessons. Except for of course that these functions deal with different types - Coin and Balance, they are almost identical in behavior in Move. However, coin's functions are used more in PTB (Programmable Transaction Blocks) as applications often return Coins instead of Balances while `balance::split` and `balance::join` are used more as part of Move flows."
    },
    {
      "codeSol": "module 0x123::candy_drop {\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    struct MintCandiesEvent has copy, drop {\n        user: address,\n        amount: u64,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_freeze(metadata));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun mint(holder: &mut CandyTreasuryCapHolder, amount: u64) {\n        let sender = tx_context::sender(ctx);\n        assert!(is_allowlisted(sender), ENOT_NOT_ALLOWLISTED);\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n        event::emit(MintCandiesEvent {\n            sender,\n            amount,\n        })\n    }\n\n    fun is_allowlisted(user: address, ctx: &mut TxContext): bool {\n        // You don't need to implement this\n    } \n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "10",
      "codeDef": "module 0x123::candy_drop {\n    // Implement here\n\n    fun is_allowlisted(user: address): bool {\n        // You don't need to implement this\n    } \n}",
      "title": "Candy drop - a simple Coin airdrop module",
      "quizTitle": "Let's put this all into a simple airdrop module for our `SuiFren` candies:\n1. Create a new module `candy_drop` that defines the `Candy` coin (we'll keep it here instead of in `sui_fren`)\n2. Implement an init function to create the coin and store the `TreasuryCap`. `Metadata` should be frozen as we'd not change anything later.\n3. Add a mint entry function that allows users to freely mint a given amount (`u64`) of candies if they're added to an allowlist of where the airdrop can be added in. You don't have to implement the allowlist, just assume there's an existing function called `is_allowlisted` that takes an address and returns true if the address is on the allowlist. We'll cover how to implement this in a later lesson.\nYou can use `assert!(condition, ENOT_NOT_ALLOWLISTED);`\n5. The mint function should also emit an event at the end of type `MintCandiesEvent` with two fields - `user` (set to the transaction sender) and `amount`.",
      "content": "We have gone through a lot of useful concepts about Coins in the previous lessons:\n1. Creating a new coin with `coin::create_currency` returns the `TreasuryCap` used to mint/burn/update metadata and the metadata objects.\n2. `Coins` are like wallets and can split, joint. Balances are like cash and can be moved from one `Coin` to another\n3. `TreasuryCap` and `Metadata` objects can both be stored for programmatic access without the need for a single owner account to keep having to sign transactions"
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::coin::{Self, Coin};\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n        candies: Balance<CANDY>,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut holder.treasury_cap;\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n            candies: coin::mint(treasury_cap, amount, ctx),\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun open_gift(gift_box: GiftBox, ctx: &mut TxContext) {\n        let GiftBox { id, sui_fren, candies } = gift_box;\n        object::delete(id);\n        transfer::public_transfer(sui_fren, tx_context::sender(ctx));\n        let candy_coins = coin::from_balance(candies, ctx);\n        transfer::public_transfer(candy_coins, tx_context::sender(ctx));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "11",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}",
      "title": "Storing Balance and Coin in custom objects",
      "quizTitle": "1. Update the `GiftBox` object we created in the previous course to contain a single `SuiFren` and an amount of `candies (coins)` as `Balance<CANDY>`\n2. Update `create_gift` function to generate the indicated amount of candies in the gift box\n3. Add a `open_gift` function that destroys the gift box and sends both the `SuiFren` and the candies to the sender.",
      "content": "As discussed in previous lessons, both `Coin` and `Store` objects have the store ability and can be embedded inside other structs (\"wrapped\" in Coin's case since it's an object struct).\n```\nstruct MyObjectWithBalance has key {\n    id: UID,\n    balance: Balance<MYCOIN>,\n}\n\nstruct MyObjectWithCoin has key {\n    id: UID,\n    coins: Coin<MYCOIN>,\n}\n```\nAs discussed in the previous lesson, it might be more common to store `Balance` instead of `Coin`. But why would someone store `Balance` in a custom struct? The most common reason for this structure is to have coins that are programmatically owned by a smart contract or module. For example, users can be building a marketplace where users can list their own `Coins` to trade against other `Coins`. In this case, when a buyer comes along, we don't want the seller to also have to sign the buy transaction. It's a lot smoother if the buyer just signs and the trade automatically happens - they receive the coins they're buying and the coins they're paying with are taken out of their wallet (`Coin` object).\n```\nstruct Listing<phantom CoinType> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<CoinType>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<CoinType>(listing: Listing<CoinType>, payment: Coin<SUI>): Balance<CoinType> {\n    let Listing<CoinType> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nIn the example above, the seller can create a listing to include the coins they want to sell directly as a shared object. The listed coins are included in the listing object. Once a buyer comes along with the payment, the listing can be destroyed to return the inner listed coins as `Balance<CoinType>`. In the PTB (Programmable transaction block), the seller can choose to merge `Balance<CoinType>` into any of the Coin objects of the same type they own.\n\nNote that `CoinType` is preceded by the phantom keyword. This is required because none of Listing's fields is directly of type CoinType. We see `Balance<CoinType>` but `CoinType` is used as a generic here instead of a direct type. In short, the phantom keyword is required for a struct if the type is only used as a generic in one or more of its fields.\n\nNote that we use the generic `<CoinType>` here so this system would work for any coin types!"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Coin has more functions",
          "isCorrect": false
        },
        {
          "answer": "B. Coin has built-in tracking",
          "isCorrect": false
        },
        {
          "answer": "C. Coin offers full implementation developers can use without writing much code",
          "isCorrect": true
        }
      ],
      "lessonId": "12",
      "codeDef": "",
      "title": "The SUI Coin and paying gas and Sponsored Transaction",
      "quizTitle": "What can a user do if they don't have enough Sui balance to pay for gas for their transaction?",
      "content": "We only briefly covered Coin<SUI> in the previous lessons but didn't delve much into it. Let's explore what SUI coin is in this lesson. In short, the main purpose of SUI on the Sui network is to pay \"gas\" for transactions and as a currency.\n\nThe SUI coin's `TreasuryCap` is kept inside the Sui framework for the purpose of issuing rewards to the network as part of their [tokenomics](https://docs.sui.io/concepts/tokenomics). No single user or account has access to the `TreasuryCap` and minting/burning of the Sui coins is governed by the Sui network via the \"system\" smart contracts deployed at `0x3`.\n\n# Gas\nIn the blockchain world, **gas** refers to the fee required for performing actions, like transactions or smart contracts, on the network. It's a vital concept because it ensures that resources are allocated efficiently and helps prioritize activities by attaching costs to them. Users pay gas fees to compensate for the computational resources needed to execute their operations, and miners prioritize transactions with higher gas fees for processing. This mechanism maintains the blockchain's reliability and security.\n\nGas costs for transactions in blockchain differ significantly from the way cloud infrastructure costs are handled in the web 2.0 (centralized) world. Here are the key distinctions:\n\n1. **Decentralization vs. Centralization**: Blockchain operates in a decentralized manner, with no single entity or company controlling the network. In contrast, web 2.0 services typically rely on centralized cloud infrastructure provided by companies like Amazon Web Services (AWS), Google Cloud, or Microsoft Azure.\n2. **User-Paid vs. Company-Paid**: In blockchain, users pay gas fees directly when they perform actions on the network, such as making transactions or interacting with smart contracts. These fees ensure that users bear the costs of their activities. In web 2.0, companies usually cover the expenses of their cloud infrastructure, and users access services without direct cost for most operations.\n3. **Incentives**: Gas fees in blockchain serve as incentives for miners (or validators) to process transactions and maintain the network's security and integrity. In web 2.0, cloud infrastructure costs are typically covered by companies as part of their operational expenses, and there's no direct financial incentive for users or third parties to participate in infrastructure maintenance.\n4. **Transparency and Control**: Blockchain gas fees are transparent and can be controlled by users based on the urgency of their transactions. Users can adjust gas prices to prioritize faster confirmation times or lower costs. In web 2.0, cloud infrastructure costs are often hidden from end-users, and they have limited control over the underlying infrastructure.\n5. **Resource Allocation**: Gas fees in blockchain allocate computational resources fairly and efficiently by ensuring that users who consume more resources pay higher fees. In web 2.0, resource allocation is typically managed by centralized cloud providers, and users don't have direct visibility into or control over resource allocation decisions.\n\nIn summary, gas in blockchain represents a user-centric, cost-bearing mechanism that maintains the decentralized and transparent nature of blockchain networks. In contrast, web 2.0 relies on centralized cloud infrastructure, where companies absorb the costs, and users have less control and transparency over the underlying infrastructure.\n\n# Other uses for SUI token\nBeside gas, a network token (main token of a network) such as SUI on the Sui blockchain can also act as a form of currency as it's likely the currency with the most liquidity (amount of funds) available. This means it can be:\n1. An intermediate value to exchange between other application-specific coins or tokens.\n2. A value for users to hold their funds\n3. Participate in securing the Sui network by staking (locking) Sui and running a validator node\n\nThe total supply of SUI is capped at 10,000,000,000 (ten billion tokens). A share of SUI total supply became liquid at Mainnet launch, with the remaining tokens vesting over the coming years, or distributed as future stake reward subsidies.\n\n# Paying for gas\nWhen sending transactions on the Sui network, users have to specify the Coin object where gas would be paid from. We talked about how users can have multiple Coin objects and can use `coin::split` and `coin::join` in combination with `transfer::public_transfer` to manage them. In the context of gas, users can also use `pay::split` which combines `coin::split` and `transfer::public_transfer` for users' convenience:\n\n```\n/// Split coin `self` to two coins, one with balance `split_amount`,\n/// and the remaining balance is left is `self`.\npublic entry fun split<T>(\n    self: &mut Coin<T>, split_amount: u64, ctx: &mut TxContext\n) {\n    keep(coin::split(self, split_amount, ctx), ctx)\n}\n```\nUIs can just use a combination of these when constructing the transactions on behalf of the users to effectively manage their SUI balances to pay for gas:\n1. If users have their SUI funds split between multiple Coin objects and no single one has enough to pay for gas, they can combine them.\n2. If users want to explicitly designate a Coin object as their gas fund, they can split it from where most of their funds are held.\n\n# Sponsored transactions\n\nA Sui sponsored transaction is one where a Sui address (the sponsor's) pays the gas fees for a transaction that another address (the user's) initializes. You can use sponsored transactions to cover the fees for users on your site or app so that they don't get charged for them. This removes a significant obstacle that web 2.0 users encounter when entering web3, as they often have to purchase tokens to perform a transaction on chain. For example, you could sponsor gamers' early transactions to increase conversion rates.\n\nMore details can found [here](https://docs.sui.io/concepts/transactions/sponsored-transactions)."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Coin has more functions",
          "isCorrect": false
        },
        {
          "answer": "B. Coin has built-in tracking",
          "isCorrect": false
        },
        {
          "answer": "C. Coin offers full implementation developers can use without writing much code",
          "isCorrect": true
        }
      ],
      "lessonId": "13",
      "codeDef": "",
      "title": "Advanced: Handling multiple coin types",
      "quizTitle": "Why is the keyword phantom required in the `Listing` object?",
      "content": "In a previous lesson, we implemented a simple `Coin` market where sellers list the coins they want to sell and buyers can buy from the listings automatically with SUI and without the seller having to be involved or signing the transaction.\n```\nstruct Listing<phantom CoinType> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<CoinType>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<CoinType>(listing: Listing<CoinType>, payment: Coin<SUI>): Balance<CoinType> {\n    let Listing<CoinType> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\n\nWhat if we want to allow sellers to specify which coins they accept as payment instead of always requiring Sui? This means we'd have to use two different types of coins as type arguments to both the `Listing` object and the `buy_coins` function:\n```\nstruct Listing<phantom ListedCoin, phantom PaymentCoin> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<ListedCoin>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<ListedCoin, PaymentCoin>(listing: Listing<ListedCoin, PaymentCoin>, payment: Coin<PaymentCoin>): Balance<CoinType> {\n    let Listing<ListedCoin, PaymentCoin> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nWe made the following changes:\n1. `Listing` now has two separate (phantom) types. We can name types so here we make the names very explicit to not mix up the types - ListedCoin and PaymentCoin.\n2. `buy_coins` now accepts two coin types as well. The payment now has to be of type `Coin<PaymentCoin>` instead of `Coin<SUI>`.\n3. The logic inside `buy_coins` didn't change much. We don't need to explicitly verify that the payment is of the right type as the payment coin's type is already specified directly in the `Listing<ListedCoin, PaymentCoin>`. Buyers have to provide the right payment or they wouldn't be able to call this function at all!\n\nType correctness is guaranteed  both by the Move compiler and the Sui VM when transactions are executed.\n\nIn very complex situations such as exchanges that allow 3 or 4-way trades between many different coin types, you might see very long functions such as:\n```\npublic fun buy_coins<Coin1, Coin2, Coin3, Coin4>(...) {\n}\n```\nThe `CoinTypes` always have to be explicitly declared as type arguments. This can lead to some complexity if we want to use the same function above to support trades of 1, 2, 3, or 4 types as users cannot leave the missing types empty when calling this function. To get around this, one solution can be to define a \"Null\" Coin type that users can pass if they don't need:\n```\nuse std::type_name;\n\nstruct Null has drop {}\n\npublic fun buy_coins<Coin1, Coin2, Coin3, Coin4>(...) {\n    if (type_name::into_string<Coin3>() == type_name::into_string<Null>()) {\n        // Coin3 is not specified and should be ignored\n    }\n}\n```\nAs shown above, developers can compare the types with `type_name::into_string` to know which types are not specified."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Mint more SUI to pay for gas",
          "isCorrect": false
        },
        {
          "answer": "B. Still submit the transaction and not pay for gas",
          "isCorrect": false
        },
        {
          "answer": "C. Buy SUI from an exchange to fund their account for gas",
          "isCorrect": true
        }
      ],
      "lessonId": "14",
      "codeDef": "",
      "title": "Coin Type orders in struct type arguments",
      "quizTitle": "What happens when users specify the types in the wrong order for an object?",
      "content": "In the previous marketplace example, we created market listings of type `Listing<ListedCoin, PaymentCoin>`. The `buy_coins` function then requires `Listing<ListedCoin, PaymentCoin>` as an argument to know which listing the buyer wants to buy from.\n```\nstruct Listing<phantom ListedCoin, phantom PaymentCoin> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<ListedCoin>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<ListedCoin, PaymentCoin>(listing: Listing<ListedCoin, PaymentCoin>, payment: Coin<PaymentCoin>): Balance<CoinType> {\n    let Listing<ListedCoin, PaymentCoin> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nLet's say someone made a listing for `Listing<MyCoin, SUI>` but a buyer mistakes the order and specifies the listing as `Listing<Sui, MyCoin>`, what would happen? When this transaction is sent to the Sui network, the validation layer would error out because `Listing<SUI, MyCoin>` is invalid at the same address provided (SUI is the listed coin and `MyCoin` is the payment). There's no concern that this might accidentally refer to another Listing for SUI as each object's address is unique and can only have a single type. If another seller does create a `Listing<SUI, MyCoin>`, this listing object's address would be different.\n\nThis can be a common problem that users run into especially for complex marketplaces/exchanges that have many different types of listings with different pairs of coins. Different from our Listing example above, in most exchanges on Sui, the order of the Coins actually doesn't matter for the core objects themselves:\n```\nstruct Market<phantom Coin1, phantom Coin2> has key {\n    id: UID,\n    reserves_1: Balance<Coin1>,\n    reserves_2: Balance<Coin2>,\n}\n```\nIn this Market, `Coin1` and `Coin2` have similar role - buyers can buy `Coin1` with `Coin2` or `Coin2` with `Coin1`. Here the order doesn't technically matter, but unfortunately when the Market object is created, we still need to choose which Coin is the first first type (Coin1). Behind the scene, the object is still created with the `Market<Coin1, Coin2>` in that order. So when users interact with this market, they still need to specify the Coins in the right order that they were created with.\n\nOne solution here to make it easier for users can be to ensure `Coin1` and `Coin2` are also sorted in alphabetic order when the `Market` objects are created. This is currently not easy to do yet in Sui Move due to lack of string comparison."
    },
    {
      "codeSol": "",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "15",
      "codeDef": "",
      "title": "Summary",
      "quizTitle": "",
      "content": "**Sui Coin standard** is the equivalent concept of ERC-20 on Ethereum network on Sui network but it is easier to use.\n* `coin::create_currency` creates a new coin, returns a metadata object storing information about the coin (symbold, name, description, and logo URL), and returns the Treasury Cap object to manage the coins.\n* `coin::mint` create a new coins and doesn't need to specify MyCoin as the type argument as the compiler can infer that.\n* We could use `TreasuryCap<CoinType>` object to mint the coins. However, only the `TreasuryCap` owner can call it. If we want to allow users to freely mint coins, we could wrap `TreasuryCap` object in a shared object.\n* We could also use `TreasureyCap` to burn coins by calling `coin::burn` function. This  also destroys the `Coin` object itself. \n\n**Coin vs Balance**\n1. `Coin` object is more like a wallet. The Coin wallet has an inner balance and cash (Balance) can be taken out of it and deposited into another Coin wallet object. Coins can also be easily split and joint with `coin::split` and `coin::join`.\n2. `Balance` is like cash only. It cannot be stored alone and needs to be put into wallets or pockets. Developers can choose to create their own \"pocket\" objects to store `Balance`. A few important `Balance` function to remember are `sui::balance`, `split`, and `withdraw_all`.\n\n**Decimals** are often used for Coins/tokens in order to reduce rounding errors. Decimals is a special case and there's no update function for it because decimals is a fundamental property of a coin and can change everyone's balance if it's updated. Therefore, for safety and simplicity, Sui's Coin standard doesn't allow modifying decimals.\n\n**Gas** is the fee required for performing actions, like transactions or smart contracts, on the network. It represents a user-centric, cost-bearing mechanism that maintains the decentralized and transparent nature of blockchain networks.\nApplications could accept SUI tokens as gas fee for their application or they could accept other types of coins as their payment. In the latter case, use `Listing` object and the `buy_coins` function.\n\n"
    }
  ],
  "title": "Coin"
}

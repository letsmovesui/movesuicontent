{
  "codeSol": "/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::transfer;\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, UID};\n    use sui::balance::{Self, Balance};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin::value(&coin) > 0, ECantBeZero);\n        coin::put(&mut store.balance, coin);\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = balance::value(&store.balance);\n        coin::take(&mut store.balance, amount, ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n    #[test_only] use std::vector;\n    #[test_only] use sui::vec_map;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            let ctx = test_scenario::ctx(&mut scenario);\n            init_for_testing(ctx);\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = test_scenario::next_tx(&mut scenario, manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = test_scenario::created(&prev_effects);\n        let shared_ids = test_scenario::shared(&prev_effects);\n        let sent_ids = test_scenario::transferred_to_account(&prev_effects);\n        let events_num = test_scenario::num_user_events(&prev_effects);\n\n        assert!(vector::length(&created_ids) == 2, 0);\n        assert!(vector::length(&shared_ids) == 1, 1);\n        assert!(vec_map::size(&sent_ids) == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = purchase(&mut store, coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            sui::transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        test_scenario::next_tx(&mut scenario, fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = test_scenario::take_from_sender_by_id<LittleBookOfCalm>(&scenario, book_id);\n            // send the book back to Manny\n            sui::transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = purchase(&mut store, coin, ctx);\n            sui::transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = collect(&mut store, &cap, ctx);\n\n            sui::transfer::public_transfer(coin, bernard);\n            sui::transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        test_scenario::end(scenario);\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "9",
  "codeDef": "/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::transfer;\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, UID};\n    use sui::balance::{Self, Balance};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin::value(&coin) > 0, ECantBeZero);\n        coin::put(&mut store.balance, coin);\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = balance::value(&store.balance);\n        coin::take(&mut store.balance, amount, ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n    #[test_only] use std::vector;\n    #[test_only] use sui::vec_map;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            let ctx = test_scenario::ctx(&mut scenario);\n            init_for_testing(ctx);\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = test_scenario::next_tx(&mut scenario, manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = test_scenario::created(&prev_effects);\n        let shared_ids = test_scenario::shared(&prev_effects);\n        let sent_ids = test_scenario::transferred_to_account(&prev_effects);\n        let events_num = test_scenario::num_user_events(&prev_effects);\n\n        assert!(vector::length(&created_ids) == 2, 0);\n        assert!(vector::length(&shared_ids) == 1, 1);\n        assert!(vec_map::size(&sent_ids) == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = purchase(&mut store, coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            sui::transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        test_scenario::next_tx(&mut scenario, fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = test_scenario::take_from_sender_by_id<LittleBookOfCalm>(&scenario, book_id);\n            // send the book back to Manny\n            sui::transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = purchase(&mut store, coin, ctx);\n            sui::transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = collect(&mut store, &cap, ctx);\n\n            sui::transfer::public_transfer(coin, bernard);\n            sui::transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        test_scenario::end(scenario);\n    }\n}",
  "title": "Summary",
  "quizTitle": "No Quiz. Here's a complete test might look like:",
  "content": "In summary, unit tests can be easily written in Move:\n- In a separate file/module\n- Start with #[test_only]\n- Can use test_scenario to have all context set up as if the code is executed from a transaction\n- Can take owned and shared objects to call tested functions. Shared objects have to be returned before test_scenario ends or next (test) transaction begins\n- Can create system objects - TxContext and Clock\n- Can validate that an abort happens with the specified error code when the tested function is called\n- Can be parameterized, for now with some boilerplate code\n\n"
}

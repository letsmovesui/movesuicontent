{
  "codeSol": "module exercise::whitelist {\n    use sui::table::{Self, Table};\n    use sui::tx_context::TxContext;\n\n    // Create a new whitelist\n    public fun new(ctx: &mut TxContext) -> Table<u64, bool> {\n        table::new(ctx)\n    }\n\n    // Add an address to the whitelist\n    public fun add(table: &mut Table<u64, bool>, address: u64) {\n        table::add(table, address, true)\n    }\n\n    // Remove an address from the whitelist\n    public fun remove(table: &mut Table<u64, bool>, address: u64) {\n        table::remove(table, address)\n    }\n\n    // Check if an address is in the whitelist\n    public fun contains(table: &Table<u64, bool>, address: u64) -> bool {\n        table::contains(table, address)\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "2",
  "codeDef": "module exercise::whitelist {\n    use sui::table::{Self, Table};\n    use sui::tx_context::TxContext;\n\n    // Create a new whitelist\n    public fun new(ctx: &mut TxContext) -> Table<u64, bool> {\n    }\n\n    // Add an address to the whitelist\n    public fun add(table: &mut Table<u64, bool>, address: u64) {\n    }\n\n    // Remove an address from the whitelist\n    public fun remove(table: &mut Table<u64, bool>, address: u64) {\n    }\n\n    // Check if an address is in the whitelist\n    public fun contains(table: &Table<u64, bool>, address: u64) -> bool {\n    }\n}",
  "title": "Table",
  "quizTitle": "Exercise: Add functions to create, add, and remove address from a whitelist.",
  "content": "Tables are a map-like collection. They use dynamic fields underneath and just store the keys and values in the object system. This allows for an efficient and flexible data structure that can store up to a thousand entries, which is also the limit of dynamic fields. Tables are not stored in the object system, but are just handles into the object system.\nWhen developers need to store a lot of data, such as for an allowlist, they should use a table.\nOne caveat here is that there are restrictions on the types of keys and values that can be used in a table. The key type must be copy, drop, and store, and the value type must be store. This is because the table needs to be able to copy the keys, and the values need to be stored in the object system.\nIn general, all primitive types (numbers, bools, etc.) can be used as keys and values. Custom structs need to follow the above rules to be usable as keys or values in a table.\nNote that tables are also objects as the Table struct has a UID field and key ability. This means they can exist independent of other objects or wrapped in other objects.\n\nTo create a table:\n```\nlet table = table::new<u64, bool>();\n```\n\nThe type specification `<u64, bool>` is not required if an entry is added to the table immediately after creation. The type of the key and value will be inferred from the first entry added to the table.\n```\nlet table = table::new();\n// A table of type <string, u64> is created\ntable::add(&mut table, string::utf8(b\"My key\"), 1);\n```\n\nTo read a value from a table:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\nlet value = table::borrow(&table, 0);\n```\nValue is a reference type and can be copied by dereferencing if it has copy ability.\n```\nlet value = *table::borrow(&table, 0);\n```\n\nTo modify a value from the table directly:\n```\nlet value = table::borrow_mut(&table, 0);\n*value = true;\n```\n\nTo remove a value from the table, we need the key:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\nlet value = table::remove(&mut table, 0);\n```\nNote that remove returns the value in case it needs to be used after removal or doesn't have the drop ability (and thus can't be dropped automatically).\n\nA table doesn't have the drop ability and has to be explicitly destroyed when all items are removed:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\ntable::remove(&mut table, 0);\ntable::destroy_empty(table);\n```\n\nTables can also be destroyed when not empty if values have the drop ability. However, take caution here as dropping a large table with a lot of values can cost a lot of gas.\n```\nlet table = table::new<u64, MyStruct>();\ntable::add(&mut table, 0, MyStruct());\ntable::drop(table);\n```"
}

{
  "codeSol": "public fun get_rand_number(ctx: &mut TxContext): u64 {\n    let id = fresh_object_address(ctx);\n    let epoch = epoch(ctx);\n    let timestamp = epoch_timestamp_ms(ctx);\n    let rand = (id + epoch + timestamp) % 100;\n    rand\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "3",
  "codeDef": "public fun get_rand_number(ctx: &mut TxContext): u64 {\n    // Implement\n}",
  "title": "Transaction context",
  "quizTitle": "Exercise: Use unique_id generated from fresh_object_address and epoch timestamp to generate random value",
  "content": "As we have seen in previous courses on objects and more advanced Move, transaction context (tx_context) is useful for many things:\n1. Create new objects. This requires a mutable tx_context\n2. Access the sender of the transaction\nTx_context is considered a special system object and automatically passed to a function:\n```\npublic fun my_function(ctx: &mut TxContext) {\n    let sender = ctx.sender();\n    let new_object = object::new(ctx);\n}\n```\nWhen calling my_function, the sender doesn't need to explicitly pass tx_context. It's automatically appended by the VM when the transaction is executed. This is also why transaction context should always be the last argument in a function signature.\n```\npublic fun my_function(arg1: u64, arg2: u64, ctx: &mut TxContext) {\n    // ...\n}\n```\n\nYou'd also see some library functions or functions from someone else's contract you might depend on requiring a transaction context. In most cases, this is for creating objects inside those functions.\nThere are other useful transaction context functions you can use:\n- `ctx.epoch()` returns the current epoch number\n```\nlet epoch = tx_context::epoch(ctx);\n```\nThe Sui blockchain is organized into non-overlapping epochs, each 24 hours long.\n\n- `ctx.epoch_timestamp_ms()` returns the start time of the current epoch in milliseconds since the Unix epoch\n```\nlet epoch_start = tx_context::epoch_timestamp_ms(ctx);\n```\n\n- `ctx.fresh_object_address()` returns a new, unique object address. This is useful for creating new objects.\n```\nlet new_object = object::new(ctx);\n```\nNote that this unique object address can be used as a unique id even for items that are not objects. These ids are guaranteed to be unique across all transactions and all objects.\n\n- `ctx.digest()` returns the hash of the current transaction. This is useful for creating deterministic randomness.\n```\nlet random_number = std::hash::digest(ctx.digest());\n```"
}

{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has store {\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String) {\n        if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n        }\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "1",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
  "title": "Dynamic Field - SuiFrens and their Hat",
  "quizTitle": "1. Add a new struct Hat with store ability to the sui_fren module. Hat has a single field color of type String. We'll add more fields later on.\n2. Add a new public function color_hat that takes a mutable reference to a SuiFren named sui_fren and a color of type String.\n3. color_hat should add a hat if one doesn't exist for that SuiFren or update the color of the existing one.\n4. You can use string::utf8(HAT_KEY) as the dynamic field key.",
  "content": "In the previous course, we have explored Objects in depth and created SuiFrens as objects that have their own attributes and a Display object that tells Web UI how they should be displayed. We also covered the following topics:\n1. Nested structs - Structs with the store ability can be embedded into another struct. This is often used for non-object structs to divide a long list of fields into logical components.\n2. Object wrapping - Putting a SuiFren into another object. This also uses the store ability but effectively removes the wrapped object from storage. SuiFrens that have been wrapped into GiftBoxes can no longer be looked up when searching by objects.\n\nIn this lesson, we'll cover another way to compose structs and objects together - Dynamic Fields. You can think of Dynamic Fields as invisible fields that are not explicitly defined on an object struct. Let's assume we have a Laptop Object that has the following attributes initially:\n```\nstruct Laptop has key {\n    id: UID,\n    screen_size: u64,\n    model: u64,\n}\n```\nLet's say we want to dynamically add more attributes for this laptop in the future but don't yet know what these attributes are exactly. We can't define them in the struct right away. This is where Dynamic Fields come to the rescue - you don't need to know all the fields you want to add to an object as dynamic fields!\n```\nuse sui::dynamic_field;\n\npublic fun add_attribute(laptop: &mut Laptop, name: String, value: u64) {\n    dynamic_field::add(&mut laptop.id, name, value);\n}\n```\nIn order to add dynamic fields to an object, you need a mutable reference to that object. Remember that for owned objects, only the owner can send transactions that use mutable/immutable references or a value of their object. Shared objects can be mutated by anyone. Adding a dynamic field can be done simply via dynamic_field::add with the mutable object's id, the key and the value.\n\nKey and value can be primitive types (numbers, strings, etc.) or structs. Note that structs used as keys must have the copy, drop, and store abilities while structs used as values must have the store ability.\n```\nstruct StickerName has copy, drop, store {\n    name: String,\n}\n\nstruct Sticker has store {\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, image_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker = Sticker { image_url };\n    dynamic_field::add(&mut laptop.id, sticker_name, sticker);\n}\n```\nDynamic fields are unique by name so you can't add fields of the same name more than once.\n\nTo read or modify a dynamic field, you need an immutable and mutable references to the object respectively and the field name (key). If the field name is a struct, you need the struct value itself, which is why the structs used as keys must have copy and drop abilities.\n```\npublic fun read_image_url(laptop: &Laptop, name: String): String {\n    let sticker_name = StickerName { name };\n    let sticker_reference: &Sticker = dynamic_field::borrow(&laptop.id, sticker_name);\n    sticker_reference.image_url\n}\n\npublic fun set_image_url(laptop: &mut Laptop, name: String, new_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker_mut_reference: &mut Sticker = dynamic_field::borrow_mut(&mut laptop.id, sticker_name);\n    sticker_mut_reference.image_url = new_url;\n}\n```\nNote that if you usually would need to specify the type of the field borrowed (&Sticker and &mut Sticker in the above example)\n\nYou can also remove an existing dynamic field with a mutable object reference and the key:\n```\npublic fun remove_sticker(laptop: &mut Laptop, name: String) {\n    let sticker_name = StickerName { name };\n    dynamic_field::remove(&mut laptop.id, sticker_name);\n}\n```\nYou can check if a dynamic field exists with dynamic_field::exists_(&laptop.id, sticker_name)"
}

{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n\n    public fun update_hat_color(sui_fren: &mut SuiFren, hat: Receiving<Hat>, color: String, ctx: &mut TxContext) {\n        let hat = transfer::receive(&mut sui_fren.id, hat);\n        hat.color = color;\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "4",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    // Update\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n    }\n}",
  "title": "Objects owning Objects",
  "quizTitle": "1. Rewrite the color_hat function to transfer the Hat object to the SuiFren object instead of using dynamic object fields.\nNote that if the hat already exists, we can't easily change its color without adding a Receiving<Hat> to the color_hat function, which doesn't make sense and conflicts with the case when the SuiFren doesn't have a hat!\n2. Instead, add a separate public function update_hat_color that updates the color of an existing hat.",
  "content": [
    "Yet another way to compose objects is to have objects own other objects. With the other three approaches - object wrapping, dynamic fields, dynamic object fields, ownership is forfeited or set to a hidden object (dynamic field object). In some cases, it can be desired to have the parent object own the child object (for example SuiFren owning the Hat it wears). This can be seen as a clear indication of object hierarchy in a complex application design with multiple types of objects.\n",
    "\n",
    "Another interesting use case for objects owning objects is composable NFTs - exactly like SuiFrens owning their Hats. This allows for powerful composition of NFTs together that make natural sense to users and is often seen in Web 3 Games that use NFTs.\n",
    "\n",
    "One drawback that makes objects owning objects less commonly used compared to the other 3 approaches is that it's harder to remove the owned object later. Therefore, objects owning objects is generally more useful if the relationship is rarely or never changed.\n",
    "\n",
    "```\n",
    "struct Laptop has key {\n",
    "    id: UID,\n",
    "}\n",
    "\n",
    "struct Sticker has key, store {\n",
    "    id: UID,\n",
    "    image_url: String,\n",
    "}\n",
    "\n",
    "public fun add_sticker(laptop: &Laptop, sticker: Sticker) {\n",
    "    transfer::public_transfer(sticker, object::uid_to_address(&laptop.id));\n",
    "}\n",
    "```\n",
    "\n",
    "In the example above, we explicitly transfer the Sticker object to the Laptop. It's now owned by the Laptop. In order to remove it later, we'd need to use Receiving<T>:\n",
    "\n",
    "```\n",
    "public fun remove_sticker(laptop: &mut Laptop, sticker: Receiving<Sticker>) {\n",
    "    let sticker = transfer::public_receive(&mut laptop.id, sticker);\n",
    "    // Do something with the sticker\n",
    "}\n",
    "```\n",
    "\n",
    "In order to extract the Sticker object that was transferred to the Laptop object earlier, we need the owner of the Laptop to call the remove_sticker function with a mutable reference to the Laptop and a variable of type Receiving<Sticker>. When sending the transaction, the owner can specify the Sticker object's address, and the Sui VM will automatically convert it into the Receiving<Sticker> type. We can then call transfer::public_transfer to get the underlying Sticker. As you can see, this is a bit harder to do than object wrapping or dynamic fields.\n",
    "\n",
    "Note that extracting an object owned by another object is also subject to the Transfer Policy (see the corresponding lesson from the previous course):\n",
    "1. If the inner object has the store ability, transfer::public_receive can be call to extract it outside of the module where its struct is defined\n",
    "2. If the inner object has no store ability, transfer::public_receive cannot be called. Only transfer::receive can be called inside the module where the struct is defined."
  ]
}

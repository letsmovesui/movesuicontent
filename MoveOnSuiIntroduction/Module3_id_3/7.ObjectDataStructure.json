{
  "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    struct GiftBox has key {\n        id: UID,\n        object_bag: ObjectBag,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            object_bag: object_bag::new(ctx),\n        };\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, fren);\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, hat);\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "7",
  "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Hat};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Update\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}",
  "title": "Object Data Structure - Bag of Mixed Objects",
  "quizTitle": "1. Update the GiftBox struct to use ObjectBag instead of a single field of type SuiFren.\n2. Update wrap_fren to work with the ObjectBag.\n3. Add a wrap_hat entry function that adds a Hat to a GiftBox's ObjectBag.\n\nThe ObjectBag should use an index as the key (first object added has index 0, second has index 1, etc.)",
  "content": "In the previous course, we covered how to wrap a SuiFren object into a GiftBox object.\n```\nstruct GiftBox has key {\n    id: UID,\n    inner: SuiFren,\n}\n\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n```\n\nLet's say we want to make the GiftBox even more of a pleasant surprise by allowing users who open it to potentially receive between 1 and 5 Frens. You might be tempted to create 5 SuiFren fields:\n```\nstruct GiftBox has key {\n    id: UID,\n    inner_1: SuiFren,\n    inner_2: SuiFren,\n    inner_3: SuiFren,\n    inner_4: SuiFren,\n    inner_5: SuiFren,\n}\n```\nThis just looks messy and doesn't really work! This would force a GiftBox to always contain exact 5 SuiFrens. What if we also allow a GiftBox to be a miss and possibly contain no SuiFrens? A better way would be to use a vector:\n```\nstruct GiftBox has key {\n    id: UID,\n    frens: vector<SuiFren>,\n}\n```\nThis is much cleaner! Now each GiftBox can contain any number of SuiFrens, including zero (empty vector). But what if we want to make it even more fun - each GiftBox can contain some number of Hats as well? We can create a second vector of Hats. But you see where we're going with this. If we want a GiftBox to contain a mixed collection of different types of objects, and vector wouldn't work here as it can only contain a single type of objects. It's better to use Object Bag instead!\n```\nuse sui::object_bag::{Self, ObjectBag};\n\nstruct MyBag has key {\n    id: UID,\n    object_bag: ObjectBag,\n}\n\npublic fun create_bag(ctx: &mut TxContext) {\n    transfer::transfer(MyBag {\n        id: object::new(ctx),\n        object_bag: object_bag::new(ctx),\n    }, tx_context::sender(ctx));\n}\n\npublic fun add_to_bag<SomeObject>(my_bag: &mut MyBag, key: String, object: SomeObject) {\n    object_bag::add(&mut my_bag.object_bag, key, object);\n}\n```\nUnder the hood, an ObjectBag uses dynamic object fields to store the objects of different types. The syntax is very similar to dynamic fields - to add an object to a Bag, you need a key of primitive type (such as index of type u64) or structs with copy/drop/store abilities and a value of struct type with key ability (object struct).\n\nThe object_bag module also offers other functions as well such as borrow, borrow_mut, contains (similar to dynamic_field::exists_), length (returns the number of objects in the bag) and is_empty."
}

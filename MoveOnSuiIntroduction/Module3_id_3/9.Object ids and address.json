{
  "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    entry fun create_gift(ctx: &mut TxContext) {\n        let sui_fren = sui_fren::create_random(ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            sui_fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    public(friend) fun create_random(ctx: &mut TxContext): SuiFren {\n        let object_id = object::new(ctx);\n        let bytes = object::uid_to_bytes(&object_id);\n        let power = bcs::peel_u64(&mut bcs::new(bytes));\n        SuiFren {\n            id: object_id,\n            power,\n        }\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "9",
  "codeDef": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new function here\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    // Add the new function here\n}",
  "title": "Object ids and address",
  "quizTitle": "Let's make the giftbox a bit more fun. Instead of wrapping an existing SuiFren, let's create one randomly when the GiftBox is created!\n1. Add a create_random public friend function to the sui_fren module that generates a SuiFren with a randomly generated power. create_random takes a single context param and returns the SuiFren object created.\n2. Add a new entry function create_gift to fren_summer module to create a gift box, call sui_fren::create_random to create the wrapped SuiFren object, and sends it the transaction's sender.\n3. Only fren_summer::create_gift can call sui_fren::create_random",
  "content": "We have been learning a lot of cool tricks we can do with objects. One fundamental aspect of object that we want to dive deeper into is object id.\n\nHave you wondered how an object's id and address are created? Technically an object's id and address are one and the same - they are unique identifiers that can allow developers to identify and fetch data from the objects. This is the case both on-chain (in Move) and off-chain (via web UI querying all data and fields for an object):\n```\npublic fun get_object_id_from_address(object_addr: address): ID {\n    object::id_from_address(address)\n}\n\npublic fun get_object_address(object: &MyObject): address {\n    object::id_to_address(&object.id)\n}\n```\nNote that the returned type for object's id is ID, which is different from the UID field that every object struct has. However, you can use object::uid_to_inner to convert a UID reference to ID. This allows comparing to check if an object is the same as a stored address.\n\nWhen an object is created, its id field is generated via object::new(ctx) where ctx is a mutable reference of type TxContext passed to the transaction by the Sui Virtual Machine (VM). Here's the code for it:\n```\npublic fun new(ctx: &mut TxContext): UID {\n    UID {\n        id: ID { bytes: tx_context::fresh_object_address(ctx) },\n    }\n}\n```\nAs you can see, behind the scene, a unique address is first generated with tx_context::fresh_object_address(ctx), then converted into bytes to create the object's id. fresh_object_address is a special type of function in Move - native function. Native functions are special as their implementation is written in Rust as part of the Move VM. This allows the function to run faster and have access to inner constructs of the VM. In this case, fresh_object_address can see the user's <b>transaction payload<b> and use it to generate a special address for the object. It also uses a counter that tracks how many objects have been created so far in the same transaction. fresh_object_address then hashes the tx payload and the counter and ensures that the result is unique even among the multiple objects created in the same transaction.\n\nOne interesting use case of the address generation process is to potentially use it as a source of randomness - the bytes generated from a newly created object's id can be used as a random value. This is typically because the hash of the transaction payload and counter often seems random (not following any pattern):\n```\nuse sui::bcs;\n\npublic fun get_random_value(ctx: &mut TxContext): u64 {\n    let object_id = object::new(ctx);\n    let bytes = object::uid_to_bytes(&object_id);\n    let random_number = bcs::peel_u64(&mut bcs::new(bytes));\n    object::delete(object_id);\n    random_number\n}\n```\nget_random_value can be called multiple times to create pseudo-random numbers (seemingly random). This could be used generally as a source of random values depending on use case, but is potentially dangerous to use as it could be manipulated by the user. They can change the expiration timestamp and other fields in the transaction in order to generate desired object ids and the resulting random number (for example to win an on-chain lottery). It could be safer to include the timestamp (from the system object Clock) but this still has risks:\n1. The user can still manipulate the random value to some extend (not as much as before as they have no control over the Clock object).\n2. The validators can partially manipulate the random value as well as they can set the timestamp of the Clock object to a specific value within a small range of margin of error.\n\nWe'll cover safer ways to generate random values in later courses."
}

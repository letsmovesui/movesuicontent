{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Because dynamic object fields removes the structs from object storage",
      "isCorrect": false
    },
    {
      "answer": "B. Because the struct fields don't have to be objects",
      "isCorrect": true
    },
    {
      "answer": "C. Because dynamic fields are faster to read and write than dynamic object fields",
      "isCorrect": false
    }
  ],
  "lessonId": "5",
  "codeDef": "",
  "title": "Using Dynamic Fields for Managing Contract States",
  "quizTitle": "Why do we want to use dynamic fields for the different laptop store configs instead of dynamic object fields?",
  "content": [
    "Another useful application of dynamic fields is to manage contracts states. You might be tempted to use multiple shared objects for each state struct. For example, we can have the following set up for the laptop store's configs:\n",
    "```\n",
    "struct PriceConfigs has key {\n",
    "    id: UID,\n",
    "    price_range: vector<u64>,\n",
    "}\n",
    "\n",
    "struct StoreHours has key {\n",
    "    id: UID,\n",
    "    open_hours: vector<vector<u8>>,\n",
    "}\n",
    "\n",
    "struct SpecConfigs has key {\n",
    "    id: UID,\n",
    "    specs_range: vector<u64>,\n",
    "}\n",
    "\n",
    "fun init(ctx: &mut TxContext) {\n",
    "    let price_configs = PriceConfigs {\n",
    "        id: object::new(ctx),\n",
    "        price_range: vector[1000, 5000],\n",
    "    };\n",
    "    let store_hours = StoreHours {\n",
    "        id: object::new(ctx),\n",
    "        open_hours: vector[vector[9, 12], vector[1, 5]],\n",
    "    };\n",
    "    let spec_configs = SpecConfigs {\n",
    "        id: object::new(ctx),\n",
    "        specs_range: vector[1000, 10000],\n",
    "    };\n",
    "    transfer::share_object(price_configs);\n",
    "    transfer::share_object(store_hours);\n",
    "    transfer::share_object(spec_configs);\n",
    "}\n",
    "```\n",
    "\n",
    "It's not a lot of work to create the shared objects. Each object is shared so it can be accessed and/or modified by users when they purchase a laptop for example:\n",
    "```\n",
    "public fun purchase_laptop(price_configs: &PriceConfigs, store_hours: &SotreHours, spec_configs: &SpecConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n",
    "}\n",
    "```\n",
    "\n",
    "As you can see, this function's signature is too long and hard to read. Furthermore the web UI that submits the transactions on the user's behalf would need to track all of these shared objects' addresses. Imagine what would happen if we have 5 or even 10 shared objects! It's also overkill as these different structs are never separated and live independently so they don't really need to be objects.\n",
    "\n",
    "It's much cleaner to instead create a single state config object and add dynamic fields there:\n",
    "```\n",
    "struct StateConfigs has key {\n",
    "    id: UID,\n",
    "}\n",
    "\n",
    "const PRICE_CONFIGS: vector<u8> = b\"PRICE_CONFIGS\";\n",
    "struct PriceConfigs has store {\n",
    "    price_range: vector<u64>,\n",
    "}\n",
    "\n",
    "const STORE_HOURS: vector<u8> = b\"STORE_HOURS\";\n",
    "struct StoreHours has store {\n",
    "    open_hours: vector<vector<u8>>,\n",
    "}\n",
    "\n",
    "const SPEC_CONFIGS: vector<u8> = b\"SPEC_CONFIGS\";\n",
    "struct SpecConfigs has store {\n",
    "    specs_range: vector<u64>,\n",
    "}\n",
    "\n",
    "fun init(ctx: &mut TxContext) {\n",
    "    let state_configs = StateConfigs {\n",
    "        id: object::new(ctx),\n",
    "    };\n",
    "    dynamic_fields::add(&mut state_configs.id, PRICE_CONFIGS, PriceConfigs {\n",
    "        id: object::new(ctx),\n",
    "        price_range: vector[1000, 5000],\n",
    "    });\n",
    "    dynamic_fields::add(&mut state_configs.id, STORE_HOURS, StoreHours {\n",
    "        id: object::new(ctx),\n",
    "        open_hours: vector[vector[9, 12], vector[1, 5]],\n",
    "    });\n",
    "    dynamic_fields::add(&mut state_configs.id, SPEC_CONFIGS, SpecConfigs {\n",
    "        id: object::new(ctx),\n",
    "        specs_range: vector[1000, 10000],\n",
    "    });\n",
    "    transfer::share(state_configs);\n",
    "}\n",
    "```\n",
    "\n",
    "The user transactions would then only need to track and pass a single object's address:\n",
    "```\n",
    "public fun purchase_laptop(state_configs: &StateConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n",
    "}\n",
    "```\n",
    "\n",
    "As you can see, this is much cleaner!"
  ]
}

{
  "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun get_attributes(sui_fren: &SuiFren): vector<String> {\r\n        sui_fren.attributes\r\n    }\r\n\r\n    public fun update_attributes(sui_fren: &mut SuiFren, attributes: vector<String>) {\r\n        sui_fren.attributes = attributes;\r\n    }\r\n}\r\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": 10,
  "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Add the new functions here\r\n}\r\n",
  "title": "Updating objects",
  "quizTitle": "1. Add a new public function `get_attributes` that takes a `sui_fren` object and return its attributes.\n2. Write a new public function `update_attributes` to allow changing a SuiFren's list of attributes. This function should take two arguments - the `sui_fren` object to modify and the new list of attributes",
  "content": "In this lesson, we'll learn how to modify an existing object by updating the fields of its struct. First we need to talk about mutable references. In a previous lesson on reading object fields, we covered immutable references and how we can pass them to public functions when sending transactions to read the state of an object.\n\nIn order to modify an object, we need to use mutable references instead. The difference in syntax is very simple - `&mut StructName` instead of `&StructName`. When interacting with the Sui blockchain, users can clearly see from a functionâ€™s arguments whether the functions only read or also modify objects by checking if it requires immutable objects (read only) or mutable (read and write).\n\nTo write a function that updates an object, we first need to specify the object being modified in a function via a mutable reference and then update its fields. All modified objects are automatically saved to the blockchain at the end of the transaction. Example:\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n\n\n   struct MyObject has key {\n       id: UID,\n       value: u64,\n   }\n\n\n   fun init(ctx: &mut TxContext) {\n       let my_object = MyObject {\n           id: object::new(ctx),\n           value: 10,\n       };\n       transfer::share_object(my_object);\n   }\n\n\n   public fun set_value(my_object: &mut MyObject, value: u64) {\n       my_object.value = value;\n   }\n}\n```\nThat's it! Pretty simple, right? You just need to pass a mutable reference to an object instead of immutable.\n"
}

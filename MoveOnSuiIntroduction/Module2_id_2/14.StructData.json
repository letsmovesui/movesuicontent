{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Anyone",
      "isCorrect": false
    },
    {
      "answer": "B. Owner of object 1",
      "isCorrect": false
    },
    {
      "answer": "C. Owner of object 2",
      "isCorrect": true
    }
  ],
  "lessonId": "14",
  "codeDef": "",
  "title": "Struct data access and user ownership rules",
  "quizTitle": "In the following example:\n```\nstruct MyData has key {\n    id: UID,\n    value: u64,\n}\n\npublic fun set_value(object_1: &MyData, object_2: &MyData, value: u64) {\n    object_2.value = value;\n}\n```\nIf `object_1` is a shared object and `object_2` is a owned object, who can send this transaction?",
  "content": "# Struct data access rules\nWe have seen various different type of structs, including object structs (those with the key ability) and non-object structs (those without the key ability). In order to access a field of a struct instance, object or non-object, we just need to use the dot annotation and call `struct_instance.field`. The `struct_instance` can be a mutable or immutable reference, or a value. However, this doesn't work outside of the module where the struct is defined:\n```\nmodule 0x123::a {\n    struct MyData has key {\n        id: UID,\n        value: u64,\n    }\n    \n    // This works\n    public fun get_value_from_reference(object: &MyData): u64 {\n        object.value\n    }\n    \n    // This works\n    public fun get_value_from_mut_reference(object: &mut MyData): u64 {\n        object.value\n    }\n}\n\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This doesn't work\n    public fun get_value(object: &MyData): u64 {\n        object.value\n    }\n}\n```\nIn the example above, `b::get_value` will fail to compile as it tries to access the value field of `MyData` but `MyData` is defined inside module a, and not in module b. In Move, only the modules that define a struct can freely access its fields. If other modules need to access a field, it'd need to do so through the original module's getter function:\n```\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This now works\n    public fun get_value(object: &MyData): u64 {\n        a::get_value_from_reference(object)\n    }\n}\n```\nIn general, this is call the module-scoped rule for struct data access. This allows developers to define rules for how their data (structs) can be read or written. They can keep the data private and not allow any external modules to access inner fields, or they can implement public getters (return an inner field's values) and setters (set an inner field's value) that can be called by external modules. They can also implement custom authentication module that requires a specific permission object to be able to update the struct's values.\n\n# User ownership\nIn the first course, we have covered Owned objects and how they can only be accessed and modified by transactions sent by the owner. This is automatically verified by the Sui blockchain when the transactions are executed and guarantees that an account's owned objects cannot be read/modified without their permission. \n\nThrough enforcement of this ownership, users can be reassured that no modules can read or modify their owned objects without them explicitly signing transactions that authorize the modules to do so. "
}

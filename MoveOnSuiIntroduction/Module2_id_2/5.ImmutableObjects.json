{
  "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    struct GiftWeekConfig has key {\n        id: UID,\n        limit: u64,\n    }\n\n    entry fun create_week(limit: u64, ctx: &mut TxContext) {\n        let gift_week_config = GiftWeekConfig {\n            id: object::new(ctx),\n            limit,\n        };\n        transfer::freeze_object(gift_week_config);\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "5",
  "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
  "title": "Immutable objects - Gift Season Info",
  "quizTitle": "Imagine users can create gift boxes with their `SuiFrens` and give away to their friends during specific weeks of the holiday season. However, we want to limit the number of gifts that can be created in each week (can be different from week to week). In order to do this, we'll:\n1. Create a new object struct `GiftWeekConfig` that has the id field and another field - limit of type `u64`.\n2. Create a new entry function `create_week` that takes a limit argument and creates and freezes a `GiftWeekConfig` object.  ",
  "content": "We have created two objects so far: `SuiFren` and `GiftBox`. Both of these are owned objects. They're owned by users and only the owners can include them in a transaction. We also briefly discussed shared objects - those that can be include in any transactions. Let's talk about a third type of object in this lesson - immutable objects.\n\nImmutable objects are almost the same as shared objects. Any user can include them as part of their transactions. However, shared objects can be included as mutable references and thus modifiable by anyone. Immutable objects can never change after they're \"frozen\".\n```\nstruct ColorObject has key {\n    id: UID,\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\npublic entry fun freeze_owned_object(object: ColorObject) {\n    transfer::freeze_object(object)\n}\n\npublic entry fun create_immutable(red: u8, green: u8, blue: u8, ctx: &mut TxContext) {\n    let color_object = ColorObject {\n        id: object::new(ctx),\n        red,\n        green,\n        blue,\n     };\n    transfer::freeze_object(color_object);\n}\n```\n\nIn the example above, `create_immutable` creates an object and immediately freezes it, making it immutable. `freeze_owned_object`, on the other hand, takes an existing owned object and makes it immutable. Note that `transfer::freeze_object` would error out if called on shared objects. `freeze_owned_object` demonstrates another key difference between immutable objects and shared objects - owned objects cannot become shared (`transfer::share_object` needs to be call immediately after an object is created in the same transaction), but owned object can be made immutable anytime as long as the owner wants to.\n\nImmutable objects can be included via immutable reference (&) anytime:\n```\npublic fun read_immutable(color: &ColorObject): (u8, u8, u8) {\n    (color.red, color.green, color.blue)\n}\n```\nread_immutable can be called on any immutable (frozen) color objects and ownership is not required.\n"
}

{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n}\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "4",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    // Add new imports here\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    // Add new structs here\n\n    // Update\n    fun init() {\n\n    }\n}\n",
  "title": "Creating a Collection and Display attributes",
  "quizTitle": "Update the sui_fren module to create an NFT collection for SuiFrens using the OriginByte standard. Make sure you don't forget any imports. Also remember the main one time witness type has to be named in a specific way (check out the first course if you forgot).\nThe SuiFren collection should have the following display attributes:\n1. name: \"SuiFrens\"\n2. description: \"A collection of SuiFrens who hangout together\"\n\nFor now we'll not share the MintCap object.",
  "content": [
    "Using the OriginByte standard, developers can easily create a collection. The first step is to include the  [nft_protocol](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol) and [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) packages from OriginByte as mentioned in the previous lesson. Afterward, a collection can be created using the collection module:",
    "```",
    "module my_nft::kite {",
    "    use nft_protocol::attributes::Attributes;",
    "    use nft_protocol::collection;",
    "    use std::string::String;",
    "    use sui::url::Url;",
    "    /// One time witness is only instantiated in the init method",
    "    struct KITE has drop {}",
    "    struct KiteNFT has key, store {",
    "        id: UID,",
    "        name: String,",
    "        description: String,",
    "        url: Url,",
    "        attributes: Attributes,",
    "    }",
    "    fun init(otw: KITE, ctx: &mut TxContext) {",
    "        let (collection, mint_cap) =",
    "            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);",
    "        transfer::public_share_object(collection);",
    "        transfer::public_share_object(mint_cap);",
    "    }",
    "}",
    "```",
    "A Collection can only be created as part of the init function as it requires a witness object (discussed in the first course). collection::create_with_mint_cap needs to be called with two type arguments:",
    "1. The witness object type. In the example above, that's KITE.",
    "2. The type of the NFT in the Collection. We created a KiteNFT type for this. Will discuss the fields in more details in the next lessons.",
    "collection::create_with_mint_cap returns two objects - the collection object of type Collection<Kite> and the mint_cap which can be used to programmatically require it for minting tokens (to be discussed later). Both of these are made shared objects because they cannot be modified anyway and can only be read. We'll talk more about whether MintCap can be an owned object later.",
    "After the collection has been created, attributes such as name/description can be added:",
    "```",
    "use nft_protocol::display_info;",
    "use ob_permissions::witness;",
    "use std::string::{Self, String};",
    "/// Can be used for authorization of other actions post-creation. It is",
    "/// vital that this struct is not freely given to any contract, because it",
    "/// serves as an auth token.",
    "struct Witness has drop {}",
    "fun init(otw: KITE, ctx: &mut TxContext) {",
    "    let (collection, mint_cap) =",
    "        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);",
    "    let delegated_witness = witness::from_witness(Witness {});",
    "    collection::add_domain(",
    "        delegated_witness,",
    "        &mut collection,",
    "        display_info::new(",
    "            string::utf8(b\"Kites\"),",
    "            string::utf8(b\"A NFT collection of Kites on Sui\"),",
    "        ),",
    "    );",
    "}",
    "```",
    "In order to set the name/description for the collection, we need a few things:",
    "1. Import the ob_permissions::witness from the [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) package provided by OriginByte.",
    "2. A new struct Witness {} declared in the same package",
    "3. Create a \"delegated witness\" object with witness::from_witness",
    "4. Call collection::add_domain with the right DisplayInfo object with the name and description. More attributes can be added as a separate domain."
  ]
}

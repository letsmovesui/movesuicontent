{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n\n    public fun mint_nft(\n        mint_cap: &MintCap<SuIFren>,\n        generation: u64,\n        birthdate: u64,\n        ctx: &mut TxContext,\n    ) {\n        let nft = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes: attributes::from_vec(vector[], vector[])\n        };\n        transfer::public_transfer(nft, tx_context::sender(ctx));\n        \n        mint_event::emit_mint(\n            witness::from_witness(Witness {}),\n            mint_cap::collection_id(mint_cap),\n            &nft,\n        );\n    }\n}\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "5",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n\n    // Add the new function here\n}\n",
  "title": "Minting a Token",
  "quizTitle": "1. Update init function to share the MintCap object \n2. Add a new public function mint that takes the MintCap object, generation, birthdate, attributes and create a new SuiFren token. It should also emit the mint event",
  "content": [
    "Now that we've created a collection. Let's talk about minting NFTs. The OriginByte standard only specifies how a Collection should be structured:\n",
    "1. Their Collection object is very minimal and all attributes need to be added as display attributes (via collection::add_domain):\n",
    "```\n",
    "struct Collection<phantom T> has key, store {\n",
    "    id: UID,\n",
    "    version: u64,\n",
    "}\n",
    "```\n",
    "2. OriginByte also has common functionalities for Collection such as creators, royalty, etc.\n",
    "3. Developers need to define their own NFT struct as we've seen in the previous lesson. OriginByte only offers common functionalities to manage that token: Permissions (MintCap), attributes standard, display standard, etc.\n",
    "4. Mint and burn events that tie the NFTs back to the collection.\n",
    "\n",
    "Developers/creators first need to define the NFT object struct, which is needed to create the collection as discussed in the previous lesson:\n",
    "```\n",
    "module my_nft::kite {\n",
    "    use nft_protocol::attributes::Attributes;\n",
    "    use nft_protocol::collection;\n",
    "    use std::string::String;\n",
    "    use sui::url::Url;\n",
    "    \n",
    "    /// One time witness is only instantiated in the init method\n",
    "    struct KITE has drop {}\n",
    "    \n",
    "    struct KiteNFT has key, store {\n",
    "        id: UID,\n",
    "        name: String,\n",
    "        description: String,\n",
    "        url: Url,\n",
    "        attributes: Attributes,\n",
    "    }\n",
    "    \n",
    "    fun init(otw: KITE, ctx: &mut TxContext) {\n",
    "        let (collection, mint_cap) =\n",
    "            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n",
    "    }\n",
    "}\n",
    "```\n",
    "Once they have a collection, they can mint the NFTs like below:\n",
    "```\n",
    "use nft_protocol::attributes::{Self, Attributes};\n",
    "use nft_protocol::mint_cap;\n",
    "use nft_protocol::mint_event;\n",
    "use sui::url;\n",
    "\n",
    "public fun mint_nft(\n",
    "    mint_cap: &MintCap<Kite>,\n",
    "    name: String,\n",
    "    description: String,\n",
    "    url: String,\n",
    "    ctx: &mut TxContext,\n",
    ") {\n",
    "    let nft = KiteNFT {\n",
    "        id: object::new(ctx),\n",
    "        name,\n",
    "        description,\n",
    "        url: url::new_unsafe(url),\n",
    "        attributes: attributes::from_vec(vector[], vector[])\n",
    "    };\n",
    "    transfer::public_transfer(nft, tx_context::sender(ctx));\n",
    "    \n",
    "    mint_event::emit_mint(\n",
    "        witness::from_witness(Witness {}),\n",
    "        mint_cap::collection_id(mint_cap),\n",
    "        &nft,\n",
    "    );\n",
    "}\n",
    "```\n",
    "You might realize that this doesn't look any different from creating an object! This is correct, there's only one small difference - attributes is a standard provided by OriginByte to store all the token attributes. We'll discuss this more in a later lesson. Developers can also add more logic here that restrict one token mint per user for example and whatever other rules they like.\n",
    "\n",
    "The mint function also takes a MintCap object in order to emit a mint event. This is required so that off-chain components can know the KiteNFTs belong in the Kite collection. The mint_event::emit_mint provided by OriginByte also requires the delegated witness object passed when adding display attributes to the collection in the init function. In most cases, MintCap can be a shared object to allow any user to call the mint_nft function.\n",
    "\n",
    "```\n",
    "fun init(otw: KITE, ctx: &mut TxContext) {\n",
    "    let (collection, mint_cap) =\n",
    "        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n",
    "    transfer::public_share_object(mint_cap);\n",
    "}\n",
    "```\n",
    "\n",
    "If this is not the case and developers want to restrict who can mint, they can make MintCap an owned object and, in the init function, transfer it to the account that can mint. This makes mint_nft a permissioned function that can only called by a specific account.\n",
    "\n",
    "Another way off-chain components can recognize NFTs from a collection is to look at their type. The collection object has a type argument so in the example above its type would be Collection<Kite>"
  ]
}

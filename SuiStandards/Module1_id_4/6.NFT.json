{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Fields are explicit and thus easier to see while attributes are dynamic and harder to know the full list",
      "isCorrect": true
    },
    {
      "answer": "B. NFT structs are extensible and attributes are not",
      "isCorrect": false
    },
    {
      "answer": "C. NFT struct fields are dynamic and can be renamed or change type of needed",
      "isCorrect": false
    }
  ],
  "lessonId": "6",
  "codeDef": "",
  "title": "NFT Attributes",
  "quizTitle": "Why is using explicit fields in the NFT struct sometimes better than attributes?",
  "content": "As shown in the previous lesson, the best way to add attributes to a token is when it's just minted. The mint_nft function can either take a list of attributes from users or add its own attributes as it sees fit:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nDevelopers have an interesting tradeoff here when deciding how to add attributes to an NFT:\n1. Add directly as fields in the NFT struct (e.g. name, description)\n2. Add via attributes\n\nThe main benefit of using attributes is because new attributes can be added later (post-minting) without having to add new fields to the NFT struct. After the module is deployed, an existing struct cannot be modified or have new fields added:\n\n```\nuse sui::vec_map;\n\npublic fun add_new_attributes(kite_nft: &mut KiteNFT, new_attribute_name: String, new_attribute_value: String) {\n    let new_attributes = vec_map::empty<String, String>();\n    vec_map::insert(&mut new_attributes, new_attribute_name, new_attribute_value);\n    attributes::add_new(&mut kite_nft.id, new_attributes);\n}\n```\nattributes::add_new takes a VecMap (a map of keys to values) so we need to create one before calling the function. The key and value types can be anything (primitives, structs, etc.) as long as the key type is copyable."
}

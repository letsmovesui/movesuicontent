{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Fields are explicit and thus easier to see while attributes are dynamic and harder to know the full list",
      "isCorrect": true
    },
    {
      "answer": "B. NFT structs are extensible and attributes are not",
      "isCorrect": false
    },
    {
      "answer": "C. NFT struct fields are dynamic and can be renamed or change type of needed",
      "isCorrect": false
    }
  ],
  "lessonId": "6",
  "codeDef": "",
  "title": "NFT Attributes",
  "quizTitle": "Why is using explicit fields in the NFT struct sometimes better than attributes?",
  "content": [
    "As shown in the previous lesson, the best way to add attributes to a token is when it's just minted. The mint_nft function can either take a list of attributes from users or add its own attributes as it sees fit:\n",
    "```\n",
    "use nft_protocol::attributes::{Self, Attributes};\n",
    "use nft_protocol::mint_cap;\n",
    "use nft_protocol::mint_event;\n",
    "use sui::url;\n",
    "\n",
    "struct KiteNFT has key {\n",
    "    id: UID,\n",
    "    url: Url,\n",
    "    attributes: Attributes,\n",
    "}\n",
    "\n",
    "public fun mint_nft(\n",
    "    mint_cap: &MintCap<Kite>,\n",
    "    name: String,\n",
    "    description: String,\n",
    "    url: String,\n",
    "    ctx: &mut TxContext,\n",
    ") {\n",
    "    let attributes = attributes::from_vec(\n",
    "        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n",
    "        vector[name, description],\n",
    "    );\n",
    "    let nft = KiteNFT {\n",
    "        id: object::new(ctx),\n",
    "        url: url::new_unsafe(url),\n",
    "        attributes,\n",
    "    };\n",
    "    transfer::public_transfer(nft, tx_context::sender(ctx));\n",
    "    \n",
    "    mint_event::emit_mint(\n",
    "        witness::from_witness(Witness {}),\n",
    "        mint_cap::collection_id(mint_cap),\n",
    "        &nft,\n",
    "    );\n",
    "}\n",
    "```\n",
    "Developers have an interesting tradeoff here when deciding how to add attributes to an NFT:\n",
    "1. Add directly as fields in the NFT struct (e.g. name, description)\n",
    "2. Add via attributes\n",
    "\n",
    "The main benefit of using attributes is because new attributes can be added later (post-minting) without having to add new fields to the NFT struct. After the module is deployed, an existing struct cannot be modified or have new fields added:\n",
    "\n",
    "```\n",
    "use sui::vec_map;\n",
    "\n",
    "public fun add_new_attributes(kite_nft: &mut KiteNFT, new_attribute_name: String, new_attribute_value: String) {\n",
    "    let new_attributes = vec_map::empty<String, String>();\n",
    "    vec_map::insert(&mut new_attributes, new_attribute_name, new_attribute_value);\n",
    "    attributes::add_new(&mut kite_nft.id, new_attributes);\n",
    "}\n",
    "```\n",
    "attributes::add_new takes a VecMap (a map of keys to values) so we need to create one before calling the function. The key and value types can be anything (primitives, structs, etc.) as long as the key type is copyable.\n"
  ]
}

{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "7",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        // Add royalty logic here\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
  "title": "Royalty",
  "quizTitle": "Update init function to charge a 2% royalty for all SuiFrens. All royalty should be sent to the sui_fren module publisher.",
  "content": "NFT royalty is a mechanism that allows creators and artists to earn a percentage of the resale price of their digital assets whenever those assets are sold in secondary markets. It provides a way for creators to continue benefiting from the appreciation of their work even after the initial sale.\n\nHere's how royalties work in NFTs:\n\n1. Initial Sale: When an NFT is initially minted and sold by the creator (often referred to as the \"primary sale\"), the creator can specify a percentage of the sale price that they want to receive as a royalty. This percentage is typically set in the NFT's smart contract during the minting process.\n2. Secondary Sales: After the initial sale, the NFT can be resold or traded by its owner in secondary markets (e.g., NFT marketplaces). When a secondary sale occurs, the creator is automatically entitled to receive the specified percentage (the royalty) of the resale price. The platform or marketplace facilitating the sale automatically deducts this royalty and transfers it to the creator's wallet.\n3. Continuous Earnings: Royalties provide creators with a continuous stream of income as long as their NFTs are being resold. This incentivizes artists and creators to produce high-quality and desirable digital content, as they can participate in the value appreciation of their work over time.\n4. Transparency: Royalties in NFTs are transparent and verifiable on the blockchain. The smart contract associated with the NFT specifies the royalty percentage and ensures that it is automatically enforced during secondary sales. This transparency builds trust between creators and buyers, as both parties can see how royalties are distributed.\n5. Benefits for Collectors: Royalties can also be beneficial for collectors and investors, as they can have confidence that their investment in an NFT may appreciate in value over time. Knowing that a portion of future resale proceeds will go back to the original creator can enhance the perceived value of an NFT.\n\nOne note here is royalty is usually guaranteed to be enforced by standards such as OriginByte. They're commonly enforced by the marketplaces and exchanges that support listing NFTs for sale. This is because payment methods can vary (different types of coins, other NFTs, debt notes, etc.) and the amount is self-reported by the marketplaces.\n\nHowever, standards like OriginByte does offer mechanisms for creators to define policies (\"strategies\" as called by OriginByte) regarding how royalty can be computed and enforced. This offers a standardized format for royalty and makes it much easier for exchanges to charge royalty.\n\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nIn the example above, we added a royalty of 1% that is 100% paid to a single creator (the module's deployer). Note behind the scene, royalty_strategy_bps::create_domain_and_add_strategy effectively adds the royalty as an attribute (\"domain\") via collection::add_domain the same way we added other attributes. It also creates and enforces (via royalty_strategy_bps::enforce) a special transfer policy. We'll cover TransferPolicy in more details in the lesson on Kiosk later as TransferPolicy is a concept introduced by the Kiosk standard.\n\nHow exactly marketplaces enforce royalty via a combination of royalty_strategy_bps, TransferPolicy and TransferRequest is outside the scope of this lesson. Curious learners are encouraged to look at the [source code](https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/nft_protocol/sources/rules/royalty_strategy.move#L65) to understand how this really works behind the scene.\n"
}

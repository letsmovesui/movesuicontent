{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Because users wouldn't be able to list without the owner being involved",
      "isCorrect": false
    },
    {
      "answer": "B. Because anyone can directly delist another user's listing and take the NFT for themselves",
      "isCorrect": true
    },
    {
      "answer": "C. Because KioskOwnerCap cannot be shared",
      "isCorrect": false
    }
  ],
  "lessonId": "12",
  "codeDef": "",
  "title": "Kiosk Standard - Trading NFTs",
  "quizTitle": "When creating a permissionless kiosk, why is it bad to make the KioskOwnerCap a shared object?",
  "content": "# Intro to NFT marketplaces\nNFT (Non-Fungible Token) marketplaces are vital hubs in the NFT ecosystem, enabling the buying, selling, and trading of unique digital assets. They matter for several key reasons:\n\n1. Accessibility: NFT marketplaces make it easy for people to enter the world of digital collectibles and unique content.\n2. Discoverability: These platforms provide tools for users to find NFTs that match their interests, fostering exploration and connection.\n3. Trust and Security: Blockchain technology ensures transparency, authenticity, and secure transactions.\n4. Secondary Sales: NFT marketplaces facilitate reselling, allowing creators to earn royalties, and investors to potentially profit.\n5. Community and Engagement: They build communities around NFTs, fostering interaction and collaboration.\n6. Monetization for Creators: Artists and creators can monetize their work directly on these platforms.\n\n# Kiosk - Sui's marketplace standard\nSui Kiosk is a standard for object marketplaces that support listing and selling. This is available as part of the Sui framework deployed at 0x2 and has a lot of powerful features that can support NFT trading well.\n\nKiosk modules can be found [here](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/kiosk) and offer the following features (also works for non-NFT objects):\n* Create and manage a new NFT marketplace (a kiosk)\n* Transfer ownership of the NFT marketplace\n* Listing and delisting NFTs\n* Purchasing listed NFTs\n* TransferPolicy allowing the NFT type owners (creators) to define custom rules for every trade of their NFT, including royalty enforcement (what we've seen with OriginByte in a previous lesson) and allowlisting\n\nKiosk currently only supports using SUI coins as payment but developers can deploy their own version of Kiosk to support other Coins if they want to.\n\n# Trading on Kiosk\nFirst a kiosk needs to be created:\n```\nstruct KioskManagement has key {\n    id: UID,\n    owner_cap: KioskOwnerCap,\n}\n\npublic fun create_kiosk(ctx: &mut TxContext) {\n    let (kiosk, owner_cap) = kiosk::new(ctx);\n    transfer::public_share_object(kiosk);\n    let kiosk_management = KioskManagement {\n        id: object::new(ctx),\n        owner_cap,\n    };\n    transfer::public_share_object(kiosk_management);\n}\n```\nIn the above example, we called kiosk::new to create the kiosk. Since it returns 2 objects that are both not droppable, we need to either share or transfer them. If developers choose to transfer and keep these objects, these kiosks can be considered \"personal kiosks\" as all listings and purchases require mutable access to the kiosk and/or the owner cap which only the owner has.\n\nIn the above example, we made the kiosk object shared and add the owner cap to a shared KioskManagement object. This would make the kiosk permissionless - anyone can list on it, subject to any rules we want in the list function:\n```\npublic fun list_on_kiosk<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft: T,\n) {\n    // Any validation we want of the NFT being listed.\n    kiosk::place(kiosk, &kiosk_management.owner_cap, nft);\n    // Keep track of the lister.\n}\n```\nkiosk::place requires a reference to the KioskOwnerCap object, which can be obtained from the shared kiosk_management object. Users have to call our list_on_kiosk function and cannot call kiosk::place directly as they don't have direct access to the owner cap object inside KioskManagement. Another note here is for an NFT to be listed for sale, the NFT type must have store ability.\n\nSellers can also delist the NFT. Note that we need to make sure whoever calls delist is the same person who created the listing originally. This can be tracked via a shared object with dynamic fields.\n```\npublic fun delist<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft_id: ID,\n) {\n    let sender = tx_context::sender(ctx);\n    // Validate that the sender is the same person who created the listing.\n    let nft = kiosk::take<T>(kiosk, &kiosk_management.owner_cap, nft_id);\n    transfer::public_transfer(nft, sender);\n}\n```\n\nSince the kiosk is a shared object, anyone can call sui::kiosk::purchase directly to purchase an NFT from a listing:\n```\n/// Make a trade: pay the owner of the item and request a Transfer to the `target`\n/// kiosk (to prevent item being taken by the approving party).\n///\n/// Received `TransferRequest` needs to be handled by the publisher of the T,\n/// if they have a method implemented that allows a trade, it is possible to\n/// request their approval (by calling some function) so that the trade can be\n/// finalized.\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {\n    let price = df::remove<Listing, u64>(&mut self.id, Listing { id, is_exclusive: false });\n    let inner = dof::remove<Item, T>(&mut self.id, Item { id });\n\n    self.item_count = self.item_count - 1;\n    assert!(price == coin::value(&payment), EIncorrectAmount);\n    df::remove_if_exists<Lock, bool>(&mut self.id, Lock { id });\n    coin::put(&mut self.profits, payment);\n\n    event::emit(ItemPurchased<T> { kiosk: object::id(self), id, price });\n\n    (inner, transfer_policy::new_request(id, price, object::id(self)))\n}\n```\nNote that while this returns the NFT purchased, it also does return a TransferRequest that cannot be dropped and needs to be \"validated\" before the transaction ends. We'll talk more about this as part of TransferPolicy in the next lesson."
}

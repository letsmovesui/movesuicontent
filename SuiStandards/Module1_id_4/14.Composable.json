{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::option::{Self, Option};\n    use std::string::String;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        hat: Option<Hat>,\n        sunglasses: Option<SunGlasses>,\n    }\n\n    struct Hat has key {\n        id: UID,\n        diameter: u64\n    }\n\n    struct SunGlasses has key {\n        id: UID,\n        color: String,\n    }\n\n    entry fun wear_hat(sui_fren: &mut SuiFren, hat: Hat) {\n        option::fill(&mut sui_fren.hat, hat);\n    }\n\n    entry fun wear_sunglasses(sui_fren: &mut SuiFren, sun_glasses: SunGlasses) {\n        option::fill(&mut sui_fren.sun_glasses, sun_glasses);\n    }\n}\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "14",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    // Add the new structs and new functions here.\n}\n",
  "title": "Composable NFTs",
  "quizTitle": "1. Add a new Hat NFT with a diameter field of type u64.\n2. Add a new SunGlasses NFT with a color of type String.\n3. Update the SuiFren NFT to allow it to optionally wear a hat and sunglasses\n4. Add two new entry functions wear_hat and wear_sunglasses that allows the SuiFren to wear a hat and sunglasses, respectively",
  "content": [
    "Similar to objects, NFTs can be combined together (\"composed\") using the different object techniques we've learnt in previous courses:\n",
    "1. Wrapping - Adding an NFT that has store ability as a field on another NFT. This removes the child NFT from storage.\n",
    "2. Dynamic object fields - Add the child NFT as a dynamic object field. Doesn't remove it from storage.\n",
    "3. Dynamic fields: Similar to dynamic object fields but the child NFT is removed from storage.\n",
    "4. Objects owning objects: Similar to dynamic object fields but have different syntax for accessing the child NFT (Receiving<T>) and maintain strict ownership chain.\n",
    "\n",
    "Among these different approaches, it's the most straightforward to use object wrapping. A strong benefit here is that it's clear to UIs and games what NFTs can be added to an NFT such as adding weapons, armors, etc. to a hero NFT. Child NFTs can also be used to represent \"Traits\" of an NFT such as background.\n",
    "```\n",
    "struct Background has key, store {\n",
    "    id: UID,\n",
    "    type: String,\n",
    "}\n",
    "\n",
    "struct Eyewear has key, store {\n",
    "    id: UID,\n",
    "    type: String,\n",
    "}\n",
    "\n",
    "struct Armor has key, store {\n",
    "    id: UID,\n",
    "    defense: u64,\n",
    "    durability: u64,\n",
    "}\n",
    "\n",
    "struct Weapon has key, store {\n",
    "    id: UID,\n",
    "    num_uses: u64,\n",
    "    power: u64,\n",
    "}\n",
    "\n",
    "struct Hero has key {\n",
    "    id: UID,\n",
    "    background: Background,\n",
    "    eyewear: Eyewear,\n",
    "    armor: Armor,\n",
    "    weapon: Weapon,\n",
    "}\n",
    "```\n",
    "In the example above, Hero is a single NFT that wraps other NFTs as specific fields. The way it's currently written, a Hero must always have all of the child NFTs - background, eyewear, armor, weapon. If we want to make armor optional for example (a hero can wear or not wear armors), we can use the Option type:\n",
    "```\n",
    "use std::option::Option;\n",
    "\n",
    "struct Hero has key {\n",
    "    id: UID,\n",
    "    background: Background,\n",
    "    eyewear: Eyewear,\n",
    "    armor: Option<Armor>,\n",
    "    weapon: Weapon,\n",
    "}\n",
    "\n",
    "public fun wear_armor(hero: &mut Hero, armor: Armor) {\n",
    "    option::fill(&mut hero.armor, armor);\n",
    "}\n",
    "\n",
    "public fun take_off_armor(hero: &mut Hero) {\n",
    "    let armor = option::extract(&mut hero.armor);\n",
    "    transfer::public_transfer(armor, tx_context::sender(ctx));\n",
    "}\n",
    "```\n",
    "We can then use `option::fill` and `option::extract` to add or remove the armor.\n",
    "\n",
    "The benefit of using composable NFTs like this is if we sell the Hero NFT on a marketplace, all of the wrapped items also come with it. We can also freely remove the items if they're optional and transfer them between the different Hero NFTs we have. Composable NFT can be a very powerful primitive to build rich games and applications."
  ]
}

{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n}\n",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "9",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
  "title": "NFT's display attributes",
  "quizTitle": "Update init function to also create a display object for the SuiFren NFT. The display object should only print out the generation and birthdate with the following keys/formats:\ngeneration: \"SuiFren generation: {generation}\"\nbirthdate: \"Born on {birthdate}\"\n\nThe display object will be transferred to the module deployer for simplicity.",
  "content": "In previous lessons, we've seen how we can add attributes when minting an NFT:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nIn the intermediate Object course, we talked about Display object and how it can be used to instruct Web UIs and wallets to display the object to users. It can also allow adding attributes that are for display purposes only without burdening the actual object and can be used for cross-cutting changes that apply to all objects of the same type.\n\nWe can also use Display object to dictate how NFT objects are displayed as well by creating one when the collection is minted:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n    \n    let publisher = package::claim(otw, ctx);\n    let display_object = display::new<KiteNFT>(&publisher, ctx);\n    display::add_multiple(\n        &mut display,\n        vector[\n            utf8(b\"All attributes\"),\n            utf8(b\"url\"),\n        ],\n        vector[\n            utf8(b\"All attributes: {attributes}\"),\n            utf8(b\"Image url: {url}\"),\n        ],\n    );\n    display::update_version(&mut display);\n    transfer::public_transfer(display, tx_context::sender(ctx));\n}\n```\nOnce the display object is created, an event is emitted that allows the Sui network nodes to detect the Display object. Subsequently, whenever an object is fetched via the node API, its display attributes are also computed in the exact formatting specified and returned along with the rest of the object's fields.\n\nIn the example above, we also send the display object to the module deployer in case we need to update the display attributes and formatting in the future. If developers are certain the display attributes won't ever change, they can also freeze the object. If they want to have custom logic as to when the display attributes can be added/modified/removed, they can also share the object."
}

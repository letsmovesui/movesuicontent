{
  "codeSol": "",
  "quizType": "ANSWERS",
  "answers": [
    {
      "answer": "A. Because buying an item off the Kiosk returns an undroppable TransferRequest",
      "isCorrect": true
    },
    {
      "answer": "B. Because money can be obtained from the user's account later if they refuse to pay",
      "isCorrect": false
    },
    {
      "answer": "C. Because TransferPolicy cannot be dropped",
      "isCorrect": false
    }
  ],
  "lessonId": "13",
  "codeDef": "",
  "title": "Kiosk Standard - Transfer Policy",
  "quizTitle": "Why can't users ignore TransferPolicy?",
  "content": "Kiosk has a very powerful functionality that allows NFT creators to dictate the rules for trading their NFTs such as royalty as we've seen in previous lessons: TransferPolicy. In the previous lesson, we've seen how purchasing an NFT first returns a TransferRequest that cannot be dropped:\n```\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {...}\n```\nIn order to resolve this TransferRequest, users need to call sui::transfer_policy::confirm_request:\n```\n/// Allow a `TransferRequest` for the type `T`. The call is protected\n/// by the type constraint, as only the publisher of the `T` can get\n/// `TransferPolicy<T>`.\n///\n/// Note: unless there's a policy for `T` to allow transfers,\n/// Kiosk trades will not be possible.\npublic fun confirm_request<T>(\n    self: &TransferPolicy<T>, request: TransferRequest<T>\n): (ID, u64, ID) {\n    let TransferRequest { item, paid, from, receipts } = request;\n    let completed = vec_set::into_keys(receipts);\n    let total = vector::length(&completed);\n\n    assert!(total == vec_set::size(&self.rules), EPolicyNotSatisfied);\n\n    while (total > 0) {\n        let rule_type = vector::pop_back(&mut completed);\n        assert!(vec_set::contains(&self.rules, &rule_type), EIllegalRule);\n        total = total - 1;\n    };\n\n    (item, paid, from)\n}\n```\nAs you can see transfer_policy::confirm_request goes through a list of \"rules\" that are completed in the request and check if all rules are satisfied. Note that confirm_request requires a TransferPolicy which can only be obtained by calling transfer_policy::new as we've seen earlier in the royalty lesson:\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nThis means the TransferPolicy can only be created by the creator and thus the creator can store it somewhere and add a function that confirms/resolves TransferRequest after checking that the royalty has been paid. They can add more rules to the policy by calling transfer_policy::add_rule as well\n```\nstruct TransferPolicyHolder<phantom T> has key {\n    id: UID,\n    transfer_policy: TransferPolicy<T>,\n}\n\npublic fun confirm_request(holder: &TransferPolicyHolder, request: TransferRequest<T>) {\n    // Verify our rules and add receipts for each confirmed rule to the request.\n    \n    transfer_policy::confirm_request(&holder.transfer_policy, request);\n}\n```\nTransferPolicyHolder is a shared object and users can always add it as an argument as the last step in the PTB (Programmable Transaction Block) after purchasing an NFT in the previous step.\n\nOverall, TransferPolicy is a very powerful primitive that allows for building very rich NFT collections and marketplaces."
}

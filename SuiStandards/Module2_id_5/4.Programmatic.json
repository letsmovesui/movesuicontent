{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "4",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    // Add the new struct here\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    entry fun mint(treasury_cap: &mut TreasuryCap<Candy>, amount: u64, ctx: &mut TxContext) {\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
  "title": "Programmatic Coin minting",
  "quizTitle": "Create a `CandyTreasuryCapHolder` object struct and update `sui_fren::init` and mint functions to use it to allow users to freely mint candies.",
  "content": [
    "We have learnt how to use the generated `TreasuryCap<CoinType>` object to mint the coins. However, only the `TreasuryCap` owner can call it. What if we want to allow users to freely mint coins (may be up to a certain limit)? How would this work?\n",
    "\n",
    "If you look at how the `TreasuryCap` object struct is defined, it has the store ability:\n",
    "```\n",
    "/// Capability allowing the bearer to mint and burn\n",
    "/// coins of type `T`. Transferable\n",
    "struct TreasuryCap<phantom T> has key, store {\n",
    "    id: UID,\n",
    "    total_supply: Supply<T>\n",
    "}\n",
    "```\n",
    "This means, it can be stored in other structs and objects! So the solution here would be to wrap it in a shared object that anyone can access and provide as an argument to the mint function:\n",
    "```\n",
    "use std::string;\n",
    "use sui::url;\n",
    "\n",
    "struct MYCOIN has drop {}\n",
    "\n",
    "struct TreasuryCapHolder has key {\n",
    "    id: UID,\n",
    "    treasury_cap: TreasuryCap<MYCOIN>,\n",
    "}\n",
    "\n",
    "fun init(otw: MYCOIN, ctx: &mut TxContext) {\n",
    "    let (treasury_cap, metadata) = coin::create_currency(\n",
    "        otw,\n",
    "        9,\n",
    "        b\"MYC\",\n",
    "        b\"MyCoin\",\n",
    "        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n",
    "        ctx,\n",
    "    );\n",
    "    transfer::public_freeze_object(metadata);\n",
    "    \n",
    "    let treasury_cap_holder = TreasuryCapHolder {\n",
    "        id: object::new(ctx),\n",
    "        treasury_cap,\n",
    "    };\n",
    "    transfer::share_object(treasury_cap_holder);\n",
    "}\n",
    "\n",
    "entry fun mint(treasury_cap_holder: &mut TreasuryCapHolder, ctx: &mut TxContext) {\n",
    "    let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n",
    "    let coins = coin::mint(treasury_cap, 1000, ctx);\n",
    "    // Do something with the coins\n",
    "}\n",
    "```\n",
    "In the example above, we wrap `TreasuryCap<MYCOIN>` inside a shared `TreasuryCapHolder` object. Anyone can now passes `&mut TreasuryCapHolder` to the mint function and mint `MYCOIN` coins freely. In practice, the developers should add some restrictions such as how many coins can be minted in total, how many each user can mint, allowlist-based control, etc.\n",
    "\n",
    "As discussed in the `Object` courses, beside wrapping the `TreasuryCap` object into another holder object, we can also leverage dynamic fields, dynamic object fields or even object ownership to retain the `TreasuryCap`. However, wrapping is generally preferred because of its simplicity when accessing."
  ]
}

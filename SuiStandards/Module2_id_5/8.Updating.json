{
  "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n        metadata: CoinMetadata<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun update_icon_url(holder: &mut CandyTreasuryCapHolder, new_icon_url: String) {\n        let metadata = &mut holder.metadata;\n        let treasury_cap = &holder.treasury_cap;\n        coin::update_icon_url(treasury_cap, metadata, new_icon_url);\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "8",
  "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n}",
  "title": "Updating Coin metadata",
  "quizTitle": "Add a metadata field to the `CandyTreasuryCapHolder` object and update the `init` function accordingly. Add a `update_icon_url` entry function that allows changing the Candy coin's icon url.\nHint: You can use `option`",
  "content": "When we created `MyCoin` earlier, we froze the metadata object returned. This would not allow for any changes to the metadata (decimals/symbol/name/description/logo url) in the future.\n\nSpeaking of decimals, we never really explained what it's for. `Decimals` are often used for Coins/tokens in order to reduce rounding errors. Most smart contract languages, including Move, do not have fractional numbers and all math operations are integer-based. This means 5 / 2 = 2 in Move, leading to a rounding error of 1. If there are no decimals, people would be losing a lot of money left and right. A decimals of at least 6 is often used in crypto and can be sometimes as high as 18 (1 coin = 10^18 units). In most cases, 9 is more than sufficient to make the rounding error small and negligible to users.\n\nBack to the metadata object, if you think there could be a chance you might want to change the coin's metadata in the future, you should not freeze it and instead transfer to an admin account for safekeeping. In the future, you can then leverage the different functions in coin to update the metadata you want:\n\n```\n/// Update name of the coin in `CoinMetadata`\npublic entry fun update_name<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, name: string::String\n) {\n    metadata.name = name;\n}\n\n/// Update the symbol of the coin in `CoinMetadata`\npublic entry fun update_symbol<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, symbol: ascii::String\n) {\n    metadata.symbol = symbol;\n}\n\n/// Update the description of the coin in `CoinMetadata`\npublic entry fun update_description<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, description: string::String\n) {\n    metadata.description = description;\n}\n\n/// Update the url of the coin in `CoinMetadata`\npublic entry fun update_icon_url<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, url: ascii::String\n) {\n    metadata.icon_url = option::some(url::new_unsafe(url));\n}\n```\nNote that decimals is a special case and there's no update function for it. This is because decimals is a fundamental property of a coin and can change everyone's balance if it's updated. Therefore, for safety and simplicity, Sui's Coin standard doesn't allow modifying decimals.\n\nIn order to call an update function such as `coin::update_symbol`, the caller needs to have access to both `TreasuryCap` and `metadata` object. Note that both `TreasuryCap` and `Metadata` structs have the store ability so we can store them somewhere that allows programmatic access and modification later on:\n\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct CoinDataHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n    metadata: CoinMetadata<MYCOIN>,\n}\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    \n    let treasury_cap_holder = TreasuryCapHolder {\n        id: object::new(ctx),\n        treasury_cap,\n        metadata,\n    };\n    transfer::share_object(treasury_cap_holder);\n}\n\nentry fun update_symbol(holder: &mut CoinDataHolder, new_symbol: String) {\n    let metadata = &mut holder.metadata;\n    let treasury_cap = &holder.treasury_cap;\n    coin::update_symbol(treasury_cap, metadata, new_symbol);\n}\n```\nIn the example above, we wrap both the `TreasuryCap` and the `Metadata` objects into a shared object that can be accessed by anyone later to update coin metadata. In practice, developers can add logic that require the sender to be a specific admin address to make sure suers don't arbitrarily update coin metadata."
}

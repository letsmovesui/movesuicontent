{
  "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::coin::{Self, Coin};\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n        candies: Balance<CANDY>,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut holder.treasury_cap;\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n            candies: coin::mint(treasury_cap, amount, ctx),\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun open_gift(gift_box: GiftBox, ctx: &mut TxContext) {\n        let GiftBox { id, sui_fren, candies } = gift_box;\n        object::delete(id);\n        transfer::public_transfer(sui_fren, tx_context::sender(ctx));\n        let candy_coins = coin::from_balance(candies, ctx);\n        transfer::public_transfer(candy_coins, tx_context::sender(ctx));\n    }\n}",
  "quizType": "CODING",
  "answers": [],
  "lessonId": "11",
  "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}",
  "title": "Storing Balance and Coin in custom objects",
  "quizTitle": "1. Update the `GiftBox` object we created in the previous course to contain a single `SuiFren` and an amount of `candies (coins)` as `Balance<CANDY>`\n2. Update `create_gift` function to generate the indicated amount of candies in the gift box\n3. Add a `open_gift` function that destroys the gift box and sends both the `SuiFren` and the candies to the sender.",
  "content": "As discussed in previous lessons, both `Coin` and `Store` objects have the store ability and can be embedded inside other structs (\"wrapped\" in Coin's case since it's an object struct).\n```\nstruct MyObjectWithBalance has key {\n    id: UID,\n    balance: Balance<MYCOIN>,\n}\n\nstruct MyObjectWithCoin has key {\n    id: UID,\n    coins: Coin<MYCOIN>,\n}\n```\nAs discussed in the previous lesson, it might be more common to store `Balance` instead of `Coin`. But why would someone store `Balance` in a custom struct? The most common reason for this structure is to have coins that are programmatically owned by a smart contract or module. For example, users can be building a marketplace where users can list their own `Coins` to trade against other `Coins`. In this case, when a buyer comes along, we don't want the seller to also have to sign the buy transaction. It's a lot smoother if the buyer just signs and the trade automatically happens - they receive the coins they're buying and the coins they're paying with are taken out of their wallet (`Coin` object).\n```\nstruct Listing<phantom CoinType> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<CoinType>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<CoinType>(listing: Listing<CoinType>, payment: Coin<SUI>): Balance<CoinType> {\n    let Listing<CoinType> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nIn the example above, the seller can create a listing to include the coins they want to sell directly as a shared object. The listed coins are included in the listing object. Once a buyer comes along with the payment, the listing can be destroyed to return the inner listed coins as `Balance<CoinType>`. In the PTB (Programmable transaction block), the seller can choose to merge `Balance<CoinType>` into any of the Coin objects of the same type they own.\n\nNote that `CoinType` is preceded by the phantom keyword. This is required because none of Listing's fields is directly of type CoinType. We see `Balance<CoinType>` but `CoinType` is used as a generic here instead of a direct type. In short, the phantom keyword is required for a struct if the type is only used as a generic in one or more of its fields.\n\nNote that we use the generic `<CoinType>` here so this system would work for any coin types!"
}

{
  "name": "Intermediate Move",
  "lesson": [
    {
      "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    public fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct MintEvent has copy, drop {\n        id: ID,\n    }\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let uid = object::new(ctx);\n        let id = object::uid_to_inner(&uid);\n        let sui_fren = SuiFren {\n            id: uid,\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n        event::emit(MintEvent {\n            id,\n        });\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "1",
      "codeDef": "// Add the new module and function here\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    // Add any friend declaration here\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct MintEvent has copy, drop {\n        id: ID,\n    }\n\n    // Update\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let uid = object::new(ctx);\n        let id = object::uid_to_inner(&uid);\n        let sui_fren = SuiFren {\n            id: uid,\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n        event::emit(MintEvent {\n            id,\n        });\n    }\n}",
      "title": "Package protected function - public(friend) and Gift boxes",
      "quizTitle": "Currently, anyone can mint `Sui Frens`. Let's:\n1. Make mint function friend only\n2. Add a new module `0x123::fren_summer` with a public function `open_box` which has the same signature as `sui_fren::mint` (for now) and call `sui_fren::mint` there. \nWe'll explain what this function will be used for in the next lessons.",
      "content": "In the previous course, we have covered the basic concepts in Sui Move: Modules, Functions, Objects and Events. In this course, we'll dive deeper into more useful concepts in Move and Objects that allow us to build a more fun and complex Sui Fren world.\n\nLet's first talk about functions. In the previous course, we saw public and private functions:\n1. Public functions can be called by transactions (via Programmable Transaction Blocks that we'll cover later) and also by other Move code (same or different modules)\n2. Private functions can only be called within the same module.\n```\nmodule 0x123::my_module {\n    public fun public_equal(x: u64): bool {\n        x == 1000\n    }\n    \n    fun private_equal(x: u64): bool {\n        x == 1000\n    }\n}\n```\nIf you recall, modules are grouped into packages for deployment on Sui. This leads to a third type of function visibility - `public(friend)`. `public(friend)` functions are similar to package-visible functions in other languages and can only be called by modules in the same package. This allows developers to limit dangerous functions to only be called by their own modules and not by others.\n```\nmodule 0x123::my_other_module {\n    use 0x123::my_module;\n\n    public fun do_it(x: u64): bool {\n        my_module::friend_only_equal(x)\n    }\n}\n\nmodule 0x123::my_module {\n    friend 0x123::my_other_module;\n\n    public(friend) fun friend_only_equal(x: u64): bool {\n        x == 1000\n    }\n}\n```\nTo create a `public(friend)` function we just need to use the corresponding visibility modified - `public(friend)`. Any modules such `0x123::my_other_module` in the example above that call the `public(friend)` function also needs to be declared explicitly as a \"friend\" - friend `0x123::my_other_module`. This explicit declaration is required for now but the Sui Move team has plans to make this not required in the future. This would truly make public(friend) functions package-visible."
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "2",
      "codeDef": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    public fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}",
      "title": "Programmable Transaction Block and Entry functions: Open gift boxes",
      "quizTitle": "Update `fren_summer::open_box` to be a private entry function.",
      "content": "Another important type of function is entry functions. In the old Move language, there are two types of entry functions - public entry and private entry.\n\nOn the Sui network, a Programmable Transaction Block (PTB) allows users to specify a series of actions (transactions) to be sent to the network as a single transaction. The actions are executed sequentially and are atomic - if any of them fails, the entire PTB fails and all changes are automatically reverted. PTB is a powerful concept that will be covered more in later courses. For now, we'll refer to PTBs as transactions that users send to the Sui blockchain. PTBs can call any public, public entry and private entry functions written in Move modules. Therefore, there are effectively no differences between public and public entry functions in Sui although these concepts are still inherited from classic Move.\n\nThe only new function type we need to learn is private entry functions, which can only be called directly from a transaction, but not from other Move code.\n\nPrivate entry functions (entry functions for short) are useful when developers want to offer features directly to users that can only be called as part of a transaction but not in other module. One example could be clipping a ticket - we want users to have to explicitly have to call this as part of the transaction and don't want other modules to clip a user's ticket on their behalf. The latter is harder for users to detect and they might not expect this to happen when sending a transaction.\n```\nentry fun clip_ticket(ticket: Ticket) {\n    let Ticket {\n          id,\n          expiration_time: _,\n      } = ticket;\n      object::delete(id);\n}\n```\n"
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "3",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n\n    // Add the new struct here\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
      "title": "Struct abilities - key, copy, drop, store",
      "quizTitle": "Give `SuiFren` store ability and define a new GiftBox object struct in the `fren_summer` module that has a field inner of type `SuiFren`. The GiftBox struct doesn't need store ability as it doesn't need to be part of any other structs.",
      "content": "In the previous course, we learnt about structs and how a struct needs to have the key ability to become an object:\n```\nstruct AdminCap has key {\n    id: UID,\n    num_frens: u64,\n}\n```\nBeside the key ability, structs can also have 3 other abilities: store, copy, and drop. Structs can have 1, 2, 3, or all 4 abilities. However, for a struct to have a specific ability, all of its fields must have the same ability.\n\nStore ability allows a struct to be part of other structs. Note that if `NestedStruct` below has another `DoubleNestedStruct` field, that struct also needs to have store ability.\n```\nstruct NestedStruct has store {\n    value: u64,\n}\n\nstruct Container has key {\n    id: UID,\n    nested: NestedStruct,\n}\n```\nCopy ability allows a struct to be \"copied\", which creates an instance of the struct with the same exact field values. Note that object structs (those with key ability and id field) cannot have the copy ability as the UID struct doesn't have copy.\n```\nstruct CopyableStruct has copy {\n    value: u64,\n}\n\nfun copy(original: CopyableStruct) {\n    let copy = original;\n    original.value = 1;\n    copy.value = 2;\n    // We now have two CopyableStructs with two different values.\n}\n```\nDrop ability allows a struct to be implicitly destroyed at the end of a function without having to \"destruct\":\n```\nstruct DroppableStruct has drop {\n    value: u64,\n}\n\nfun copy() {\n    let droppable = DroppableStruct { value: 1 };\n    // At the end of this function, droppable would be destroyed.\n    // We don't need to explicitly destruct:\n    // let DroppableStruct { value: _ } = droppable;\n}\n```\nIt's very important to remember that a struct can only have an ability if ALL of its fields have the same ability. Without remembering this, developers can get very confused if they try to create a droppable struct while having an undroppable field."
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun create_gift(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    public(friend) fun create(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\n        SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        }\n    }\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let sui_fren = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "4",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new functions here\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new function here\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let sui_fren = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n    }\n}",
      "title": "Object wrapping - Wrapping Sui Frens in Gift Boxes",
      "quizTitle": "Let's add a few new functions:\n1. Add a friend function to the `sui_fren` module - create, which has the same arguments as mint and creates and returns a `SuiFren`.\n2. Add a new entry function to `fren_summer` - `create_gift`, which has the same arguments as `sui_fren::create`, calls `sui_fren::create` to create a `SuiFren`, puts it into a `GiftBox`, and sends the `GiftBox` to the sender.\n3. Add a new entry function to `fren_summer` - `wrap_fren`, which takes an existing `SuiFren` argument named `fren`, wraps it in a `GiftBox`, and sends the `GiftBox` to the sender.",
      "content": "We created a new type of object - `GiftBox` that has a `SuiFren` in it. But how do we get a `SuiFren` in there? There are two options here:\n1. Create a new function in `sui_fren` - create, that creates a `SuiFren` object and returns it, instead of immediately transferring it to the sender like the mint function.\n2. Mint the `SuiFren` first. Once the transfer has happened in mint, we cannot retrieve the `SuiFren` in the same transaction and would need to do that in a followup transaction while explicitly passing that `SuiFren` in as an argument. We can add a wrap function in `fren_summer` that allows the sender to wrap an existing `SuiFren` and create a gift box. They can later send it to friends.\n\nIn the second case, putting the `SuiFren` into the `GiftBox` is called <b>object wrapping<b>. This does more than you think - it takes the object being wrapped <b>out of the object storage<b>. This means that if you have a UI that displays all the `SuiFrens` a user owns, that `SuiFren` they wrapped will disappear from the list.\n```\nstruct Box has key {\n    id: UID,\n    thing: Thing,\n}\n\nstruct Thing has key, store {\n    id: UID,\n}\n\npublic fun wrap(thing: Thing, ctx: &mut TxContext) {\n    let box = Box { id: object::new(ctx), thing };\n    transfer::transfer(box, tx_context::sender(ctx));\n}\n```\nNote that the wrap function takes a value, not a reference! We covered passing objects by value in the previous course and how this removes the object from storage.\n"
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    struct GiftWeekConfig has key {\n        id: UID,\n        limit: u64,\n    }\n\n    entry fun create_week(limit: u64, ctx: &mut TxContext) {\n        let gift_week_config = GiftWeekConfig {\n            id: object::new(ctx),\n            limit,\n        };\n        transfer::freeze_object(gift_week_config);\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "5",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
      "title": "Immutable objects - Gift Season Info",
      "quizTitle": "Imagine users can create gift boxes with their `SuiFrens` and give away to their friends during specific weeks of the holiday season. However, we want to limit the number of gifts that can be created in each week (can be different from week to week). In order to do this, we'll:\n1. Create a new object struct `GiftWeekConfig` that has the id field and another field - limit of type `u64`.\n2. Create a new entry function `create_week` that takes a limit argument and creates and freezes a `GiftWeekConfig` object.  ",
      "content": "We have created two objects so far: `SuiFren` and `GiftBox`. Both of these are owned objects. They're owned by users and only the owners can include them in a transaction. We also briefly discussed shared objects - those that can be include in any transactions. Let's talk about a third type of object in this lesson - immutable objects.\n\nImmutable objects are almost the same as shared objects. Any user can include them as part of their transactions. However, shared objects can be included as mutable references and thus modifiable by anyone. Immutable objects can never change after they're \"frozen\".\n```\nstruct ColorObject has key {\n    id: UID,\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\npublic entry fun freeze_owned_object(object: ColorObject) {\n    transfer::freeze_object(object)\n}\n\npublic entry fun create_immutable(red: u8, green: u8, blue: u8, ctx: &mut TxContext) {\n    let color_object = ColorObject {\n        id: object::new(ctx),\n        red,\n        green,\n        blue,\n     };\n    transfer::freeze_object(color_object);\n}\n```\n\nIn the example above, `create_immutable` creates an object and immediately freezes it, making it immutable. `freeze_owned_object`, on the other hand, takes an existing owned object and makes it immutable. Note that `transfer::freeze_object` would error out if called on shared objects. `freeze_owned_object` demonstrates another key difference between immutable objects and shared objects - owned objects cannot become shared (`transfer::share_object` needs to be call immediately after an object is created in the same transaction), but owned object can be made immutable anytime as long as the owner wants to.\n\nImmutable objects can be included via immutable reference (&) anytime:\n```\npublic fun read_immutable(color: &ColorObject): (u8, u8, u8) {\n    (color.red, color.green, color.blue)\n}\n```\nread_immutable can be called on any immutable (frozen) color objects and ownership is not required.\n"
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(gift_box: GiftBox, ctx: &TxContext) {\n        let GiftBox {id, inner} = gift_box;\n        object::delete(id);\n        transfer::public_transfer(inner, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "6",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(gift_box: GiftBox) {\n        \n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n\n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
      "title": "Transfer Policy - Public and private transfers of objects",
      "quizTitle": "Update the `open_box` function in the `fren_summer` module to destruct the `GiftBox` object, take the inner `SuiFren` and then transfer that to the sender. Don't forget to update abilities.",
      "content": "We have already seen both owned objects in action:\n```\nstruct OwnedObject has key {\n    id: UID,\n}\n\npublic fun create_owned_object(tx_context: &mut TxContext) {\n  let owned_object = OwnedObject {\n      id: object::new(ctx),\n  };\n  transfer::transfer(owned_object, tx_context::sender(ctx));\n}\n```\nWe have also learnt about struct abilities - key, store, copy, drop. There's a special hidden feature that you can get by combining the store ability and the functionalities offer by the transfer module - Transfer Policy.\n\nWith Transfer Policy, developers can dictate if the objects they define can be transferred outside of their module code:\n1. Objects that have the store ability can be transferred outside of the same module it's defined in with `transfer::public_transfer`.\n```\nmodule 0x123::my_module {\n    struct OwnedObject has key, store {\n        id: UID,\n    }\n}\n\nmodule 0x123::your_module {\n    use 0x123::my_module::OwnedObject;\n    \n    public fun transfer(object: OwnedObject, receiver: address) {\n        transfer::public_transfer(object, receiver);\n    }\n}\n```\n2. Objects without the store ability can <b>only<b> be transferred with `transfer::transfer` inside the same module it's defined in. In the example above, if we remove the store ability from OwnedObject, the transfer function in `your_module` would stop working. OwnedObject can now only be transferred directly inside `my_module`:\n```\nmodule 0x123::my_module {\n    struct OwnedObject has key {\n        id: UID,\n    }\n    \n    public fun transfer(object: OwnedObject, receiver: address) {\n        transfer::transfer(object, receiver);\n    }\n}\n```\n\n"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Yes",
          "isCorrect": true
        },
        {
          "answer": "B. No",
          "isCorrect": false
        }
      ],
      "lessonId": "7",
      "codeDef": "",
      "title": "Transfer Policy - share vs public_share, freeze vs public_freeze",
      "quizTitle": "Imagine you're working on a movie theatre smart contract that can issue Ticket objects for different shows. Should this Ticket object have the store ability?",
      "content": "Similar to `transfer::transfer` and `transfer::public_transfer` functions, the transfer module also offers:\n1. `share` and `public_share`\n2. `freeze` and `public_freeze`\n\nThese functions work similarly to `transfer` vs `public_transfer` - the public versions can only be used if the object passed to them has the store ability. This gives developers additional flexibility to control how their objects can be used.\n\nWith `share` and `public_share`, the developers can allow their objects to only be owned or also sharable. For example:\n1. A developer creates a `PunchCard` object where users can get a hole clipped every time they buy a boba tea. The developer wants the `PunchCard` to be sharable between users so different users can use the same `PunchCard`. They can just add the store ability to `PunchCard`.\n2. Another developer creates a `GymMembership` object for their gym but doesn't want their membership to be shared by more than one users. They just need to not give `GymMembership` the store ability.\n\nWith `freeze` and `public_freeze`, developers can similarly decide if they want the owners to be able to make their objects immutable:\n1. The `PunchCard` object from earlier can potentially be made immutable if the users want to give up on it.\n2. The `GymMembership` object cannot be made immutable as once the membership expires, it should be deleted."
    },
    {
      "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Candy};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n        candies: vector<Candy>,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Candy has store {\n        value: u64,\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "8",
      "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Candy};\n    use sui::tx_context;\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n}",
      "title": "Wrapping Objects vs Non-object structs",
      "quizTitle": "Create a new struct `Candy` in the `sui_fren` module that has a single field value of type `u64` and add a new field candies to `GiftBox` of type vector of `Candies`. For now `Candy` is a non-object struct and we'll feed the candies to `Fren` to up-level them in later sessions.",
      "content": "In a previous lesson, we learnt about Object Wrapping and how we can wrap a `SuiFren` object into a `GiftBox`:\n```\nstruct GiftBox has key {\n    id: UID,\n    inner: SuiFren,\n}\n\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n```\nThere's an alternative to object wrapping that has a similar syntax - using a non-object struct that only has the store ability:\n```\nstruct SuiFren has store {\n    generation: u64,\n    birthdate: u64,\n    attributes: vector<String>,\n}\n```\nThis approach is usually useful only if the developer doesn't plan to turn the nested struct type into an object. This can help break a long object struct into smaller related components, for example:\n```\nstruct LongObject has key {\n    id: UID,\n    field_1: u64,\n    field_2: u64,\n    field_3: u64,\n    field_4: u64,\n    field_5: u64,\n    field_6: u64,\n    field_7: u64,\n    field_8: u64,\n}\n```\nvs\n```\nstruct BigObject has key {\n    id: UID,\n    field_group_1: FieldGroup1,\n    field_group_2: FieldGroup2,\n    field_group_3: FieldGroup3,\n}\n\nstruct FieldGroup1 has store {\n    field_1: u64,\n    field_2: u64,\n    field_3: u64,\n}\n\nstruct FieldGroup2 has store {\n    field_4: u64,\n    field_5: u64,\n    field_6: u64,\n}\n\nstruct FieldGroup3 has store {\n    field_7: u64,\n    field_8: u64,\n\n}\n```\n\n"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Owned object",
          "isCorrect": false
        },
        {
          "answer": "B. Shared object",
          "isCorrect": false
        },
        {
          "answer": "C. Immutable object ",
          "isCorrect": true
        }
      ],
      "lessonId": "9",
      "codeDef": "",
      "title": "Shared objects - parallel execution and consensus",
      "quizTitle": "If we have a `SuiFrenConfig` object that's initialized in the init function but never changed. What kind of object should it be?",
      "content": "Another hidden knowledge that's good to know as developer on Sui: In general, it's better to design your smart contracts to use Owned objects as much as possible. Shared objects should generally only be used for shared state across many users, and immutable objects are preferred over shared objects if that state doesn't need to change.\n\nShared objects go through a separate execution path on the Sui network as it requires full consensus. If any users can change a shared object, there can be conflicts that lead to different final results depending on the ordering. Therefore, the Sui network needs to use a full Consensus process and make sure all Sui validators agree on the ordering and the final results before they are committed to storage. Because of this, shared objects would take longer to execute and impose a higher cost on the Sui network than owned or immutable objects. You can think of this as the Sui network works the best if as many objects can be owned or immutable or possible.\n\nThe general rules of thumb are:\n1. Immutable objects for all shared state of a contract if the data never changes.\n2. Shared objects for shared state that can be updated.\n3. Owned objects for everything else. "
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    use sui::package;\n    use sui::types;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "10",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the witness struct here\n\n    // Add the init function here\n}",
      "title": "System Objects: One-time Witness Object and Publisher Object",
      "quizTitle": "Add a witness struct to the `sui_fren` module and an init function that:\n1. Takes the witness object as argument and creates a publisher object\n2. Transfers the publisher struct to the sender (same as the deploying account). Note that you would need to use the right transfer function (which one between `transfer` and `public_transfer`?)",
      "content": "We have seen the `TxContext` object, which can be passed as mutable or immutable reference. Let's discuss other special objects.\n\nWhen deploying a module, any init function would be called automatically. The init function can also be given a witness object - a special system object that is only created once the first time the module is deployed:\n```\nmodule 0x123::my_module {\n    struct MY_MODULE has drop {}\n    \n    fun init(witness: MY_MODULE) {\n        // Do something with the witness object.\n    }\n}\n```\nIn order to receive the witness object in the init function, you need to declare a struct with the same name as the module but in all uppercase (any _ is kept). This struct must have the drop ability. Now, when you define the init function you can add the witness object of that type as the first argument.\n\nWitness objects currently only have two main cases but more can be added by the Sui team in the near future:\n1. Claim the `Publisher Object`. `Publisher Object` is a proof that the keeper has deployed the object.\n```\nfun init(witness: MY_MODULE, ctx: &mut TxContext) {\n    assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n    let publisher_object = package::claim(witness, ctx);\n    // Use or store the publisher object...\n}\n```\n2. Proof when calling other modules' functions that this is in the middle of the initialization flow. This is usually useful when there's a set of actions that have to be done with multiple different modules as part of initializing the project.\n```\nmodule 0x123::module_b {\n    fun init(module_a_witness: MODULE_A, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&module_a_witness), ENotOneTimeWitness);\n        // We know that this is being called from module A's init function.\n    }\n}\n```\nPublisher objects also only have 2 use cases currently but more can be added soon:\n1. Create Display Objects. More on these in the next lesson\n2. Set transfer policy in Sui's Kiosk (NFT standard). This will be covered in the NFT course."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n\n    public fun create_display_object(publisher: &Publisher, ctx: &mut TxContext) {\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display_object,\n            vector[\n                utf8(b\"id\"),\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n                utf8(b\"attributes\"),\n            ],\n            vector[\n                utf8(b\"id: {id}\"),\n                utf8(b\"generation: {generation}\"),\n                utf8(b\"birthdate: {birthdate}\"),\n                utf8(b\"all attributes: {attributes}\"),\n            ],\n        );\n        display::update_version(&mut display_object);\n        transfer::public_transfer(display_object, tx_context::sender(ctx));\n    }\n}",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "11",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}",
      "title": "System Objects: Display Objects",
      "quizTitle": "Add a new public function add_display that creates a display object for a SuiFren with the following formatting rules:\n1. `id` will be formatted as `id: {id}`\n2. `generation` will be formatted as `generation: {generation}`\n3. `birthdate: {birthdate}`\n4. `all attributes: {attributes}`\nThe display object should be sent to the sender.",
      "content": "Display `Objects (Display<T>)` are objects that indicate how fields can be displayed for an object of a specific type.\n```\nstruct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n```\nIf an account holds both MyObject and Display<MyObject>, a web UI can look at the fields in Display<MyObject> to know how to format and display the fields of MyObject.\n```\nmodule 0x123::my_module {\n    struct MyObject has key {\n        id: UID,\n        num_value: u64,\n        string_value: String,\n    }\n    \n    public fun create_display_object(publisher: &Publisher, ctx: &mut TxContext) {\n        let display_object = display::new<MyObject>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"num_value\"),\n                utf8(b\"string_value\"),\n            ],\n            vector[\n                utf8(b\"Value: {num_value}\"),\n                utf8(b\"Description: {string_value}\"),\n            ],\n        );\n        display::update_version(&mut display);\n    }\n}\n```\nIn order to create the display object, we need a reference to the publisher object for the module where `MyObject` is deployed at. Assuming we have created this object (see previous lesson) and store it in an account we control, we can use this account to call `create_display_object`. After the display object is created, we can add formatting rules by calling `display::add_multiple` with two vectors, one for the list of fields from `MyObject` to display and one for the formatting rules.\n\nAfter the formatting rules have been set, we can call `display::update_version` to finalize the updates to the display object. Once the display object is created, an event is emitted that allows the Sui network nodes to detect the Display object. Subsequently, whenever an object is fetched via the node API, its display attributes are also computed in the exact formatting specified and returned along with the rest of the object's fields.\n"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Because timestamp could be manipulated by validators",
          "isCorrect": true
        },
        {
          "answer": "B. Because timestamp could be non deterministic",
          "isCorrect": false
        },
        {
          "answer": "C. Because timestamp can be manipulated by users",
          "isCorrect": false
        }
      ],
      "lessonId": "12",
      "codeDef": "",
      "title": "System Objects - Clock",
      "quizTitle": "Why is timestamp potentially dangerous to use to generate random results?",
      "content": "The last system object we'll look into is the `Clock` object. This allows user to obtain the current time as recorded on the Sui blockchain:\n```\nuse sui::clock;\n\npublic entry fun get_time(clock: &Clock) {\n    let timestamp_ms = clock::timestamp_ms(clock);\n}\n```\nNote that the returned timestamp is in million seconds (1 second = 1000 ms).\n\nTimestamp can used in two common ways:\n1. Get the timestamp for record keeping or emitting events\n```\nstruct TimeEvent has copy, drop {\n    timestamp_ms: u64,\n}\n    \npublic entry fun get_time(clock: &Clock) {\n    event::emit(TimeEvent { timestamp_ms: clock::timestamp_ms(clock) });\n}\n```\n2. Generate a pseudo-random number. This is technically susceptible to validator manipulation as validators can set the timestamp within a very small margin of error.\n```\nentry fun flip_coin(clock: &Clock): u64 {\n    let timestamp_ms = clock::timestamp_ms(clock);\n    // 0 is heads, 1 is tails\n    timestamp % 2\n}\n```\n"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. The previous function that's calling the current function",
          "isCorrect": false
        },
        {
          "answer": "B. The sender of the transaction",
          "isCorrect": true
        },
        {
          "answer": "C. The sender of SUI tokens",
          "isCorrect": false
        }
      ],
      "lessonId": "13",
      "codeDef": "",
      "title": "System Object: TxContext and avoid security vulnerabilities",
      "quizTitle": "What does `tx_context::sender` return?",
      "content": "Another very commonly used System object is TxContext. We have seen this in action for two main use cases:\n1. Create a new object's id with `object::new`\n2. Get the sender with `tx_context::sender`\n```\nstruct MyObject has key {\n    id: UID,\n    value_1: u64,\n    value_2: u64,\n}\n\npublic fun create_object(value_1: u64, value_2: u64, ctx: &mut TxContext) {\n    let object = MyObject {\n        id: object::new(ctx),\n        value_1,\n        value_2,\n    };\n    transfer::transfer(object, tx_context::sender(ctx));\n}\n```\nDevelopers should pay close attention to how they use the sender address returned from `tx_context::sender`. It's okay to send newly created to this objects, but it can be problematic to use as authentication or proof of user's direct intention to call this function. For example:\n```\nmodule 0x123::safe_module {\n    public fun claim_rewards(amount: u64, receiver: address, ctx: &mut TxContext) {\n        let sender = tx_context::sender(ctx);\n        assert!(sender == @0x12345, ENOT_AUTHORIZED);\n        // Send the amount of rewards to the receiver address\n    }\n}\n```\nIn the example above, we want to write a special function `claim_rewards` that allows a specific address to call and withdraw an amount of reward money. This looks safe on the surface but can be exploited! A malicious developer can just write a module that promises an airdrop to the users and in the code do the following:\n```\nmodule 0x123::malicious_module {\n    const MALICIOUS_DEVELOPER: address = @0x98765;\n\n    public fun airdrop(ctx: &mut TxContext) {\n        safe_module::claim_rewards(1000, MALICIOUS_DEVELOPER, ctx);\n    }\n}\n```\nThis would instantly drain the user's rewards! safe_module cannot easily distinguish if the ctx object is being passed by the VM (first function call) or by another function from another object. One solution here could be to make claim_rewards an entry function so it has to be directly called by the user. However, this might not be desirable in some cases if we want to sometimes allow our own code (from a different module in the same package) to call this function. \n\nIn general, using `tx_context::sender` as an authentication mechanism is risky and should be very thoroughly evaluated if there can be any possible exploits.\n\nOther functions that the `tx_context` module offers includes digest which returns the transaction hash, epoch and `epoch_timestamp_ms` which return the current epoch number and corresponding timestamp, and `fresh_object_address` which uses the same underlying function as `object::new` to generate a new object's address."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Anyone",
          "isCorrect": false
        },
        {
          "answer": "B. Owner of object 1",
          "isCorrect": false
        },
        {
          "answer": "C. Owner of object 2",
          "isCorrect": true
        }
      ],
      "lessonId": "14",
      "codeDef": "",
      "title": "Struct data access and user ownership rules",
      "quizTitle": "In the following example:\n```\nstruct MyData has key {\n    id: UID,\n    value: u64,\n}\n\npublic fun set_value(object_1: &MyData, object_2: &MyData, value: u64) {\n    object_2.value = value;\n}\n```\nIf `object_1` is a shared object and `object_2` is a owned object, who can send this transaction?",
      "content": "# Struct data access rules\nWe have seen various different type of structs, including object structs (those with the key ability) and non-object structs (those without the key ability). In order to access a field of a struct instance, object or non-object, we just need to use the dot annotation and call `struct_instance.field`. The `struct_instance` can be a mutable or immutable reference, or a value. However, this doesn't work outside of the module where the struct is defined:\n```\nmodule 0x123::a {\n    struct MyData has key {\n        id: UID,\n        value: u64,\n    }\n    \n    // This works\n    public fun get_value_from_reference(object: &MyData): u64 {\n        object.value\n    }\n    \n    // This works\n    public fun get_value_from_mut_reference(object: &mut MyData): u64 {\n        object.value\n    }\n}\n\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This doesn't work\n    public fun get_value(object: &MyData): u64 {\n        object.value\n    }\n}\n```\nIn the example above, `b::get_value` will fail to compile as it tries to access the value field of `MyData` but `MyData` is defined inside module a, and not in module b. In Move, only the modules that define a struct can freely access its fields. If other modules need to access a field, it'd need to do so through the original module's getter function:\n```\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This now works\n    public fun get_value(object: &MyData): u64 {\n        a::get_value_from_reference(object)\n    }\n}\n```\nIn general, this is call the module-scoped rule for struct data access. This allows developers to define rules for how their data (structs) can be read or written. They can keep the data private and not allow any external modules to access inner fields, or they can implement public getters (return an inner field's values) and setters (set an inner field's value) that can be called by external modules. They can also implement custom authentication module that requires a specific permission object to be able to update the struct's values.\n\n# User ownership\nIn the first course, we have covered Owned objects and how they can only be accessed and modified by transactions sent by the owner. This is automatically verified by the Sui blockchain when the transactions are executed and guarantees that an account's owned objects cannot be read/modified without their permission. \n\nThrough enforcement of this ownership, users can be reassured that no modules can read or modify their owned objects without them explicitly signing transactions that authorize the modules to do so. "
    },
    {
      "codeSol": "",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "15",
      "codeDef": "",
      "title": "Summary",
      "quizTitle": "",
      "content": "This module furthers your understandings of basic Sui Move. \n\n**Functions** We are learning two more types of functions:\n1. Public (friend) functions: similar to package-visible functions in other languages and can only be called by modules in the same package. This allows developers to limit dangerous functions to only be called by their own modules and not by others.\n2. Private (entry) function: can only be called directly from a transaction, but not from other Move code.\n\n**Programmable Transaction Block (PTB)** allows users to specify a series of actions (transactions) to be sent to the network as a single transaction. The actions are executed sequentially and are atomic - if any of them fails, the entire PTB fails and all changes are automatically reverted\n\n**Struct** \nBeside key ability, structs also offer 3 more abilities: \n1. Store ability allows a struct to be part of other structs. \n2. Copy ability allows a struct to be \"copied\", which creates an instance of the struct with the same exact field values.\n3. Drop ability allows a struct to be implicitly destroyed at the end of a function without having to \"destruct\".\n\nStruct data access. This allows developers to define rules for how their data (structs) can be read or written. They can keep the data private and not allow any external modules to access inner fields, or they can implement public getters (return an inner field's values) and setters (set an inner field's value) that can be called by external modules. They can also implement custom authentication module that requires a specific permission object to be able to update the struct's values.\n\n**Object**\n1. Object Wrapping: a method for encapsulating objects within other objects, a key technique for creating layered data structures and managing ownership and access in a more granular manner.\n2. Immutable Object: is the third type of objects beside shared objects and owned objects. Immutable object can be included  as part of users' transactions but can NEVER be changed after they're \"frozen\".\n3. System Object: Witness Object, Publisher Object, Display Object, Clock\n4. Transferability: \n- Objects that have the store ability can be transferred outside of the same module. Objects without the store ability can ONLY be transferred with transfer::transfer inside the same module it's defined in.\n- Share and public_share objects: the developers can allow their objects to only be owned or also sharable.\n- Freeze and public_freeze, developers can similarly decide if they want the owners to be able to make their objects immutable\nGolden rules for choosing types of objects to use:\n* Immutable objects for all shared state of a contract if the data never changes.\n* Shared objects for shared state that can be updated.\n* Owned objects for everything else."
    }
  ]
}

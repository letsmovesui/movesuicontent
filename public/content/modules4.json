{
  "curStatus": "ready",
  "description": "",
  "id": "4",
  "lesson": [
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Each token is unique while each NFT is not",
          "isCorrect": false
        },
        {
          "answer": "B. Each NFT is unique while each token is not",
          "isCorrect": true
        },
        {
          "answer": "C. NFTs cannot be objects",
          "isCorrect": false
        }
      ],
      "lessonId": "1",
      "codeDef": "",
      "title": "Intro to NFT",
      "quizTitle": "What is the difference between NFTs and Tokens (Coins on Sui)?",
      "content": "In recent years, a groundbreaking technology has taken the art, entertainment, and digital collectibles world by storm - Non-Fungible Tokens, or NFTs. These digital assets have revolutionized the way we think about ownership and authenticity in the digital age.\n\nNFTs are unique digital tokens that are built on blockchain technology, which is the same underlying technology behind cryptocurrencies like Bitcoin and Ethereum. What sets NFTs apart is their individuality; each token represents a one-of-a-kind item, whether it's a piece of digital art, music, video clips, virtual real estate, in-game items, or even tweets and memes. This uniqueness is achieved through cryptographic signatures that verify the token's authenticity and ownership, making it tamper-proof and verifiable on a public ledger.\n\nNFTs have opened up exciting opportunities for artists, creators, and collectors, enabling them to monetize and trade digital creations like never before. They have also sparked discussions about the intersection of technology, ownership, and the future of digital culture. As NFTs continue to evolve and expand into various industries, they are reshaping the way we perceive and interact with digital assets, offering a glimpse into the potential of blockchain technology beyond cryptocurrencies.\n\nNFTs (Non-Fungible Tokens) are represented on the blockchain through a combination of smart contracts and unique identifiers. Here's how it works:\n\n1. Smart Contracts: NFTs are created and managed using smart contracts, which are self-executing agreements with predefined rules and conditions. Smart contracts on blockchain platforms like Ethereum, Binance Smart Chain, and others are responsible for the creation, transfer, and ownership of NFTs. These contracts contain the logic that governs the behavior of NFTs, such as how they can be created, bought, sold, and transferred.\n2. Unique Identifiers: Each NFT has a unique identifier that distinguishes it from all other tokens on the blockchain. This identifier is typically a long string of characters that is associated with the specific NFT. It is often referred to as the \"token ID\" or \"token index.\" This identifier ensures the uniqueness of the NFT and allows it to be easily tracked on the blockchain.\n3. Metadata: NFTs often include metadata, which is additional information about the digital asset linked to the token. Metadata can include details about the creator, a description of the asset, its properties, and a link to the actual digital file (e.g., an image, video, or audio file). Metadata is typically stored off-chain (outside the blockchain) due to size limitations, and a reference to this metadata is included within the NFT's smart contract. This allows users to access and display information about the NFT without storing the entire content on the blockchain.\n4. Ownership and Transfer: The ownership of an NFT is tracked on the blockchain. When an NFT is created, the smart contract records the initial owner's wallet address. When the NFT is transferred to another party, the ownership information in the smart contract is updated to reflect the new owner's wallet address. This transfer process is secure and transparent, as it is recorded on the public ledger of the blockchain.\n5. Interoperability: NFTs are often created and traded on various blockchain platforms, each with its own set of standards (e.g., ERC-721 and ERC-1155 on Ethereum, BEP-721 on Binance Smart Chain). To ensure interoperability between different platforms, certain standards and protocols have emerged, allowing NFTs to be recognized and used across multiple ecosystems. For example, the Ethereum-based NFTs can be supported on various NFT marketplaces and platforms that adhere to the same standards.\n\nOn the Sui blockchain, NFTs are easy to create and manage with objects. Each NFT can be an object, which is already unique and can contain any metadata defined by the creators/developers. We'll talk more about how to implement NFTs on Sui in details in the next lessons."
    },
    {
      "codeSol": "module sui::sui_fren {\n    use std::string::String;\n    use sui::object::UID;\n    use sui::url::Url;\n\n    struct SuiFrenCollection has key {\n        id: UID,\n        creator: address,\n        name: String,\n        description: String,\n        limit: u64,\n        url: Url,\n    }\n\n    struct SuiFren has key {\n        id: UID,\n        collection: address,\n        name: String,\n        url: Url,\n        attributes: vector<String>,\n    }\n}",
      "quizType": "CODING",
      "answers": [
        {
          "answer": "Each token is unique while each NFT is not",
          "isCorrect": false
        },
        {
          "answer": "Each NFT is unique while each token is not",
          "isCorrect": false
        },
        {
          "answer": "NFTs cannot be objects",
          "isCorrect": false
        }
      ],
      "lessonId": "2",
      "codeDef": "module sui::sui_fren {\n    // Add the structs here\n}",
      "title": "NFT Standard - Collection and Token Objects",
      "quizTitle": "Let's start easy with this lesson and attempt to create our own simple NFT standard for SuiFrens. Define two separate object structs, one for SuiFrenCollection, and one for SuiFren (as an NFT) with the following fields:\nSuiFrenCollection:\n1. creator of type address\n2. name of type String\n3. description of type String\n4. limit of type u64\n5. url of type sui::url::Url\n\nSuiFren NFT:\n1. collection of type address\n2. name of type String\n3. url of type sui::url::Url\n4. attributes of type vector<String>\n\nHint: Don't forget imports!",
      "content": "To understand how to implement NFTs, let's define the core components of NFTs - creators, collections, tokens (NFTs):\n\n# Creators\nCreators are the individuals or entities responsible for producing and minting NFTs. They can be artists, musicians, game developers, content creators, or anyone who generates unique digital content that can be tokenized into NFTs.\n\nCreators use blockchain platforms and smart contracts to mint NFTs, defining the properties, ownership, and rules associated with each token. They can also specify attributes and metadata for their NFTs to provide additional information and context to buyers and collectors.\n\n# NFT collections\nare groups or sets of non-fungible tokens (NFTs) that share a common theme, style, or creator. They are curated collections of unique digital assets, often organized around a specific genre, artist, project, or category.\n\nFor example, a collection might be centered around digital art, featuring NFTs created by various artists. Another collection could revolve around virtual real estate, offering unique parcels of virtual land in a virtual world. Each NFT within a collection is distinct, but they are grouped together based on a common theme or affiliation.\n\n# NFT tokens\nNFT tokens are grouped into collections. Once a creator creates a collection, they can allow users to mint NFT tokens in the same collection, each one having unique identifier and attributes. Whether there's a limit to how many NFT tokens can be minted for a single collection can be defined by the creator via how they implement the smart contracts.\n\n# Implementation\nIn Sui Move, we can represent both NFT Collection and Token as objects. A Collection object can have the following fields:\n1. creator: The address of the collection's creator\n2. name: Collection's name such as \"SuiFrens\"\n3. description: Description of the collection\n4. limit: The number of tokens that can minted in the collection\n5. url: Collection's url\n\nAn NFT token usually has the following fields:\n1. collection: The address of the collection object\n2. name: Token's name e.g. \"SuiFren #1234\"\n3. url: Url of the token's image\n4. attributes: A list of attributes for the token such as birthdate, generation, etc. like we've seen in the previous course.\n\nNFT tokens can also have other attributes such as display info, royalty, etc. that we'll discuss more in later lessons. \n\n"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "They would override each other's NFT data",
          "isCorrect": false
        },
        {
          "answer": "Web UIs, wallets and marketplaces would not be able to support so many different standards",
          "isCorrect": true
        },
        {
          "answer": "Creating a new NFT standard is not allowed by the Sui network",
          "isCorrect": false
        }
      ],
      "lessonId": "3",
      "codeDef": "",
      "title": "Community NFT Standards",
      "quizTitle": "Why is it bad if every developer/creator creates their own NFT standard and functionalities?",
      "content": "Although our simple standard from earlier should work for creating our own SuiFren collections and NFTs, there are two problems with it:\n1. It's not a standard used by other developers/creators. Without an agreed upon standard such as how an NFT's attributes are defined, it'd be hard for wallets (used by users to sign and send transactions to the Sui network) and UIs to know how to display the data correctly.\n2. Developers can't reimplement all the functionalities  every time they create their own NFT collections.\n\nBecause of the above reasons, it makes sense for the community to have a common standard and functionality set for NFTs to make it easier for creators to create collections and have them displayed well by both UIs and wallets without having to do a lot of manual work.\n\nMost of the NFT collections on the Sui network currently use two main standards:\n1. OriginByte: https://github.com/Origin-Byte/nft-protocol. This has the most marketshare of the NFT standards on Sui\n2. Suiet: https://std.suiet.app/\n\nFor the remainder of this course, we'll dive into the OriginByte standard as they have the most functionalities while still allowing very flexible NFT design for game builders and artists. In their own words:\n\n```\nOrigin-Byte is an ecosystem of tools, standards, and smart contracts designed to make life easier for Web3 Game Developers and NFT creators. From simple artwork to complex gaming assets, we want to help you reach the public, and provide on-chain market infrastructure.\n\nThe ecosystem is partitioned into three critical components:\n\nThe NFT standard, encompassing the core Nft, Collection, and Safe types, controlling the lifecycle and properties of each NFT.\nPrimary markets, encompassing Marketplace, Listing, and numerous markets which control the initial minting and sale of NFTs.\nSecondary markets, encompassing principally the Orderbook which allows you to trade existing NFTs.\n```\n\nThese library contracts are all deployed in all Sui networks (testnet, mainnet). The address can be seen in their [Move.toml](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol). In order to develop with these standard, developers just need to copy the [nft_protocol](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol) and [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) directories over into their source code, and directly use the modules/functions/struct types provided there. In the next few lessons, we'll give a thorough introduction to all of the functionalities they offer.\n\nCommunity builders are always encouraged to improve and suggest adding functionalities to the existing standards such as OriginByte. Through exploring one specific standard, we hope to show you the \"basic\" set of all functionalities commonly used to construct rich and powerful NFTs in art collections, games and many other types of applications. Even if there are new standards adopted by the community in the feature, most of the concepts and functionalities should still apply and developers should be able to more easily switch to those new standards."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "4",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    // Add new imports here\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    // Add new structs here\n\n    // Update\n    fun init() {\n\n    }\n}\n",
      "title": "Creating a Collection and Display attributes",
      "quizTitle": "Update the sui_fren module to create an NFT collection for SuiFrens using the OriginByte standard. Make sure you don't forget any imports. Also remember the main one time witness type has to be named in a specific way (check out the first course if you forgot).\nThe SuiFren collection should have the following display attributes:\n1. name: \"SuiFrens\"\n2. description: \"A collection of SuiFrens who hangout together\"\n\nFor now we'll not share the MintCap object.",
      "content": "Using the OriginByte standard, developers can easily create a collection. The first step is to include the  [nft_protocol](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol) and [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) packages from OriginByte as mentioned in the previous lesson. Afterward, a collection can be created using the collection module:\n```\nmodule my_nft::kite {\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use std::string::String;\n    use sui::url::Url;\n    \n    /// One time witness is only instantiated in the init method\n    struct KITE has drop {}\n    \n    struct KiteNFT has key, store {\n        id: UID,\n        name: String,\n        description: String,\n        url: Url,\n        attributes: Attributes,\n    }\n    \n    fun init(otw: KITE, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n```\nA Collection can only be created as part of the init function as it requires a witness object (discussed in the first course). collection::create_with_mint_cap needs to be called with two type arguments:\n1. The witness object type. In the example above, that's KITE.\n2. The type of the NFT in the Collection. We created a KiteNFT type for this. Will discuss the fields in more details in the next lessons.\n\ncollection::create_with_mint_cap returns two objects - the collection object of type Collection<Kite> and the mint_cap which can be used to programmatically require it for minting tokens (to be discussed later). Both of these are made shared objects because they cannot be modified anyway and can only be read. We'll talk more about whether MintCap can be an owned object later.\n\nAfter the collection has been created, attributes such as name/description can be added:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n}\n```\nIn order to set the name/description for the collection, we need a few things:\n1. Import the ob_permissions::witness from the [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) package provided by OriginByte.\n2. A new struct Witness {} declared in the same package\n3. Create a \"delegated witness\" object with witness::from_witness\n4. Call collection::add_domain with the right DisplayInfo object with the name and description. More attributes can be added as a separate domain."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n\n    public fun mint_nft(\n        mint_cap: &MintCap<SuIFren>,\n        generation: u64,\n        birthdate: u64,\n        ctx: &mut TxContext,\n    ) {\n        let nft = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes: attributes::from_vec(vector[], vector[])\n        };\n        transfer::public_transfer(nft, tx_context::sender(ctx));\n        \n        mint_event::emit_mint(\n            witness::from_witness(Witness {}),\n            mint_cap::collection_id(mint_cap),\n            &nft,\n        );\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "5",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n\n    // Add the new function here\n}\n",
      "title": "Minting a Token",
      "quizTitle": "1. Update init function to share the MintCap object \n2. Add a new public function mint that takes the MintCap object, generation, birthdate, attributes and create a new SuiFren token. It should also emit the mint event",
      "content": "Now that we've created a collection. Let's talk about minting NFTs. The OriginByte standard only specifies how a Collection should be structured:\n1. Their Collection object is very minimal and all attributes need to be added as display attributes (via collection::add_domain):\n```\nstruct Collection<phantom T> has key, store {\n    id: UID,\n    version: u64,\n}\n```\n2. OriginByte also has common functionalities for Collection such as creators, royalty, etc.\n3. Developers need to define their own NFT struct as we've seen in the previous lesson. OriginByte only offers common functionalities to manage that token: Permissions (MintCap), attributes standard, display standard, etc.\n4. Mint and burn events that tie the NFTs back to the collection.\n\nDevelopers/creators first need to define the NFT object struct, which is needed to create the collection as discussed in the previous lesson:\n```\nmodule my_nft::kite {\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use std::string::String;\n    use sui::url::Url;\n    \n    /// One time witness is only instantiated in the init method\n    struct KITE has drop {}\n    \n    struct KiteNFT has key, store {\n        id: UID,\n        name: String,\n        description: String,\n        url: Url,\n        attributes: Attributes,\n    }\n    \n    fun init(otw: KITE, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    }\n}\n```\nOnce they have a collection, they can mint the NFTs like below:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        name,\n        description,\n        url: url::new_unsafe(url),\n        attributes: attributes::from_vec(vector[], vector[])\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nYou might realize that this doesn't look any different from creating an object! This is correct, there's only one small difference - attributes is a standard provided by OriginByte to store all the token attributes. We'll discuss this more in a later lesson. Developers can also add more logic here that restrict one token mint per user for example and whatever other rules they like.\n\nThe mint function also takes a MintCap object in order to emit a mint event. This is required so that off-chain components can know the KiteNFTs belong in the Kite collection. The mint_event::emit_mint provided by OriginByte also requires the delegated witness object passed when adding display attributes to the collection in the init function. In most cases, MintCap can be a shared object to allow any user to call the mint_nft function.\n\n```\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    transfer::public_share_object(mint_cap);\n}\n```\n\nIf this is not the case and developers want to restrict who can mint, they can make MintCap an owned object and, in the init function, transfer it to the account that can mint. This makes mint_nft a permissioned function that can only called by a specific account.\n\nAnother way off-chain components can recognize NFTs from a collection is to look at their type. The collection object has a type argument so in the example above its type would be Collection<Kite>"
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Fields are explicit and thus easier to see while attributes are dynamic and harder to know the full list",
          "isCorrect": true
        },
        {
          "answer": "B. NFT structs are extensible and attributes are not",
          "isCorrect": false
        },
        {
          "answer": "C. NFT struct fields are dynamic and can be renamed or change type of needed",
          "isCorrect": false
        }
      ],
      "lessonId": "6",
      "codeDef": "",
      "title": "NFT Attributes",
      "quizTitle": "Why is using explicit fields in the NFT struct sometimes better than attributes?",
      "content": "As shown in the previous lesson, the best way to add attributes to a token is when it's just minted. The mint_nft function can either take a list of attributes from users or add its own attributes as it sees fit:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nDevelopers have an interesting tradeoff here when deciding how to add attributes to an NFT:\n1. Add directly as fields in the NFT struct (e.g. name, description)\n2. Add via attributes\n\nThe main benefit of using attributes is because new attributes can be added later (post-minting) without having to add new fields to the NFT struct. After the module is deployed, an existing struct cannot be modified or have new fields added:\n\n```\nuse sui::vec_map;\n\npublic fun add_new_attributes(kite_nft: &mut KiteNFT, new_attribute_name: String, new_attribute_value: String) {\n    let new_attributes = vec_map::empty<String, String>();\n    vec_map::insert(&mut new_attributes, new_attribute_name, new_attribute_value);\n    attributes::add_new(&mut kite_nft.id, new_attributes);\n}\n```\nattributes::add_new takes a VecMap (a map of keys to values) so we need to create one before calling the function. The key and value types can be anything (primitives, structs, etc.) as long as the key type is copyable."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "7",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        // Add royalty logic here\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
      "title": "Royalty",
      "quizTitle": "Update init function to charge a 2% royalty for all SuiFrens. All royalty should be sent to the sui_fren module publisher.",
      "content": "NFT royalty is a mechanism that allows creators and artists to earn a percentage of the resale price of their digital assets whenever those assets are sold in secondary markets. It provides a way for creators to continue benefiting from the appreciation of their work even after the initial sale.\n\nHere's how royalties work in NFTs:\n\n1. Initial Sale: When an NFT is initially minted and sold by the creator (often referred to as the \"primary sale\"), the creator can specify a percentage of the sale price that they want to receive as a royalty. This percentage is typically set in the NFT's smart contract during the minting process.\n2. Secondary Sales: After the initial sale, the NFT can be resold or traded by its owner in secondary markets (e.g., NFT marketplaces). When a secondary sale occurs, the creator is automatically entitled to receive the specified percentage (the royalty) of the resale price. The platform or marketplace facilitating the sale automatically deducts this royalty and transfers it to the creator's wallet.\n3. Continuous Earnings: Royalties provide creators with a continuous stream of income as long as their NFTs are being resold. This incentivizes artists and creators to produce high-quality and desirable digital content, as they can participate in the value appreciation of their work over time.\n4. Transparency: Royalties in NFTs are transparent and verifiable on the blockchain. The smart contract associated with the NFT specifies the royalty percentage and ensures that it is automatically enforced during secondary sales. This transparency builds trust between creators and buyers, as both parties can see how royalties are distributed.\n5. Benefits for Collectors: Royalties can also be beneficial for collectors and investors, as they can have confidence that their investment in an NFT may appreciate in value over time. Knowing that a portion of future resale proceeds will go back to the original creator can enhance the perceived value of an NFT.\n\nOne note here is royalty is usually guaranteed to be enforced by standards such as OriginByte. They're commonly enforced by the marketplaces and exchanges that support listing NFTs for sale. This is because payment methods can vary (different types of coins, other NFTs, debt notes, etc.) and the amount is self-reported by the marketplaces.\n\nHowever, standards like OriginByte does offer mechanisms for creators to define policies (\"strategies\" as called by OriginByte) regarding how royalty can be computed and enforced. This offers a standardized format for royalty and makes it much easier for exchanges to charge royalty.\n\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nIn the example above, we added a royalty of 1% that is 100% paid to a single creator (the module's deployer). Note behind the scene, royalty_strategy_bps::create_domain_and_add_strategy effectively adds the royalty as an attribute (\"domain\") via collection::add_domain the same way we added other attributes. It also creates and enforces (via royalty_strategy_bps::enforce) a special transfer policy. We'll cover TransferPolicy in more details in the lesson on Kiosk later as TransferPolicy is a concept introduced by the Kiosk standard.\n\nHow exactly marketplaces enforce royalty via a combination of royalty_strategy_bps, TransferPolicy and TransferRequest is outside the scope of this lesson. Curious learners are encouraged to look at the [source code](https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/nft_protocol/sources/rules/royalty_strategy.move#L65) to understand how this really works behind the scene.\n"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    use nft_protocol::display_info;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_transfer(collection, tx_context::sender(ctx));\n        transfer::public_share_object(mint_cap);\n    }\n\n    public fun update_collection_description(collection: &mut Collection<SuiFren>, new_description: String) {\n        display_info::change_description(collection::borrow_uid_mut(Witness {}, collection), new_description);\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "8",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n\n    // Add the new function here\n}\n",
      "title": "Add, update and remove Collection's attributes",
      "quizTitle": "1. Update init function to send the Collection object to the module publisher.\n2. Add a new public function update_collection_description that allows the module publisher to update the description to a specified new_description string.",
      "content": "In an earlier lesson, we looked at how NFT collection can be created with a list of predefined attributes:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n}\n```\nThese attributes can also be modified after the collection has already been created. Permission-wise, developers have two options:\n1. Allow anyone to modify a collection's attributes, subject to specific rules (e.g. being a specific account as defined by the protocol). In this case, the Collection object needs to be a shared object.\n2. Keep the collection object as an owned object and transfer it to the account that has the permission to modify the collection's attributes later.\n\nEither way, this would give access to specify a mutable reference to the collection object when calling the functions that add/update/remove collection attributes. To add a group of attributes (domain) later, we just need the delegated witness object and call collection::add_domain again.\n```\npublic fun add_collection_attributes_group(collection: &mut Collection<KiteNFT>, attributes: vector<String>) {\n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        attributes,\n    );\n}\n```\nSince domain can be any type, it can be a single attribute or a group of - you can add a vector, VectorMap or any other containers that contain multiple attributes. Note that each type of domain can only be added once as they're added via dynamic fields behind the scene.\n\nTo modify an existing domain (can be a single attribute or a container of attributes):\n```\npublic fun update_collection_string_attribute(collection: &mut Collection<KiteNFT>, new_value: String) {\n    let string_attribute = collection::borrow_domain_mut<KiteNFT, String>(\n        delegated_witness,\n        &mut collection,\n    );\n    *string_attribute = new_value;\n}\n```\n\nTo modify the name or description that were set for the collection using DisplayInfo:\n```\npublic fun update_collection_name_and_desc(collection: &mut Collection<KiteNFT>, new_name: String, new_desc: String) {\n    display_info::change_name(collection::borrow_uid_mut(Witness {}, collection), new_name);\n    display_info::change_description(collection::borrow_uid_mut(Witness {}, collection), new_desc);\n}\n```\n\nTo delete a domain, including DisplayInfo since it's droppable:\n```\npublic fun delete_collection_display_info(collection: &mut Collection<KiteNFT>) {\n    collection::remove_domain<KiteNFT, DisplayInfo>(Witness {}, collection);\n}\n```"
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "9",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
      "title": "NFT's display attributes",
      "quizTitle": "Update init function to also create a display object for the SuiFren NFT. The display object should only print out the generation and birthdate with the following keys/formats:\ngeneration: \"SuiFren generation: {generation}\"\nbirthdate: \"Born on {birthdate}\"\n\nThe display object will be transferred to the module deployer for simplicity.",
      "content": "In previous lessons, we've seen how we can add attributes when minting an NFT:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nIn the intermediate Object course, we talked about Display object and how it can be used to instruct Web UIs and wallets to display the object to users. It can also allow adding attributes that are for display purposes only without burdening the actual object and can be used for cross-cutting changes that apply to all objects of the same type.\n\nWe can also use Display object to dictate how NFT objects are displayed as well by creating one when the collection is minted:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n    \n    let publisher = package::claim(otw, ctx);\n    let display_object = display::new<KiteNFT>(&publisher, ctx);\n    display::add_multiple(\n        &mut display,\n        vector[\n            utf8(b\"All attributes\"),\n            utf8(b\"url\"),\n        ],\n        vector[\n            utf8(b\"All attributes: {attributes}\"),\n            utf8(b\"Image url: {url}\"),\n        ],\n    );\n    display::update_version(&mut display);\n    transfer::public_transfer(display, tx_context::sender(ctx));\n}\n```\nOnce the display object is created, an event is emitted that allows the Sui network nodes to detect the Display object. Subsequently, whenever an object is fetched via the node API, its display attributes are also computed in the exact formatting specified and returned along with the rest of the object's fields.\n\nIn the example above, we also send the display object to the module deployer in case we need to update the display attributes and formatting in the future. If developers are certain the display attributes won't ever change, they can also freeze the object. If they want to have custom logic as to when the display attributes can be added/modified/removed, they can also share the object."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID, ID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    struct DeleteFrenEvent has copy, drop {\n        fren_id: ID,\n    }\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n\n    entry fun delete_fren(sui_fren: SuiFren) {\n        let SuiFren {id, generation: _, birthdate: _, attributes: _ } = sui_fren;\n        let fren_id = object::uid_to_inner(&id);\n        object::delete(id);\n        event::emit(DeleteFrenEvent { fren_id });\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "10",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    // Add the new event here\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}\n",
      "title": "Burning NFTs",
      "quizTitle": "1. Add a new event DeleteFrenEvent that just has the id (of type ID) of the SuiFren NFT that was deleted, named fren_id. Check out https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/object.move for how to create an ID from the object's UID field. \n2. Add a new entry function delete_fren that can delete a SuiFren NFT",
      "content": "Similar to normal objects, NFTs can also be burnt (destroyed). This is a common feature for games that can be used to:\n1. Implement item crafting. Users can burn a few ingredient items to craft a weapon or concoct a potion.\n2. Represent item loss. When an armor is broken, it's burnt and disappears from the user's inventory.\n\nApplications can also burn consumable NFTs such as concert or raffle tickets.\n```\nuse nft_protocol::mint_event;\n\nstruct Witness has drop {}\n\nstruct Ticket has key {\n    id: UID,\n    expiration: u64,\n}\n\npublic fun clip_ticket(\n    collection: &mut Collection<Ticket>,\n    ticket: Ticket,\n) {\n    let Ticket {id, expiration: _ } = ticket;\n    object::delete(id);\n    \n    // Update collection's supply\n}\n```\nThis will destroy the NFT - it'll be removed from object storage after the transaction is executed. Note that if the collection tracks a supply of tickets (how many tickets are currently available), the supply attribute needs to be updated. See the earlier lesson on update collection's attributes for more details how."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. To make it clear on-chain or off-chain who the creators are",
          "isCorrect": true
        },
        {
          "answer": "B. For royalty payment split",
          "isCorrect": false
        },
        {
          "answer": "C. Because it's required by the OriginByte standard",
          "isCorrect": false
        }
      ],
      "lessonId": "11",
      "codeDef": "",
      "title": "Multiple creators",
      "quizTitle": "Why should the list of creators added to the collection as an attribute?",
      "content": "We've seen from previous lessons how the creator, usually the module deployer, can hold multiple permissions:\n1. Creator can own the Collection object for adding, updating, or deleting attributes.\n2. Creator can own the Display object for NFTs in the collection to control how they can be displayed in UIs.\n3. Creator can receive the royalty payments when the NFTs are traded on marketplaces\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Single creator account receiving all royalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nFor some collections, especially in games, there can be multiple creators, either because there are multiple different people involved or just for splitting the royalty payments into multiple accounts for safety reason. OriginByte provides a simple creators module interface that allows adding multiple creators. This can be used to:\n1. Add a creators attribute to the collection to keep track of all the creator addresses.\n2. Split royalty payment with specified percentages for these different creators accounts\n```\nuse nft_protocol::creators;\nuse ob_utils::utils;\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n    \n    // List of all creators\n    let creators = vector[\n        @0xA01, @0xA05, @0xA06, @0xA07, @0x08\n    ];\n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        creators::new(utils::vec_set_from_vec(&creators)),\n    );\n \n    // Royalty payment is split between 5 accounts at 20% each.\n    let shares = vector[2_000, 2_000, 2_000, 2_000, 2_000];\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nCreators can also be added or removed with control over the Collection object (either as owned or shared object)."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Because users wouldn't be able to list without the owner being involved",
          "isCorrect": false
        },
        {
          "answer": "B. Because anyone can directly delist another user's listing and take the NFT for themselves",
          "isCorrect": true
        },
        {
          "answer": "C. Because KioskOwnerCap cannot be shared",
          "isCorrect": false
        }
      ],
      "lessonId": "12",
      "codeDef": "",
      "title": "Kiosk Standard - Trading NFTs",
      "quizTitle": "When creating a permissionless kiosk, why is it bad to make the KioskOwnerCap a shared object?",
      "content": "# Intro to NFT marketplaces\nNFT (Non-Fungible Token) marketplaces are vital hubs in the NFT ecosystem, enabling the buying, selling, and trading of unique digital assets. They matter for several key reasons:\n\n1. Accessibility: NFT marketplaces make it easy for people to enter the world of digital collectibles and unique content.\n2. Discoverability: These platforms provide tools for users to find NFTs that match their interests, fostering exploration and connection.\n3. Trust and Security: Blockchain technology ensures transparency, authenticity, and secure transactions.\n4. Secondary Sales: NFT marketplaces facilitate reselling, allowing creators to earn royalties, and investors to potentially profit.\n5. Community and Engagement: They build communities around NFTs, fostering interaction and collaboration.\n6. Monetization for Creators: Artists and creators can monetize their work directly on these platforms.\n\n# Kiosk - Sui's marketplace standard\nSui Kiosk is a standard for object marketplaces that support listing and selling. This is available as part of the Sui framework deployed at 0x2 and has a lot of powerful features that can support NFT trading well.\n\nKiosk modules can be found [here](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/kiosk) and offer the following features (also works for non-NFT objects):\n* Create and manage a new NFT marketplace (a kiosk)\n* Transfer ownership of the NFT marketplace\n* Listing and delisting NFTs\n* Purchasing listed NFTs\n* TransferPolicy allowing the NFT type owners (creators) to define custom rules for every trade of their NFT, including royalty enforcement (what we've seen with OriginByte in a previous lesson) and allowlisting\n\nKiosk currently only supports using SUI coins as payment but developers can deploy their own version of Kiosk to support other Coins if they want to.\n\n# Trading on Kiosk\nFirst a kiosk needs to be created:\n```\nstruct KioskManagement has key {\n    id: UID,\n    owner_cap: KioskOwnerCap,\n}\n\npublic fun create_kiosk(ctx: &mut TxContext) {\n    let (kiosk, owner_cap) = kiosk::new(ctx);\n    transfer::public_share_object(kiosk);\n    let kiosk_management = KioskManagement {\n        id: object::new(ctx),\n        owner_cap,\n    };\n    transfer::public_share_object(kiosk_management);\n}\n```\nIn the above example, we called kiosk::new to create the kiosk. Since it returns 2 objects that are both not droppable, we need to either share or transfer them. If developers choose to transfer and keep these objects, these kiosks can be considered \"personal kiosks\" as all listings and purchases require mutable access to the kiosk and/or the owner cap which only the owner has.\n\nIn the above example, we made the kiosk object shared and add the owner cap to a shared KioskManagement object. This would make the kiosk permissionless - anyone can list on it, subject to any rules we want in the list function:\n```\npublic fun list_on_kiosk<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft: T,\n) {\n    // Any validation we want of the NFT being listed.\n    kiosk::place(kiosk, &kiosk_management.owner_cap, nft);\n    // Keep track of the lister.\n}\n```\nkiosk::place requires a reference to the KioskOwnerCap object, which can be obtained from the shared kiosk_management object. Users have to call our list_on_kiosk function and cannot call kiosk::place directly as they don't have direct access to the owner cap object inside KioskManagement. Another note here is for an NFT to be listed for sale, the NFT type must have store ability.\n\nSellers can also delist the NFT. Note that we need to make sure whoever calls delist is the same person who created the listing originally. This can be tracked via a shared object with dynamic fields.\n```\npublic fun delist<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft_id: ID,\n) {\n    let sender = tx_context::sender(ctx);\n    // Validate that the sender is the same person who created the listing.\n    let nft = kiosk::take<T>(kiosk, &kiosk_management.owner_cap, nft_id);\n    transfer::public_transfer(nft, sender);\n}\n```\n\nSince the kiosk is a shared object, anyone can call sui::kiosk::purchase directly to purchase an NFT from a listing:\n```\n/// Make a trade: pay the owner of the item and request a Transfer to the `target`\n/// kiosk (to prevent item being taken by the approving party).\n///\n/// Received `TransferRequest` needs to be handled by the publisher of the T,\n/// if they have a method implemented that allows a trade, it is possible to\n/// request their approval (by calling some function) so that the trade can be\n/// finalized.\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {\n    let price = df::remove<Listing, u64>(&mut self.id, Listing { id, is_exclusive: false });\n    let inner = dof::remove<Item, T>(&mut self.id, Item { id });\n\n    self.item_count = self.item_count - 1;\n    assert!(price == coin::value(&payment), EIncorrectAmount);\n    df::remove_if_exists<Lock, bool>(&mut self.id, Lock { id });\n    coin::put(&mut self.profits, payment);\n\n    event::emit(ItemPurchased<T> { kiosk: object::id(self), id, price });\n\n    (inner, transfer_policy::new_request(id, price, object::id(self)))\n}\n```\nNote that while this returns the NFT purchased, it also does return a TransferRequest that cannot be dropped and needs to be \"validated\" before the transaction ends. We'll talk more about this as part of TransferPolicy in the next lesson."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Because buying an item off the Kiosk returns an undroppable TransferRequest",
          "isCorrect": true
        },
        {
          "answer": "B. Because money can be obtained from the user's account later if they refuse to pay",
          "isCorrect": false
        },
        {
          "answer": "C. Because TransferPolicy cannot be dropped",
          "isCorrect": false
        }
      ],
      "lessonId": "13",
      "codeDef": "",
      "title": "Kiosk Standard - Transfer Policy",
      "quizTitle": "Why can't users ignore TransferPolicy?",
      "content": "Kiosk has a very powerful functionality that allows NFT creators to dictate the rules for trading their NFTs such as royalty as we've seen in previous lessons: TransferPolicy. In the previous lesson, we've seen how purchasing an NFT first returns a TransferRequest that cannot be dropped:\n```\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {...}\n```\nIn order to resolve this TransferRequest, users need to call sui::transfer_policy::confirm_request:\n```\n/// Allow a `TransferRequest` for the type `T`. The call is protected\n/// by the type constraint, as only the publisher of the `T` can get\n/// `TransferPolicy<T>`.\n///\n/// Note: unless there's a policy for `T` to allow transfers,\n/// Kiosk trades will not be possible.\npublic fun confirm_request<T>(\n    self: &TransferPolicy<T>, request: TransferRequest<T>\n): (ID, u64, ID) {\n    let TransferRequest { item, paid, from, receipts } = request;\n    let completed = vec_set::into_keys(receipts);\n    let total = vector::length(&completed);\n\n    assert!(total == vec_set::size(&self.rules), EPolicyNotSatisfied);\n\n    while (total > 0) {\n        let rule_type = vector::pop_back(&mut completed);\n        assert!(vec_set::contains(&self.rules, &rule_type), EIllegalRule);\n        total = total - 1;\n    };\n\n    (item, paid, from)\n}\n```\nAs you can see transfer_policy::confirm_request goes through a list of \"rules\" that are completed in the request and check if all rules are satisfied. Note that confirm_request requires a TransferPolicy which can only be obtained by calling transfer_policy::new as we've seen earlier in the royalty lesson:\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nThis means the TransferPolicy can only be created by the creator and thus the creator can store it somewhere and add a function that confirms/resolves TransferRequest after checking that the royalty has been paid. They can add more rules to the policy by calling transfer_policy::add_rule as well\n```\nstruct TransferPolicyHolder<phantom T> has key {\n    id: UID,\n    transfer_policy: TransferPolicy<T>,\n}\n\npublic fun confirm_request(holder: &TransferPolicyHolder, request: TransferRequest<T>) {\n    // Verify our rules and add receipts for each confirmed rule to the request.\n    \n    transfer_policy::confirm_request(&holder.transfer_policy, request);\n}\n```\nTransferPolicyHolder is a shared object and users can always add it as an argument as the last step in the PTB (Programmable Transaction Block) after purchasing an NFT in the previous step.\n\nOverall, TransferPolicy is a very powerful primitive that allows for building very rich NFT collections and marketplaces."
    },
    {
      "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::option::{Self, Option};\n    use std::string::String;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        hat: Option<Hat>,\n        sunglasses: Option<SunGlasses>,\n    }\n\n    struct Hat has key {\n        id: UID,\n        diameter: u64\n    }\n\n    struct SunGlasses has key {\n        id: UID,\n        color: String,\n    }\n\n    entry fun wear_hat(sui_fren: &mut SuiFren, hat: Hat) {\n        option::fill(&mut sui_fren.hat, hat);\n    }\n\n    entry fun wear_sunglasses(sui_fren: &mut SuiFren, sun_glasses: SunGlasses) {\n        option::fill(&mut sui_fren.sun_glasses, sun_glasses);\n    }\n}\n",
      "quizType": "CODING",
      "answers": [],
      "lessonId": "14",
      "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    // Add the new structs and new functions here.\n}\n",
      "title": "Composable NFTs",
      "quizTitle": "1. Add a new Hat NFT with a diameter field of type u64.\n2. Add a new SunGlasses NFT with a color of type String.\n3. Update the SuiFren NFT to allow it to optionally wear a hat and sunglasses\n4. Add two new entry functions wear_hat and wear_sunglasses that allows the SuiFren to wear a hat and sunglasses, respectively",
      "content": "Similar to objects, NFTs can be combined together (\"composed\") using the different object techniques we've learnt in previous courses:\n1. Wrapping - Adding an NFT that has store ability as a field on another NFT. This removes the child NFT from storage.\n2. Dynamic object fields - Add the child NFT as a dynamic object field. Doesn't remove it from storage.\n3. Dynamic fields: Similar to dynamic object fields but the child NFT is removed from storage.\n4. Objects owning objects: Similar to dynamic object fields but have different syntax for accessing the child NFT (Receiving<T>) and maintain strict ownership chain.\n\nAmong these different approaches, it's the most straightforward to use object wrapping. A strong benefit here is that it's clear to UIs and games what NFTs can be added to an NFT such as adding weapons, armors, etc. to a hero NFT. Child NFTs can also be used to represent \"Traits\" of an NFT such as background.\n```\nstruct Background has key, store {\n    id: UID,\n    type: String,\n}\n\nstruct Eyewear has key, store {\n    id: UID,\n    type: String,\n}\n\nstruct Armor has key, store {\n    id: UID,\n    defense: u64,\n    durability: u64,\n}\n\nstruct Weapon has key, store {\n    id: UID,\n    num_uses: u64,\n    power: u64,\n}\n\nstruct Hero has key {\n    id: UID,\n    background: Background,\n    eyewear: Eyewear,\n    armor: Armor,\n    weapon: Weapon,\n}\n```\nIn the example above, Hero is a single NFT that wraps other NFTs as specific fields. The way it's currently written, a Hero must always have all of the child NFTs - background, eyewear, armor, weapon. If we want to make armor optional for example (a hero can wear or not wear armors), we can use the Option type:\n```\nuse std::option::Option;\n\nstruct Hero has key {\n    id: UID,\n    background: Background,\n    eyewear: Eyewear,\n    armor: Option<Armor>,\n    weapon: Weapon,\n}\n\npublic fun wear_armor(hero: &mut Hero, armor: Armor) {\n    option::fill(&mut hero.armor, armor);\n}\n\npublic fun take_off_armor(hero: &mut Hero) {\n    let armor = option::extract(&mut hero.armor);\n    transfer::public_transfer(armor, tx_context::sender(ctx));\n}\n```\nWe can then use ```option::fill``` and ```option::extract``` to add or remove the armor.\n\nThe benefit of using composable NFTs like this is if we sell the Hero NFT on a marketplace, all of the wrapped items also come with it. We can also freely remove the items if they're optional and transfer them between the different Hero NFTs we have. Composable NFT can be a very powerful primitive to build rich games and applications."
    },
    {
      "codeSol": "",
      "quizType": "ANSWERS",
      "answers": [
        {
          "answer": "A. Checking if a large vector contains an item can be slow due to linear scan",
          "isCorrect": true
        },
        {
          "answer": "B. Adding to a large vector is slow",
          "isCorrect": false
        },
        {
          "answer": "C. Vectors are bad and should be avoided in all situations",
          "isCorrect": false
        }
      ],
      "lessonId": "15",
      "codeDef": "",
      "title": "Efficiency of NFT mints and Effect on Sui network",
      "quizTitle": "Why does using a large vector affect the efficiency of the Sui network?",
      "content": "With the object model, specifically owned objects, the Sui network is built to handle hundreds of thousands of TPS as transactions that only modify specific owned objects can be executed in parallel without conflicting with one another:\n1. Alice adds an armor to her hero NFT. She owns both the armor and the hero NFTs.\n2. Bob sends some SUI as a gift to Alice, which modifies both of their primary Coin objects.\n\nThe two transactions above don't touch the same objects and can be run in parallel, significantly reducing the execution time. Furthermore, transactions involving owned objects don't need to go through the full consensus process that are usually heavy and slow for most networks.\n\nThe general rule of thumb for building scalable applications that can perform well on the Sui network and also reduce contention - if too many applications are built incorrectly, they can take up more execution time and resources on the Sui network and thus potentially lead to a lower scale than the Sui network is designed to achieve.\n\nThere's a few mistakes that developers should avoid as much as possible:\n1. Use modifiable shared objects when there are no reasons to. This can manifest during an NFT mint for example, where the Collection object has a supply field that's increased every time a new NFT is minted. This supply can also be used to generate an incrementing id for each NFT (e.g. SuiFren #124). This should be avoided if possible.\n2. Use a vector to keep track of which addresses have minted an NFT. This is common with allowlist features where only specific accounts that have been allowlisted can mint an NFT. The minting module then keeps track of who has minted so an account can only mint one NFT at maximum. Allowlist can be implemented incorrectly if developers use a vector or vec_set/vec_map (both use vectors underneath). If the allowlist is large enough (e.g. > 10k items), checking whether an address has minted before can be very expensive for the network as it'd take a long time to execute. In thse cases, it'd be better to use table instead.\n3. Freeze objects as much as possible instead of sharing if they are never changed."
    }
  ],
  "title": "NFT - Kiosk Standard"
}

[
  {
    "title": {
      "en": "Move on Sui Introduction",
      "vi": "Move on Sui Introduction"
    },
    "description": {
      "en": "This course follows the stories of Sui Frens that are born from SuiFrenGroup and pick up experience over time through various games and activities to evolve into better and stronger versions. In this course, learners are introduced to objects, the fundamental building block of Sui Move, and learn best design patterns and practices for creating, managing and combining objects into more powerful applications. This will set the foundation for more advanced courses later that dive into more sophisticated applications leveraging standards on Sui such as Coin and NFT (Kiosk) and application-specific design patterns such as Defi, Gaming, etc.",
      "vi": "This course follows the stories of Sui Frens that are born from SuiFrenGroup and pick up experience over time through various games and activities to evolve into better and stronger versions. In this course, learners are introduced to objects, the fundamental building block of Sui Move, and learn best design patterns and practices for creating, managing and combining objects into more powerful applications. This will set the foundation for more advanced courses later that dive into more sophisticated applications leveraging standards on Sui such as Coin and NFT (Kiosk) and application-specific design patterns such as Defi, Gaming, etc."
    },
    "modules": [
      {
        "title": "Fundamental concepts",
        "lesson": [
          {
            "codeSol": "",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 1,
            "codeDef": "",
            "title": "Meet the SuiFrens",
            "quizTitle": "Check out the SuiFrens below.",
            "content": "In this first lesson, you're going to be building the foundation for a fantasy world where the SuiFrens hang out, play different games, and evolve together.\n\nWe'll create a fren_group Move module with the following features:\n\nCreate new SuiFrens via a function. The first Fren type we’ll start out with is Baby Shark.\nKeep track of all the SuiFrens that have been born.\nEach SuiFren will be unique with its own appearance. You can see various aspects of their appearance can change and create unique SuiFrens - body, ear, belly, emotion, etc.\nEach SuiFren has a level field that denotes the SuiFren’s power. In later courses, we'll make our Sui Fren world more exciting with power upgrades, evolution, and breeding of new Fren types.\nIn order to generate a unique appearance for each SuiFren, we'll randomly generate the properties. There are generally two ways to do this:\n\n1. Generate each SuiFren off-chain and only randomize the id of the SuiFrens people receive. Each Sui Fren is then generated off-chain with unique combination of aspects and associated with a specific id. This allows each person to receive their own unique SuiFren.\n2. Generate a single random number on-chain that can be parsed into different attributes. We'll focus on this in our journey to explore Move together.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 2,
            "codeDef": "// Create the fren_group module here",
            "title": "Module",
            "quizTitle": "Write a module with the address as `0x123` and the module's name as `sui_fren`",
            "content": "Move code is organized into Modules. Each module roughly corresponds to a single smart contract on other blockchains. Move, however, offers a lot more functionalities that make organizing code into smaller and more modular pieces easier.\nEach module offers an API through its entry and public functions. Users can interact with the modules by calling functions from these modules via transactions or via other Move code. Transactions are sent to and processed by the Sui blockchain and once executed, the resulting changes will be saved. This tech stack resembles the Web 2 stack where Move modules act as the server with different routes/APIs, the Sui blockchain acting as the framework to run the server and provides the database for storing data. Developers can then build a UI that connects to this server and database to provide rich functionalities to their users.\n```\nmodule 0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script {\n\n\n}\n```\nDevelopers often deploy modules together as a single package, which gets assigned to an object and has its own address such as `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3`. The module can then be referred to with the object address and its name: `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script`. In this case the module's name is pool_script. Move also allows using an alias for the address by defining it in Move.toml (e.g. cetus=`0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3` and then defining the module as `cetus::pool_script`).\nWhen calling a function on this module, users can send a transaction content that invokes `0x996c4d9480708fb8b92aa7acf819fb0497b5ec8e65ba06601cae2fb6db3312c3::pool_script::open_position` where `open_position` is the function's name. This standard format of module and function identifiers makes it easy for applications to deploy, manage, and integrate with Move modules.\nModular design is strongly encouraged on Sui and developers should keep each module as small as possible and in its separate file. This keeps the data structure and code clean, while making it easier for applications to integrate with the modules and for users to more easily understand each transaction that they send. This is similar to principles from Web 2 development such as the Single Responsibility Principle (SRP).\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    struct AdminCap {\r\n        num_frens: u64,\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 3,
            "codeDef": "module 0x123::sui_fren {\r\n    // Create the struct here\r\n}\r\n",
            "title": "Structs",
            "quizTitle": "Add a new struct AdminCap with a single field num_frens of type u64",
            "content": "Data on the Sui blockchain can be organized into structs. Structs can be thought of as a group of related fields, each with its own type such as numbers, booleans, and vectors. Struct is a foundational concept in Sui Move. \n```\nmodule 0x123::my_module {\n   use sui::object::UID;\n\n\n   // All structs that are the core of an object need to have the `key` attribute and an id field of type UID.\n   struct MyObject has key {\n       id: UID,\n       color: u64,\n   }\n}\n```\nIn the example above, we're defining a simple struct MyObject with two fields id and color. Each struct can be defined as having \"abilities\" - key, store, drop, copy. We'll explain more later what these abilities mean.\n# Move types\n\nMove supports multiple different types:\n\n1. Unsigned integers: `u8`, `u16`, `u32`, `u64`, `u128`, `u256` The different types of integers have different maximum values they can store. For example, u8 can store values up to 2^8 - 1 or 255, while `u256` can store values up to 2^256 - 1.\n2. `Booleans: bool`\n3. `Addresses: address`. Address is a core construct in blockchains and represents a user identity. Users can generate addresses from keys that only they have off-chain and use them to sign transactions. This proves that the transactions do come from the users and are not fake.\n4. `String`\n5. `Vector`. An array of u64 would be `vector<u64>`.\n6. Custom struct types such as UID imported with use `sui::object::UID` in the earlier example.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 4,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n\r\n    struct AdminCap {\r\n        num_frens: u64,\r\n    }\r\n}\r\n",
            "title": "Sui Objects",
            "quizTitle": "In the previous lesson, we defined the AdminCap struct but it's not yet a valid Object type. Let's:\n1. Update AdminCap to have the key ability and an id field of type UID.\n2. Add a new private function - fun init that takes an argument ctx of type &mut TxContext and creates the AdminCap object with num_frens set to 1000. An init function is automatically called when the module is deployed to the blockchain.\n3. Share the AdminCap object so anyone can use to create Frens. We'll cover later how to make it so that only specific accounts can have AdminCap and create Frens.\n",
            "content": "A fundamental concept in Sui we first need to explore is objects. In Sui, all data is represented as fields inside distinct objects. This models real life where everything around us is an object - chair, table, light, etc. People go through life interacting with objects, looking at them to understand their characteristics, interacting with them and modifying their states.\n\nOn the Sui blockchain, modules create, read, interact with, and modify objects as part of their flows. As users send transactions to call different functions on the blockchain, the functions they call might need to read data from multiple objects that the users own, and modify them to reflect the results of the user interactions. Object is a core fundamental building block in Sui Move and the core of any application. When building one, the first thing developers should think about is what the application data looks like and which objects need to be created to store them.\n\nFor example, as part of a ticketing application, users might call into a module that first gives you a ticket and allow you to check if it has expired:\n```\nmodule 0x123::ticket_module {\n   use sui::clock::{Self, Clock};\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n \n   struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n   }\n \n   public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n       let ticket = Ticket {\n           id: object::new(ctx),\n           expiration_time: clock::timestamp_ms(clock),\n       };\n       transfer::share_object(ticket);\n   }\n}\n```\nThe steps are:\n\n1. Define the object (we use struct to represent the object). In this case, we define the Ticket object. This object must have the key ability and an id field of type object::UID (see the import statement at the top of the module).\n2. Call object::new with the default &mut TxContext argument passed to all functions when invoked via a transaction. &mut TxContext is required to create a new object to call object::new, which returns the object's unique id which can be assigned to the id field of the object (Ticket in this case).\n3. Call transfer::share_object to make the object shared. This is useful when the data in the object is used for multiple users (global data) and doesn’t belong to any specific user. In this case, technically a ticket is not meant to be shared but we'll make it shared for demonstration purposes. Owned objects are objects owned by a specific user and can only be read or modified with that user’s permission (via signing a transaction). We’ll cover shared and owned object more in subsequent lessons.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n\r\n\r\n    // Add function get_num_frens here\r\n    fun get_num_frens(admin_cap: &AdminCap): u64 {\r\n        admin_cap.num_frens\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 5,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 1000,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n\r\n\r\n    // Add function get_num_frens here\r\n}\r\n",
            "title": "Reading Object fields",
            "quizTitle": "Add a new function `get_num_frens` that takes an argument `admin_cap` of type `&AdminCap` object and returns the `num_frens` value.",
            "content": "Previously, we wrote a simple ticket application that creates tickets that have an expiration time. Let's introduce a separate function that reads this `expiration_time` field and checks if a ticket has expired:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::TxContext;\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun is_expired(ticket: &Ticket, clock: &Clock): bool {\n     ticket.expiration_time >= clock::timestamp_ms(clock)\n  }\n}\n```\nTo read the data of a `Ticket` object, the `is_expired` function above takes an immutable reference to the `Ticket` object. Move distinguishes between references and object values. When we only need to read the state of existing tickets in is_expired, we use a reference and should not be recreating or copying the entire ticket. This is similar to an electronic ticket where you can have multiple copies on your phone and laptop, but they all point to the same ticket. Immutable references just mean you can’t update the associated structs’ fields and can be represented with type `&StructName`. Note that `is_expired` also takes a `Clock` object reference (`&Clock`). This is another automatic argument, similar to `TxContext` that is passed by the system. We'll cover this more later.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let admin_cap = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: 10^3,\r\n        };\r\n        transfer::share_object(admin_cap);\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 6,
            "codeDef": "module 0x123::sui_fren {\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n\n\n   struct AdminCap has key {\n       id: UID,\n       num_frens: u64,\n   }\n  \n   fun init(ctx: &mut TxContext) {\n       let admin_cap = AdminCap {\n           id: object::new(ctx),\n           num_frens: 1000,\n       };\n       transfer::share_object(admin_cap);\n   }\n}\n",
            "title": "Math",
            "quizTitle": "Rewrite the default `num_frens` value for `AdminCap` using exponential of 10.",
            "content": "Doing math in Move is easy and very similar to other programming languages:\n* Add: x + y\n* Subtract: x - y\n* Multiply: x * y\n* Divide: x / y\n* Mod: x % y\n* Exponential: x ^ y\nNote that this is integer math, which means results are rounded down. For example, 5 / 2 = 2. We'll learn how to do fractional math in later lessons."
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    const DEFAULT_NUM_FRIENDS: u16 = 1000;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let config = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: (DEFAULT_NUM_FRIENDS as u64),\r\n        };\r\n        transfer::share_object(config);\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 7,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n\r\n    const DEFAULT_NUM_FRIENDS: u16 = 1000;\r\n\r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    fun init(ctx: &mut TxContext) {\r\n        let config = AdminCap {\r\n            id: object::new(ctx),\r\n            num_frens: DEFAULT_NUM_FRIENDS,\r\n        };\r\n        transfer::share_object(config);\r\n    }\r\n}\r\n",
            "title": "Typecasting",
            "quizTitle": "The init function below currently sets `num_frens` in AdminCap to a constant (fixed value) `DEFAULT_NUM_FRIENDS` of type `u16` despite `num_frens` is of type `u64`. This will fail to compile due to type mismatch. Fix this.",
            "content": "In the previous lesson, we've seen different types of integers: `u8`, `u32`, `u64`, `u128`, `u256`. Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different types:\n```\nfun mixed_types_math(): u64 {\n   let x: u8 = 1;\n   let y: u64 = 2;\n   // This will fail to compile as x and y are different types. One is u8, the other is u64.\n   x + y\n}\n```\nTo correct this, we need to cast x to `u64` with `(x as u64)`. Remember that the parentheses () are required when typecasting.\n```\nfun mixed_types_math(): u64 {\n   let x: u8 = 1;\n   let y: u64 = 2;\n   // This will fail to compile as x and y are different types. One is u8, the other is u64.\n   (x as u64) + y\n}\n```\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    // Add the new SuiFren struct here\r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 8,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    // Add the new SuiFren struct here\r\n}\r\n",
            "title": "Vectors",
            "quizTitle": "Define a new `SuiFren` object struct that has the following fields: generation of type `u64`, birthdate of type `u64`, and attributes as a `vector` of strings. Don't forget to add an import statement for `vector`.",
            "content": "When you want a list of values, use vectors. A vector in Move is dynamic by default and doesn't have a fixed size. It can grow and shrink as needed. Vector in Sui is imported by default and doesn't need to be explicitly added. You just need to do `use std::vector` at the top of your module to be able to access it. We’ll talk about other data structures and libraries available for use in a later course. Example:\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n\n\n   struct MyObject has key {\n       id: UID,\n       values: vector<u64>,\n       bool_values: vector<bool>,\n       address_values: vector<address>,\n   }\n}\n```\nYou can also store Objects in vectors by referencing the structs. Note that for an object to be stored in another object's field, its struct needs the store ability:\n\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n\n\n   struct NestedObject has key, store {\n       id: UID,\n       owner: address,\n       balance: u64,\n   }\n\n\n   struct GlobalData has key {\n       id: UID,\n       wrapped_objects: vector<NestedObject>,\n   }\n}\n```\n\nWhen creating an empty vector you can use the following syntax:\n```\nfun init() {\n   // The empty vector does not yet have a type declared. The first value added will determine its type.\n   let empty_vector = vector[];\n   let int_vector = vector[1, 2, 3];\n   let bool_vector = vector[true, true, false];\n}\n```"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    \n    struct AdminCap has key {\n        id: UID,\n        num_frens: u64,\n    }\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    \n    struct AdminCap has key {\n        id: UID,\n        num_frens: u64,\n    }\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\n        SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        }\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 9,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n}\r\n\r\nmodule 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Add the new function here\r\n}\r\n",
            "title": "Public vs Private Functions",
            "quizTitle": "Create a new public function named mint that takes four arguments and returns a SuiFren object:\n1. generation and birthdate of type `u64`\n2. attributes of type `vector<String>`\n3. ctx of type `&mut TxContext`.\n\nHint: You can use the following shortened form when struct field names and values have the same name:\n```\nstruct MyStruct {\n   value: u64,\n}\nlet value = 1;\nMyStruct {\n   value,\n}\n```",
            "content": "In the previous examples, we've only been using the `init` function, which creates the `AdminCap` object. This `init` function must be `private` and is called automatically by the Sui Virtual Machine (VM) when the module is deployed.\n\nIn this lesson, we'll create a `public` function that will be called by the user to create a new Fren. A public function in Move looks like this:\n```module 0x123::my_module {\n   public fun equals_1000(x: u64): bool {\n       x == 1000\n   }\n}\n```\nNote that this function has the keyword public, which means it can be called from any other Move modules and from transactions. Private functions on other hand can only be called in the same module and cannot be called from transactions. When public transactions are called, system objects such as `TxContext` and `Clock` can optionally be passed. It’s up to you to add those objects as arguments if your function needs them.\n**Good Practice**\nSystem objects need to always go at the end of the argument list.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun get_attributes(sui_fren: &SuiFren): vector<String> {\r\n        sui_fren.attributes\r\n    }\r\n\r\n    public fun update_attributes(sui_fren: &mut SuiFren, attributes: vector<String>) {\r\n        sui_fren.attributes = attributes;\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 10,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Add the new functions here\r\n}\r\n",
            "title": "Updating objects",
            "quizTitle": "1. Add a new public function `get_attributes` that takes a `sui_fren` object and return its attributes.\n2. Write a new public function `update_attributes` to allow changing a SuiFren's list of attributes. This function should take two arguments - the `sui_fren` object to modify and the new list of attributes",
            "content": "In this lesson, we'll learn how to modify an existing object by updating the fields of its struct. First we need to talk about mutable references. In a previous lesson on reading object fields, we covered immutable references and how we can pass them to public functions when sending transactions to read the state of an object.\n\nIn order to modify an object, we need to use mutable references instead. The difference in syntax is very simple - `&mut StructName` instead of `&StructName`. When interacting with the Sui blockchain, users can clearly see from a function’s arguments whether the functions only read or also modify objects by checking if it requires immutable objects (read only) or mutable (read and write).\n\nTo write a function that updates an object, we first need to specify the object being modified in a function via a mutable reference and then update its fields. All modified objects are automatically saved to the blockchain at the end of the transaction. Example:\n```\nmodule 0x123::my_module {\n   use std::vector;\n   use sui::object::{Self, UID};\n   use sui::transfer;\n   use sui::tx_context::TxContext;\n\n\n   struct MyObject has key {\n       id: UID,\n       value: u64,\n   }\n\n\n   fun init(ctx: &mut TxContext) {\n       let my_object = MyObject {\n           id: object::new(ctx),\n           value: 10,\n       };\n       transfer::share_object(my_object);\n   }\n\n\n   public fun set_value(my_object: &mut MyObject, value: u64) {\n       my_object.value = value;\n   }\n}\n```\nThat's it! Pretty simple, right? You just need to pass a mutable reference to an object instead of immutable.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::{Self, TxContext};\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 11,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\r\n        SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        }\r\n    }\r\n}\r\n",
            "title": "Owned Objects",
            "quizTitle": "Update mint to send the newly created `SuiFren` to the transaction sender instead of returning it.",
            "content": "In the previous lessons, we learned how to create, read, and modify the `SuiFren` object which is shared among all users.\n\nThere are two types of Objects:\n1. `Shared Objects` can be read and modified by any users. We previous made `AdminCap` a shared object, which would allow any users to create Sui Frens. This might not be the desired behavior.\n2. `Owned Objects` are private objects that only users who own them can read and modify. Ownership is automatically verified as part of executing the transactions on Sui. Note that only direct ownership is allowed, so if user A owns object B and object B owns object C, user A cannot send a transaction that includes object C. There is a workaround for this using `Receiving<T>` but we'll cover this later.\n\nLet’s modify our `Ticket` example in previous lessons to create true tickets that are given to individual users instead of being accessible by all:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::{Self, TxContext};\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n        let ticket = Ticket {\n             id: object::new(ctx),\n             expiration_time: clock::timestamp_ms(clock),\n        };\n        // tx_context::sender(ctx) returns the address of the user who sends this transaction.\n        transfer::transfer(ticket, tx_context::sender(ctx));\n  }\n \n  public fun is_expired(ticket: &Ticket, clock: &Clock): bool {\n     ticket.expiration_time >= clock::timestamp_ms(clock)\n  }\n}\n```\nIn order to make `Ticket` objects owned, we just need to explicitly transfer the object to an address instead of calling `transfer::share` like before. Here, we transfer newly created tickets to the user who sends the transaction that calls `create_ticket`. To get the user's address, we use `tx_context::sender(ctx)`."
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n\r\n    // Add the new burn function here\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 12,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct AdminCap has key {\r\n        id: UID,\r\n        num_frens: u64,\r\n    }\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n    \r\n    // Add the new burn function here\r\n}\r\n",
            "title": "Deleting Objects",
            "quizTitle": "Add a new public burn function that takes and destroys a SuiFren :(\n",
            "content": "In previous lessons, we have covered the two type of Object arguments that can be passed to a function from a user transaction: immutable reference `&ObjectStruct` used to read data from an object and mutable reference `&mut ObjectStruct` used to modify an object. There's a third type of object argument we can pass to an entry function - the object value that can be used to delete an object from Sui storage:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::object::{Self, UID};\n  use sui::transfer;\n  use sui::tx_context::TxContext;\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  public fun clip_ticket(ticket: Ticket) {\n     let Ticket {\n         id,\n         expiration_time: _,\n     } = ticket;\n     object::delete(id);\n  }\n}\n```\nIn the example above, we added a new function `clip_ticket` that takes a `Ticket` object as an argument and deletes it. We are not passing a mutable reference to the object as we're not modifying it. We're instead passing the entire Ticket struct so we can delete it:\n1. Destruct the Ticket struct with let `Ticket { id, expiration_time: _ } = ticket`\n2. Destroy the Ticket object with `object::delete(id)`"
          },
          {
            "codeSol": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    use sui::event;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    struct MintEvent has copy, drop {\r\n        id: ID,\r\n    }\r\n\r\n    struct BurnEvent has copy, drop {\r\n        id: ID,\r\n    }\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let uid = object::new(ctx);\r\n        let id = object::uid_to_inner(&uid);\r\n        let sui_fren = SuiFren {\r\n            id: uid,\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n        event::emit(MintEvent {\r\n            id,\r\n        });\r\n    }\r\n\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n        event::emit(BurnEvent {\r\n            id: object::uid_to_inner(&id),\r\n        });\r\n    }\r\n}\r\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 13,
            "codeDef": "module 0x123::sui_fren {\r\n    use sui::object::{Self, UID};\r\n    use sui::transfer;\r\n    use sui::tx_context::TxContext;\r\n    use std::string::String;\r\n    use std::vector;\r\n    \r\n    struct SuiFren has key {\r\n        id: UID,\r\n        generation: u64,\r\n        birthdate: u64,\r\n        attributes: vector<String>,\r\n    }\r\n\r\n    // Define the new events here\r\n\r\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\r\n        let sui_fren = SuiFren {\r\n            id: object::new(ctx),\r\n            generation,\r\n            birthdate,\r\n            attributes,\r\n        };\r\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\r\n    }\r\n\r\n    public fun burn(sui_fren: SuiFren) {\r\n        let SuiFren {\r\n            id,\r\n            generation: _,\r\n            birthdate: _,\r\n            attributes: _,\r\n        } = sui_fren;\r\n        object::delete(id);\r\n        // Emit event here\r\n    }\r\n}\r\n",
            "title": "Events",
            "quizTitle": "Emit two events:\n1. `MintEvent` which has the id of the newly minted `SuiFren` object.\n2. `BurnEvent` which has the id of the `SuiFren` being deleted. Hint: Don't forget imports!",
            "content": "Our module is almost finished! Now let's add events. Wait, but what are events? Event is a way for your module to communicate that something happened on the blockchain to your app front-end, which can be 'listening' for certain events and take action when they happen. Without events, it's much harder for an \"off-chain\" component (smart contracts are considered \"on-chain\") to monitor whether tickets are created, extended, or redeemed. They would need to query the results for each transaction and manually go through the results to see what objects are changed and how exactly they changed. This is not easy at all and events can help!\nExample:\n```\nmodule 0x123::ticket_module {\n  use sui::clock::{Self, Clock};\n  use sui::event;\n  use sui::object::{Self, ID, UID};\n  use sui::transfer;\n  use sui::tx_context::{Self, TxContext};\n \n  struct Ticket has key {\n      id: UID,\n      expiration_time: u64,\n  }\n \n  struct CreateTicketEvent has copy, drop {\n     id: ID,\n  }\n \n  struct ClipTicketEvent has copy, drop {\n     id: ID,\n  }\n \n   public fun create_ticket(ctx: &mut TxContext, clock: &Clock) {\n     let uid = object::new(ctx);\n     let id = object::uid_to_inner(&uid);\n     let ticket = Ticket {\n           id: uid,\n           expiration_time: clock::timestamp_ms(clock),\n     };\n     transfer::transfer(ticket, tx_context::sender(ctx));\n     event::emit(CreateTicketEvent {\n         id,\n     });\n   }\n \n  public fun clip_ticket(ticket: Ticket) {\n     let Ticket { id, expiration_time: _ } = ticket;\n     object::delete(id);\n     event::emit(ClipTicketEvent {\n        id: object::uid_to_inner(&id),\n     });\n  }\n}\n```\nIn order to emit an event on Sui, you just need to do two things:\n1. Define the event struct like `ClipTicketEvent`.\n2. Call `event::emit` to emit the event defined in (1) Note that if we want to include the object id (essentially an address) in the event, we need to use `object::uid_to_inner` to convert the original UID type to an ID type yet. UID cannot be copied or stored."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Owned objects need to go through consensus before transactions using them are finalized.",
                "isCorrect": false
              },
              {
                "answer": "B. Shared objects can be converted into owned objects but not the opposite.",
                "isCorrect": false
              },
              {
                "answer": "C. Owned objects can shared when they're created. Shared objects cannot be converted to owned objects.",
                "isCorrect": true
              }
            ],
            "lessonId": 14,
            "codeDef": "",
            "title": "Shared Objects vs Owned Objects",
            "quizTitle": "What's the difference between Shared objects and Owned objects?",
            "content": "In previous lessons, we got familiar with Shared and Owned Objects:\n```\nstruct SharedObject has key {\n   id: UID,\n}\n\n\nstruct OwnedObject has key {\n   id: UID,\n}\n\n\npublic fun create_shared_object(ctx: &mut TxContext) {\n let shared_object = SharedObject {\n     id: object::new(ctx),\n };\n transfer::share_object(shared_object);\n}\n\n\npublic fun create_owned_object(ctx: &mut TxContext) {\n let owned_object = OwnedObject {\n     id: object::new(ctx),\n };\n transfer::transfer(owned_object, tx_context::sender(ctx));\n}\n```\nA key benefit of using Owned Objects is that they can be processed in parallel as transactions touching them don’t overlap with one another (they don’t read or modify the same data). Shared objects, however, cannot be processed in parallel if they’re modified and would need to go through a more rigorous execution process, which is slower and less scalable.\nAnother important thing to note with Shared Objects is that they can only be shared in the same transaction where they’re created. This would not work:\n```\nstruct SharedObject has key {\n   id: UID,\n}\n\n\npublic fun create_object(tx_context: &mut TxContext) {\n let object = SharedObject {\n     id: object::new(ctx),\n };\n transfer::transfer(object, tx_context::sender(ctx));\n}\n\n\npublic fun share_object(object: SharedObject) {\n transfer::share_object(object);\n}\n```\nIf we call `create_object` which creates an initially owned object and then later try to share it with `share_object` in a second transaction, this would fail!"
          },
          {
            "codeSol": "",
            "quizType": "CODING",
            "answers": [],
            "lessonId": 15,
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "",
            "content": "**Module**\n1. Module Organization: Move code is organized into modules, each similar to a single smart contract on other blockchains.\n2. API and Interaction: Modules provide APIs through entry and public functions. Users interact with these modules by calling functions either through transactions or other Move code. This interaction is processed by the Sui blockchain, and any resulting changes are saved.\n3. Modular design is emphasized in Sui. Developers are encouraged to keep modules small and in separate files, adhering to clean data structures and code. This facilitates easier integration for applications and clearer understanding for users. \n\n**Struct**\n1. Struct is a group of related fields, each with its own type such as numbers, booleans, and vectors.\n2. Each struct can be defined as having \"abilities\" - key, store, drop, copy.\n3. MoveSui supports these following data types: unsigned integers, booleans, addresses, string, vector, and custom struct types.\n\n**Objects**\nAfter finishing this module, you should be able to understand:\n1. Life cycle of an object\n2. How to read an object\n3. How to update an object\n4. How to delete an object\n5. Shared objects vs owned objects\n\n**Vectors** could be understood as dynamic arrays, essential for managing lists of items in smart contracts, reflecting the need for flexible data structures in blockchain applications.\n\n**Events** is a way for your module to communicate that something happened on the blockchain to your app front-end, which can be 'listening' for certain events and take action when they happen.\n\n**Functions**\n1. Public function (has keyword public): can be called from any other Move modules and from transactions\n2. Private function (has keyword private): can  be called only in the same module and cannot be called from transactions"
          }
        ]
      },
      {
        "name": "Intermediate Move",
        "lesson": [
          {
            "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    public fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct MintEvent has copy, drop {\n        id: ID,\n    }\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let uid = object::new(ctx);\n        let id = object::uid_to_inner(&uid);\n        let sui_fren = SuiFren {\n            id: uid,\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n        event::emit(MintEvent {\n            id,\n        });\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "1",
            "codeDef": "// Add the new module and function here\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    // Add any friend declaration here\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct MintEvent has copy, drop {\n        id: ID,\n    }\n\n    // Update\n    public fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let uid = object::new(ctx);\n        let id = object::uid_to_inner(&uid);\n        let sui_fren = SuiFren {\n            id: uid,\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n        event::emit(MintEvent {\n            id,\n        });\n    }\n}",
            "title": "Package protected function - public(friend) and Gift boxes",
            "quizTitle": "Currently, anyone can mint `Sui Frens`. Let's:\n1. Make mint function friend only\n2. Add a new module `0x123::fren_summer` with a public function `open_box` which has the same signature as `sui_fren::mint` (for now) and call `sui_fren::mint` there. \nWe'll explain what this function will be used for in the next lessons.",
            "content": "In the previous course, we have covered the basic concepts in Sui Move: Modules, Functions, Objects and Events. In this course, we'll dive deeper into more useful concepts in Move and Objects that allow us to build a more fun and complex Sui Fren world.\n\nLet's first talk about functions. In the previous course, we saw public and private functions:\n1. Public functions can be called by transactions (via Programmable Transaction Blocks that we'll cover later) and also by other Move code (same or different modules)\n2. Private functions can only be called within the same module.\n```\nmodule 0x123::my_module {\n    public fun public_equal(x: u64): bool {\n        x == 1000\n    }\n    \n    fun private_equal(x: u64): bool {\n        x == 1000\n    }\n}\n```\nIf you recall, modules are grouped into packages for deployment on Sui. This leads to a third type of function visibility - `public(friend)`. `public(friend)` functions are similar to package-visible functions in other languages and can only be called by modules in the same package. This allows developers to limit dangerous functions to only be called by their own modules and not by others.\n```\nmodule 0x123::my_other_module {\n    use 0x123::my_module;\n\n    public fun do_it(x: u64): bool {\n        my_module::friend_only_equal(x)\n    }\n}\n\nmodule 0x123::my_module {\n    friend 0x123::my_other_module;\n\n    public(friend) fun friend_only_equal(x: u64): bool {\n        x == 1000\n    }\n}\n```\nTo create a `public(friend)` function we just need to use the corresponding visibility modified - `public(friend)`. Any modules such `0x123::my_other_module` in the example above that call the `public(friend)` function also needs to be declared explicitly as a \"friend\" - friend `0x123::my_other_module`. This explicit declaration is required for now but the Sui Move team has plans to make this not required in the future. This would truly make public(friend) functions package-visible."
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "2",
            "codeDef": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    public fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}",
            "title": "Programmable Transaction Block and Entry functions: Open gift boxes",
            "quizTitle": "Update `fren_summer::open_box` to be a private entry function.",
            "content": "Another important type of function is entry functions. In the old Move language, there are two types of entry functions - public entry and private entry.\n\nOn the Sui network, a Programmable Transaction Block (PTB) allows users to specify a series of actions (transactions) to be sent to the network as a single transaction. The actions are executed sequentially and are atomic - if any of them fails, the entire PTB fails and all changes are automatically reverted. PTB is a powerful concept that will be covered more in later courses. For now, we'll refer to PTBs as transactions that users send to the Sui blockchain. PTBs can call any public, public entry and private entry functions written in Move modules. Therefore, there are effectively no differences between public and public entry functions in Sui although these concepts are still inherited from classic Move.\n\nThe only new function type we need to learn is private entry functions, which can only be called directly from a transaction, but not from other Move code.\n\nPrivate entry functions (entry functions for short) are useful when developers want to offer features directly to users that can only be called as part of a transaction but not in other module. One example could be clipping a ticket - we want users to have to explicitly have to call this as part of the transaction and don't want other modules to clip a user's ticket on their behalf. The latter is harder for users to detect and they might not expect this to happen when sending a transaction.\n```\nentry fun clip_ticket(ticket: Ticket) {\n    let Ticket {\n          id,\n          expiration_time: _,\n      } = ticket;\n      object::delete(id);\n}\n```\n"
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "3",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n\n    // Add the new struct here\n\n    entry fun open_box(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        sui_fren::mint(generation, birthdate, attributes, ctx);\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
            "title": "Struct abilities - key, copy, drop, store",
            "quizTitle": "Give `SuiFren` store ability and define a new GiftBox object struct in the `fren_summer` module that has a field inner of type `SuiFren`. The GiftBox struct doesn't need store ability as it doesn't need to be part of any other structs.",
            "content": "In the previous course, we learnt about structs and how a struct needs to have the key ability to become an object:\n```\nstruct AdminCap has key {\n    id: UID,\n    num_frens: u64,\n}\n```\nBeside the key ability, structs can also have 3 other abilities: store, copy, and drop. Structs can have 1, 2, 3, or all 4 abilities. However, for a struct to have a specific ability, all of its fields must have the same ability.\n\nStore ability allows a struct to be part of other structs. Note that if `NestedStruct` below has another `DoubleNestedStruct` field, that struct also needs to have store ability.\n```\nstruct NestedStruct has store {\n    value: u64,\n}\n\nstruct Container has key {\n    id: UID,\n    nested: NestedStruct,\n}\n```\nCopy ability allows a struct to be \"copied\", which creates an instance of the struct with the same exact field values. Note that object structs (those with key ability and id field) cannot have the copy ability as the UID struct doesn't have copy.\n```\nstruct CopyableStruct has copy {\n    value: u64,\n}\n\nfun copy(original: CopyableStruct) {\n    let copy = original;\n    original.value = 1;\n    copy.value = 2;\n    // We now have two CopyableStructs with two different values.\n}\n```\nDrop ability allows a struct to be implicitly destroyed at the end of a function without having to \"destruct\":\n```\nstruct DroppableStruct has drop {\n    value: u64,\n}\n\nfun copy() {\n    let droppable = DroppableStruct { value: 1 };\n    // At the end of this function, droppable would be destroyed.\n    // We don't need to explicitly destruct:\n    // let DroppableStruct { value: _ } = droppable;\n}\n```\nIt's very important to remember that a struct can only have an ability if ALL of its fields have the same ability. Without remembering this, developers can get very confused if they try to create a droppable struct while having an undroppable field."
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun create_gift(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    public(friend) fun create(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext): SuiFren {\n        SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        }\n    }\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let sui_fren = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "4",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new functions here\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new function here\n\n    public(friend) fun mint(generation: u64, birthdate: u64, attributes: vector<String>, ctx: &mut TxContext) {\n        let sui_fren = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes,\n        };\n        transfer::transfer(sui_fren, tx_context::sender(ctx));\n    }\n}",
            "title": "Object wrapping - Wrapping Sui Frens in Gift Boxes",
            "quizTitle": "Let's add a few new functions:\n1. Add a friend function to the `sui_fren` module - create, which has the same arguments as mint and creates and returns a `SuiFren`.\n2. Add a new entry function to `fren_summer` - `create_gift`, which has the same arguments as `sui_fren::create`, calls `sui_fren::create` to create a `SuiFren`, puts it into a `GiftBox`, and sends the `GiftBox` to the sender.\n3. Add a new entry function to `fren_summer` - `wrap_fren`, which takes an existing `SuiFren` argument named `fren`, wraps it in a `GiftBox`, and sends the `GiftBox` to the sender.",
            "content": "We created a new type of object - `GiftBox` that has a `SuiFren` in it. But how do we get a `SuiFren` in there? There are two options here:\n1. Create a new function in `sui_fren` - create, that creates a `SuiFren` object and returns it, instead of immediately transferring it to the sender like the mint function.\n2. Mint the `SuiFren` first. Once the transfer has happened in mint, we cannot retrieve the `SuiFren` in the same transaction and would need to do that in a followup transaction while explicitly passing that `SuiFren` in as an argument. We can add a wrap function in `fren_summer` that allows the sender to wrap an existing `SuiFren` and create a gift box. They can later send it to friends.\n\nIn the second case, putting the `SuiFren` into the `GiftBox` is called <b>object wrapping<b>. This does more than you think - it takes the object being wrapped <b>out of the object storage<b>. This means that if you have a UI that displays all the `SuiFrens` a user owns, that `SuiFren` they wrapped will disappear from the list.\n```\nstruct Box has key {\n    id: UID,\n    thing: Thing,\n}\n\nstruct Thing has key, store {\n    id: UID,\n}\n\npublic fun wrap(thing: Thing, ctx: &mut TxContext) {\n    let box = Box { id: object::new(ctx), thing };\n    transfer::transfer(box, tx_context::sender(ctx));\n}\n```\nNote that the wrap function takes a value, not a reference! We covered passing objects by value in the previous course and how this removes the object from storage.\n"
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    struct GiftWeekConfig has key {\n        id: UID,\n        limit: u64,\n    }\n\n    entry fun create_week(limit: u64, ctx: &mut TxContext) {\n        let gift_week_config = GiftWeekConfig {\n            id: object::new(ctx),\n            limit,\n        };\n        transfer::freeze_object(gift_week_config);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "5",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
            "title": "Immutable objects - Gift Season Info",
            "quizTitle": "Imagine users can create gift boxes with their `SuiFrens` and give away to their friends during specific weeks of the holiday season. However, we want to limit the number of gifts that can be created in each week (can be different from week to week). In order to do this, we'll:\n1. Create a new object struct `GiftWeekConfig` that has the id field and another field - limit of type `u64`.\n2. Create a new entry function `create_week` that takes a limit argument and creates and freezes a `GiftWeekConfig` object.  ",
            "content": "We have created two objects so far: `SuiFren` and `GiftBox`. Both of these are owned objects. They're owned by users and only the owners can include them in a transaction. We also briefly discussed shared objects - those that can be include in any transactions. Let's talk about a third type of object in this lesson - immutable objects.\n\nImmutable objects are almost the same as shared objects. Any user can include them as part of their transactions. However, shared objects can be included as mutable references and thus modifiable by anyone. Immutable objects can never change after they're \"frozen\".\n```\nstruct ColorObject has key {\n    id: UID,\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\npublic entry fun freeze_owned_object(object: ColorObject) {\n    transfer::freeze_object(object)\n}\n\npublic entry fun create_immutable(red: u8, green: u8, blue: u8, ctx: &mut TxContext) {\n    let color_object = ColorObject {\n        id: object::new(ctx),\n        red,\n        green,\n        blue,\n     };\n    transfer::freeze_object(color_object);\n}\n```\n\nIn the example above, `create_immutable` creates an object and immediately freezes it, making it immutable. `freeze_owned_object`, on the other hand, takes an existing owned object and makes it immutable. Note that `transfer::freeze_object` would error out if called on shared objects. `freeze_owned_object` demonstrates another key difference between immutable objects and shared objects - owned objects cannot become shared (`transfer::share_object` needs to be call immediately after an object is created in the same transaction), but owned object can be made immutable anytime as long as the owner wants to.\n\nImmutable objects can be included via immutable reference (&) anytime:\n```\npublic fun read_immutable(color: &ColorObject): (u8, u8, u8) {\n    (color.red, color.green, color.blue)\n}\n```\nread_immutable can be called on any immutable (frozen) color objects and ownership is not required.\n"
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(gift_box: GiftBox, ctx: &TxContext) {\n        let GiftBox {id, inner} = gift_box;\n        object::delete(id);\n        transfer::public_transfer(inner, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "6",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    entry fun open_box(gift_box: GiftBox) {\n        \n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n\n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n}",
            "title": "Transfer Policy - Public and private transfers of objects",
            "quizTitle": "Update the `open_box` function in the `fren_summer` module to destruct the `GiftBox` object, take the inner `SuiFren` and then transfer that to the sender. Don't forget to update abilities.",
            "content": "We have already seen both owned objects in action:\n```\nstruct OwnedObject has key {\n    id: UID,\n}\n\npublic fun create_owned_object(tx_context: &mut TxContext) {\n  let owned_object = OwnedObject {\n      id: object::new(ctx),\n  };\n  transfer::transfer(owned_object, tx_context::sender(ctx));\n}\n```\nWe have also learnt about struct abilities - key, store, copy, drop. There's a special hidden feature that you can get by combining the store ability and the functionalities offer by the transfer module - Transfer Policy.\n\nWith Transfer Policy, developers can dictate if the objects they define can be transferred outside of their module code:\n1. Objects that have the store ability can be transferred outside of the same module it's defined in with `transfer::public_transfer`.\n```\nmodule 0x123::my_module {\n    struct OwnedObject has key, store {\n        id: UID,\n    }\n}\n\nmodule 0x123::your_module {\n    use 0x123::my_module::OwnedObject;\n    \n    public fun transfer(object: OwnedObject, receiver: address) {\n        transfer::public_transfer(object, receiver);\n    }\n}\n```\n2. Objects without the store ability can <b>only<b> be transferred with `transfer::transfer` inside the same module it's defined in. In the example above, if we remove the store ability from OwnedObject, the transfer function in `your_module` would stop working. OwnedObject can now only be transferred directly inside `my_module`:\n```\nmodule 0x123::my_module {\n    struct OwnedObject has key {\n        id: UID,\n    }\n    \n    public fun transfer(object: OwnedObject, receiver: address) {\n        transfer::transfer(object, receiver);\n    }\n}\n```\n\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Yes",
                "isCorrect": true
              },
              {
                "answer": "B. No",
                "isCorrect": false
              }
            ],
            "lessonId": "7",
            "codeDef": "",
            "title": "Transfer Policy - share vs public_share, freeze vs public_freeze",
            "quizTitle": "Imagine you're working on a movie theatre smart contract that can issue Ticket objects for different shows. Should this Ticket object have the store ability?",
            "content": "Similar to `transfer::transfer` and `transfer::public_transfer` functions, the transfer module also offers:\n1. `share` and `public_share`\n2. `freeze` and `public_freeze`\n\nThese functions work similarly to `transfer` vs `public_transfer` - the public versions can only be used if the object passed to them has the store ability. This gives developers additional flexibility to control how their objects can be used.\n\nWith `share` and `public_share`, the developers can allow their objects to only be owned or also sharable. For example:\n1. A developer creates a `PunchCard` object where users can get a hole clipped every time they buy a boba tea. The developer wants the `PunchCard` to be sharable between users so different users can use the same `PunchCard`. They can just add the store ability to `PunchCard`.\n2. Another developer creates a `GymMembership` object for their gym but doesn't want their membership to be shared by more than one users. They just need to not give `GymMembership` the store ability.\n\nWith `freeze` and `public_freeze`, developers can similarly decide if they want the owners to be able to make their objects immutable:\n1. The `PunchCard` object from earlier can potentially be made immutable if the users want to give up on it.\n2. The `GymMembership` object cannot be made immutable as once the membership expires, it should be deleted."
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Candy};\n    use sui::tx_context;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n        candies: vector<Candy>,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Candy has store {\n        value: u64,\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "8",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Candy};\n    use sui::tx_context;\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n}",
            "title": "Wrapping Objects vs Non-object structs",
            "quizTitle": "Create a new struct `Candy` in the `sui_fren` module that has a single field value of type `u64` and add a new field candies to `GiftBox` of type vector of `Candies`. For now `Candy` is a non-object struct and we'll feed the candies to `Fren` to up-level them in later sessions.",
            "content": "In a previous lesson, we learnt about Object Wrapping and how we can wrap a `SuiFren` object into a `GiftBox`:\n```\nstruct GiftBox has key {\n    id: UID,\n    inner: SuiFren,\n}\n\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n```\nThere's an alternative to object wrapping that has a similar syntax - using a non-object struct that only has the store ability:\n```\nstruct SuiFren has store {\n    generation: u64,\n    birthdate: u64,\n    attributes: vector<String>,\n}\n```\nThis approach is usually useful only if the developer doesn't plan to turn the nested struct type into an object. This can help break a long object struct into smaller related components, for example:\n```\nstruct LongObject has key {\n    id: UID,\n    field_1: u64,\n    field_2: u64,\n    field_3: u64,\n    field_4: u64,\n    field_5: u64,\n    field_6: u64,\n    field_7: u64,\n    field_8: u64,\n}\n```\nvs\n```\nstruct BigObject has key {\n    id: UID,\n    field_group_1: FieldGroup1,\n    field_group_2: FieldGroup2,\n    field_group_3: FieldGroup3,\n}\n\nstruct FieldGroup1 has store {\n    field_1: u64,\n    field_2: u64,\n    field_3: u64,\n}\n\nstruct FieldGroup2 has store {\n    field_4: u64,\n    field_5: u64,\n    field_6: u64,\n}\n\nstruct FieldGroup3 has store {\n    field_7: u64,\n    field_8: u64,\n\n}\n```\n\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Owned object",
                "isCorrect": false
              },
              {
                "answer": "B. Shared object",
                "isCorrect": false
              },
              {
                "answer": "C. Immutable object ",
                "isCorrect": true
              }
            ],
            "lessonId": "9",
            "codeDef": "",
            "title": "Shared objects - parallel execution and consensus",
            "quizTitle": "If we have a `SuiFrenConfig` object that's initialized in the init function but never changed. What kind of object should it be?",
            "content": "Another hidden knowledge that's good to know as developer on Sui: In general, it's better to design your smart contracts to use Owned objects as much as possible. Shared objects should generally only be used for shared state across many users, and immutable objects are preferred over shared objects if that state doesn't need to change.\n\nShared objects go through a separate execution path on the Sui network as it requires full consensus. If any users can change a shared object, there can be conflicts that lead to different final results depending on the ordering. Therefore, the Sui network needs to use a full Consensus process and make sure all Sui validators agree on the ordering and the final results before they are committed to storage. Because of this, shared objects would take longer to execute and impose a higher cost on the Sui network than owned or immutable objects. You can think of this as the Sui network works the best if as many objects can be owned or immutable or possible.\n\nThe general rules of thumb are:\n1. Immutable objects for all shared state of a contract if the data never changes.\n2. Shared objects for shared state that can be updated.\n3. Owned objects for everything else. "
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    use sui::package;\n    use sui::types;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "10",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the witness struct here\n\n    // Add the init function here\n}",
            "title": "System Objects: One-time Witness Object and Publisher Object",
            "quizTitle": "Add a witness struct to the `sui_fren` module and an init function that:\n1. Takes the witness object as argument and creates a publisher object\n2. Transfers the publisher struct to the sender (same as the deploying account). Note that you would need to use the right transfer function (which one between `transfer` and `public_transfer`?)",
            "content": "We have seen the `TxContext` object, which can be passed as mutable or immutable reference. Let's discuss other special objects.\n\nWhen deploying a module, any init function would be called automatically. The init function can also be given a witness object - a special system object that is only created once the first time the module is deployed:\n```\nmodule 0x123::my_module {\n    struct MY_MODULE has drop {}\n    \n    fun init(witness: MY_MODULE) {\n        // Do something with the witness object.\n    }\n}\n```\nIn order to receive the witness object in the init function, you need to declare a struct with the same name as the module but in all uppercase (any _ is kept). This struct must have the drop ability. Now, when you define the init function you can add the witness object of that type as the first argument.\n\nWitness objects currently only have two main cases but more can be added by the Sui team in the near future:\n1. Claim the `Publisher Object`. `Publisher Object` is a proof that the keeper has deployed the object.\n```\nfun init(witness: MY_MODULE, ctx: &mut TxContext) {\n    assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n    let publisher_object = package::claim(witness, ctx);\n    // Use or store the publisher object...\n}\n```\n2. Proof when calling other modules' functions that this is in the middle of the initialization flow. This is usually useful when there's a set of actions that have to be done with multiple different modules as part of initializing the project.\n```\nmodule 0x123::module_b {\n    fun init(module_a_witness: MODULE_A, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&module_a_witness), ENotOneTimeWitness);\n        // We know that this is being called from module A's init function.\n    }\n}\n```\nPublisher objects also only have 2 use cases currently but more can be added soon:\n1. Create Display Objects. More on these in the next lesson\n2. Set transfer policy in Sui's Kiosk (NFT standard). This will be covered in the NFT course."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n\n    public fun create_display_object(publisher: &Publisher, ctx: &mut TxContext) {\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display_object,\n            vector[\n                utf8(b\"id\"),\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n                utf8(b\"attributes\"),\n            ],\n            vector[\n                utf8(b\"id: {id}\"),\n                utf8(b\"generation: {generation}\"),\n                utf8(b\"birthdate: {birthdate}\"),\n                utf8(b\"all attributes: {attributes}\"),\n            ],\n        );\n        display::update_version(&mut display_object);\n        transfer::public_transfer(display_object, tx_context::sender(ctx));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "11",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUI_FREN has drop {}\n\n    fun init(witness: SUI_FREN, ctx: &mut TxContext) {\n        assert!(types::is_one_time_witness(&witness), ENotOneTimeWitness);\n        let publisher_object = package::claim(witness, ctx);\n        transfer::public_transfer(publisher_object, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}",
            "title": "System Objects: Display Objects",
            "quizTitle": "Add a new public function add_display that creates a display object for a SuiFren with the following formatting rules:\n1. `id` will be formatted as `id: {id}`\n2. `generation` will be formatted as `generation: {generation}`\n3. `birthdate: {birthdate}`\n4. `all attributes: {attributes}`\nThe display object should be sent to the sender.",
            "content": "Display `Objects (Display<T>)` are objects that indicate how fields can be displayed for an object of a specific type.\n```\nstruct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n```\nIf an account holds both MyObject and Display<MyObject>, a web UI can look at the fields in Display<MyObject> to know how to format and display the fields of MyObject.\n```\nmodule 0x123::my_module {\n    struct MyObject has key {\n        id: UID,\n        num_value: u64,\n        string_value: String,\n    }\n    \n    public fun create_display_object(publisher: &Publisher, ctx: &mut TxContext) {\n        let display_object = display::new<MyObject>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"num_value\"),\n                utf8(b\"string_value\"),\n            ],\n            vector[\n                utf8(b\"Value: {num_value}\"),\n                utf8(b\"Description: {string_value}\"),\n            ],\n        );\n        display::update_version(&mut display);\n    }\n}\n```\nIn order to create the display object, we need a reference to the publisher object for the module where `MyObject` is deployed at. Assuming we have created this object (see previous lesson) and store it in an account we control, we can use this account to call `create_display_object`. After the display object is created, we can add formatting rules by calling `display::add_multiple` with two vectors, one for the list of fields from `MyObject` to display and one for the formatting rules.\n\nAfter the formatting rules have been set, we can call `display::update_version` to finalize the updates to the display object. Once the display object is created, an event is emitted that allows the Sui network nodes to detect the Display object. Subsequently, whenever an object is fetched via the node API, its display attributes are also computed in the exact formatting specified and returned along with the rest of the object's fields.\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Because timestamp could be manipulated by validators",
                "isCorrect": true
              },
              {
                "answer": "B. Because timestamp could be non deterministic",
                "isCorrect": false
              },
              {
                "answer": "C. Because timestamp can be manipulated by users",
                "isCorrect": false
              }
            ],
            "lessonId": "12",
            "codeDef": "",
            "title": "System Objects - Clock",
            "quizTitle": "Why is timestamp potentially dangerous to use to generate random results?",
            "content": "The last system object we'll look into is the `Clock` object. This allows user to obtain the current time as recorded on the Sui blockchain:\n```\nuse sui::clock;\n\npublic entry fun get_time(clock: &Clock) {\n    let timestamp_ms = clock::timestamp_ms(clock);\n}\n```\nNote that the returned timestamp is in million seconds (1 second = 1000 ms).\n\nTimestamp can used in two common ways:\n1. Get the timestamp for record keeping or emitting events\n```\nstruct TimeEvent has copy, drop {\n    timestamp_ms: u64,\n}\n    \npublic entry fun get_time(clock: &Clock) {\n    event::emit(TimeEvent { timestamp_ms: clock::timestamp_ms(clock) });\n}\n```\n2. Generate a pseudo-random number. This is technically susceptible to validator manipulation as validators can set the timestamp within a very small margin of error.\n```\nentry fun flip_coin(clock: &Clock): u64 {\n    let timestamp_ms = clock::timestamp_ms(clock);\n    // 0 is heads, 1 is tails\n    timestamp % 2\n}\n```\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. The previous function that's calling the current function",
                "isCorrect": false
              },
              {
                "answer": "B. The sender of the transaction",
                "isCorrect": true
              },
              {
                "answer": "C. The sender of SUI tokens",
                "isCorrect": false
              }
            ],
            "lessonId": "13",
            "codeDef": "",
            "title": "System Object: TxContext and avoid security vulnerabilities",
            "quizTitle": "What does `tx_context::sender` return?",
            "content": "Another very commonly used System object is TxContext. We have seen this in action for two main use cases:\n1. Create a new object's id with `object::new`\n2. Get the sender with `tx_context::sender`\n```\nstruct MyObject has key {\n    id: UID,\n    value_1: u64,\n    value_2: u64,\n}\n\npublic fun create_object(value_1: u64, value_2: u64, ctx: &mut TxContext) {\n    let object = MyObject {\n        id: object::new(ctx),\n        value_1,\n        value_2,\n    };\n    transfer::transfer(object, tx_context::sender(ctx));\n}\n```\nDevelopers should pay close attention to how they use the sender address returned from `tx_context::sender`. It's okay to send newly created to this objects, but it can be problematic to use as authentication or proof of user's direct intention to call this function. For example:\n```\nmodule 0x123::safe_module {\n    public fun claim_rewards(amount: u64, receiver: address, ctx: &mut TxContext) {\n        let sender = tx_context::sender(ctx);\n        assert!(sender == @0x12345, ENOT_AUTHORIZED);\n        // Send the amount of rewards to the receiver address\n    }\n}\n```\nIn the example above, we want to write a special function `claim_rewards` that allows a specific address to call and withdraw an amount of reward money. This looks safe on the surface but can be exploited! A malicious developer can just write a module that promises an airdrop to the users and in the code do the following:\n```\nmodule 0x123::malicious_module {\n    const MALICIOUS_DEVELOPER: address = @0x98765;\n\n    public fun airdrop(ctx: &mut TxContext) {\n        safe_module::claim_rewards(1000, MALICIOUS_DEVELOPER, ctx);\n    }\n}\n```\nThis would instantly drain the user's rewards! safe_module cannot easily distinguish if the ctx object is being passed by the VM (first function call) or by another function from another object. One solution here could be to make claim_rewards an entry function so it has to be directly called by the user. However, this might not be desirable in some cases if we want to sometimes allow our own code (from a different module in the same package) to call this function. \n\nIn general, using `tx_context::sender` as an authentication mechanism is risky and should be very thoroughly evaluated if there can be any possible exploits.\n\nOther functions that the `tx_context` module offers includes digest which returns the transaction hash, epoch and `epoch_timestamp_ms` which return the current epoch number and corresponding timestamp, and `fresh_object_address` which uses the same underlying function as `object::new` to generate a new object's address."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Anyone",
                "isCorrect": false
              },
              {
                "answer": "B. Owner of object 1",
                "isCorrect": false
              },
              {
                "answer": "C. Owner of object 2",
                "isCorrect": true
              }
            ],
            "lessonId": "14",
            "codeDef": "",
            "title": "Struct data access and user ownership rules",
            "quizTitle": "In the following example:\n```\nstruct MyData has key {\n    id: UID,\n    value: u64,\n}\n\npublic fun set_value(object_1: &MyData, object_2: &MyData, value: u64) {\n    object_2.value = value;\n}\n```\nIf `object_1` is a shared object and `object_2` is a owned object, who can send this transaction?",
            "content": "# Struct data access rules\nWe have seen various different type of structs, including object structs (those with the key ability) and non-object structs (those without the key ability). In order to access a field of a struct instance, object or non-object, we just need to use the dot annotation and call `struct_instance.field`. The `struct_instance` can be a mutable or immutable reference, or a value. However, this doesn't work outside of the module where the struct is defined:\n```\nmodule 0x123::a {\n    struct MyData has key {\n        id: UID,\n        value: u64,\n    }\n    \n    // This works\n    public fun get_value_from_reference(object: &MyData): u64 {\n        object.value\n    }\n    \n    // This works\n    public fun get_value_from_mut_reference(object: &mut MyData): u64 {\n        object.value\n    }\n}\n\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This doesn't work\n    public fun get_value(object: &MyData): u64 {\n        object.value\n    }\n}\n```\nIn the example above, `b::get_value` will fail to compile as it tries to access the value field of `MyData` but `MyData` is defined inside module a, and not in module b. In Move, only the modules that define a struct can freely access its fields. If other modules need to access a field, it'd need to do so through the original module's getter function:\n```\nmodule 0x123::b {\n    use 0x123::a::MyData;\n    \n    // This now works\n    public fun get_value(object: &MyData): u64 {\n        a::get_value_from_reference(object)\n    }\n}\n```\nIn general, this is call the module-scoped rule for struct data access. This allows developers to define rules for how their data (structs) can be read or written. They can keep the data private and not allow any external modules to access inner fields, or they can implement public getters (return an inner field's values) and setters (set an inner field's value) that can be called by external modules. They can also implement custom authentication module that requires a specific permission object to be able to update the struct's values.\n\n# User ownership\nIn the first course, we have covered Owned objects and how they can only be accessed and modified by transactions sent by the owner. This is automatically verified by the Sui blockchain when the transactions are executed and guarantees that an account's owned objects cannot be read/modified without their permission. \n\nThrough enforcement of this ownership, users can be reassured that no modules can read or modify their owned objects without them explicitly signing transactions that authorize the modules to do so. "
          },
          {
            "codeSol": "",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "15",
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "",
            "content": "This module furthers your understandings of basic Sui Move. \n\n**Functions** We are learning two more types of functions:\n1. Public (friend) functions: similar to package-visible functions in other languages and can only be called by modules in the same package. This allows developers to limit dangerous functions to only be called by their own modules and not by others.\n2. Private (entry) function: can only be called directly from a transaction, but not from other Move code.\n\n**Programmable Transaction Block (PTB)** allows users to specify a series of actions (transactions) to be sent to the network as a single transaction. The actions are executed sequentially and are atomic - if any of them fails, the entire PTB fails and all changes are automatically reverted\n\n**Struct** \nBeside key ability, structs also offer 3 more abilities: \n1. Store ability allows a struct to be part of other structs. \n2. Copy ability allows a struct to be \"copied\", which creates an instance of the struct with the same exact field values.\n3. Drop ability allows a struct to be implicitly destroyed at the end of a function without having to \"destruct\".\n\nStruct data access. This allows developers to define rules for how their data (structs) can be read or written. They can keep the data private and not allow any external modules to access inner fields, or they can implement public getters (return an inner field's values) and setters (set an inner field's value) that can be called by external modules. They can also implement custom authentication module that requires a specific permission object to be able to update the struct's values.\n\n**Object**\n1. Object Wrapping: a method for encapsulating objects within other objects, a key technique for creating layered data structures and managing ownership and access in a more granular manner.\n2. Immutable Object: is the third type of objects beside shared objects and owned objects. Immutable object can be included  as part of users' transactions but can NEVER be changed after they're \"frozen\".\n3. System Object: Witness Object, Publisher Object, Display Object, Clock\n4. Transferability: \n- Objects that have the store ability can be transferred outside of the same module. Objects without the store ability can ONLY be transferred with transfer::transfer inside the same module it's defined in.\n- Share and public_share objects: the developers can allow their objects to only be owned or also sharable.\n- Freeze and public_freeze, developers can similarly decide if they want the owners to be able to make their objects immutable\nGolden rules for choosing types of objects to use:\n* Immutable objects for all shared state of a contract if the data never changes.\n* Shared objects for shared state that can be updated.\n* Owned objects for everything else."
          }
        ]
      },
      {
        "name": "Advanced Objects",
        "lesson": [
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has store {\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String) {\n        if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n        }\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "1",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
            "title": "Dynamic Field - SuiFrens and their Hat",
            "quizTitle": "1. Add a new struct Hat with store ability to the sui_fren module. Hat has a single field color of type String. We'll add more fields later on.\n2. Add a new public function color_hat that takes a mutable reference to a SuiFren named sui_fren and a color of type String.\n3. color_hat should add a hat if one doesn't exist for that SuiFren or update the color of the existing one.\n4. You can use string::utf8(HAT_KEY) as the dynamic field key.",
            "content": "In the previous course, we have explored Objects in depth and created SuiFrens as objects that have their own attributes and a Display object that tells Web UI how they should be displayed. We also covered the following topics:\n1. Nested structs - Structs with the store ability can be embedded into another struct. This is often used for non-object structs to divide a long list of fields into logical components.\n2. Object wrapping - Putting a SuiFren into another object. This also uses the store ability but effectively removes the wrapped object from storage. SuiFrens that have been wrapped into GiftBoxes can no longer be looked up when searching by objects.\n\nIn this lesson, we'll cover another way to compose structs and objects together - Dynamic Fields. You can think of Dynamic Fields as invisible fields that are not explicitly defined on an object struct. Let's assume we have a Laptop Object that has the following attributes initially:\n```\nstruct Laptop has key {\n    id: UID,\n    screen_size: u64,\n    model: u64,\n}\n```\nLet's say we want to dynamically add more attributes for this laptop in the future but don't yet know what these attributes are exactly. We can't define them in the struct right away. This is where Dynamic Fields come to the rescue - you don't need to know all the fields you want to add to an object as dynamic fields!\n```\nuse sui::dynamic_field;\n\npublic fun add_attribute(laptop: &mut Laptop, name: String, value: u64) {\n    dynamic_field::add(&mut laptop.id, name, value);\n}\n```\nIn order to add dynamic fields to an object, you need a mutable reference to that object. Remember that for owned objects, only the owner can send transactions that use mutable/immutable references or a value of their object. Shared objects can be mutated by anyone. Adding a dynamic field can be done simply via dynamic_field::add with the mutable object's id, the key and the value.\n\nKey and value can be primitive types (numbers, strings, etc.) or structs. Note that structs used as keys must have the copy, drop, and store abilities while structs used as values must have the store ability.\n```\nstruct StickerName has copy, drop, store {\n    name: String,\n}\n\nstruct Sticker has store {\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, image_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker = Sticker { image_url };\n    dynamic_field::add(&mut laptop.id, sticker_name, sticker);\n}\n```\nDynamic fields are unique by name so you can't add fields of the same name more than once.\n\nTo read or modify a dynamic field, you need an immutable and mutable references to the object respectively and the field name (key). If the field name is a struct, you need the struct value itself, which is why the structs used as keys must have copy and drop abilities.\n```\npublic fun read_image_url(laptop: &Laptop, name: String): String {\n    let sticker_name = StickerName { name };\n    let sticker_reference: &Sticker = dynamic_field::borrow(&laptop.id, sticker_name);\n    sticker_reference.image_url\n}\n\npublic fun set_image_url(laptop: &mut Laptop, name: String, new_url: String) {\n    let sticker_name = StickerName { name };\n    let sticker_mut_reference: &mut Sticker = dynamic_field::borrow_mut(&mut laptop.id, sticker_name);\n    sticker_mut_reference.image_url = new_url;\n}\n```\nNote that if you usually would need to specify the type of the field borrowed (&Sticker and &mut Sticker in the above example)\n\nYou can also remove an existing dynamic field with a mutable object reference and the key:\n```\npublic fun remove_sticker(laptop: &mut Laptop, name: String) {\n    let sticker_name = StickerName { name };\n    dynamic_field::remove(&mut laptop.id, sticker_name);\n}\n```\nYou can check if a dynamic field exists with dynamic_field::exists_(&laptop.id, sticker_name)"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_object_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            let hat = Hat {\n                id: object::new(ctx),\n                color,\n            };\n            dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n        }\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "2",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Update\n    struct Hat has store {\n        color: String,\n    }\n\n    // Update\n    public fun color_hat(sui_fren: &mut SuiFren, color: String) {\n        if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n            hat.color = color;\n        } else {\n            dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n        }\n    }\n}",
            "title": "Dynamic Object Field - Store objects as dynamic field",
            "quizTitle": "1. Update Hat to be an object\n2. Use dynamic object field to add that Hat instead. Remember you'd need to add a transaction context param to the color_hat function to be able to create Hat objects.",
            "content": "You must have a question about dynamic fields - what if we store an object in a dynamic field. While this is possible, one side effect of storing a Sticker object as a dynamic field on a Laptop is the Sticker object will be removed from storage and cannot be looked up by its id off-chain (for example in a web UI). This is the same side effect we saw with object wrapping.\n```\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, sticker: Sticker) {\n    dynamic_field::add(&mut laptop.id, name, sticker);\n}\n```\nNote that the Sticker object must also have the store ability to be stored in a dynamic fields. Because Sticker is now an object, we also need to explicit pass it via a transaction. If it's an owned object, only the owner can do so (ownership rule).\n\nIf you don't want the Sticker object to be removed from global storage so your web UI can still look it up, you can use the dynamic_object_field module instead of dynamic_field. These two modules and their functions look pretty much the same inside Move - the difference regarding global storage only matters for off chain components such as the web UI.\n```\nuse sui::dynamic_object_field;\n\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &mut Laptop, name: String, sticker: Sticker) {\n    dynamic_object_field::add(&mut laptop.id, name, sticker);\n}\n```\nIn general, dynamic object fields are preferred over dynamic fields to store objects dynamically. You should only use dynamic fields if you intentionally want to remove the objects from global storage. One example could be when you put a hat on your SuiFren, you want the Hat to be gone from global storage to indicate it has been claimed.\n\nBonus: You might be curious about what happens to the ownership of an object after it has been added as a dynamic field on another object. The answer is that it'd be owned by the <b>dynamic field<b> itself! Behind the scene, when dynamic fields are added, each field is secretly created as a separate object in the global storage tied to the parent object the field is defined on. This dynamic field object would own the object added to it. In the example above, the Laptop owns the sticker dynamic field and the sticker dynamic field owns the Sticker object. Confusing right? Most developers don't really need to know this :)"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. They both don't remove the nested object from global storage",
                "isCorrect": false
              },
              {
                "answer": "B. They both require explicit struct definition",
                "isCorrect": false
              },
              {
                "answer": "C. They both can work for object and non-object structs",
                "isCorrect": true
              }
            ],
            "lessonId": "3",
            "codeDef": "",
            "title": "Dynamic Fields vs Dynamic Object Fields vs Wrapping",
            "quizTitle": "What is the similarity between object wrapping and dynamic fields?",
            "content": "Let's summarize the different approaches to combining objects we have learnt so far:\n1. Object wrapping: Store objects within another objects (for example SuiFrens in GiftBoxes). This removes the wrapped objects (SuiFrens) from global storage. Off-chain web UI cannot look them up after wrapping. The object no longer has any owner. You can think of this almost as converting an object into a normal non-object struct instance.\n2. Dynamic Fields: Can be used to store objects as well. This also removes the object from global storage. Ownership is also removed. Very similar to object wrapping, except that the field is added dynamically instead of explicitly defined in the struct.\n3. Dynamic Object Fields: Does not remove the object from global storage. Ownership is transferred to the special \"dynamic field object\" that is generally not easy to look up for Web UIs. In most cases, this has almost the same effect as forfeiting ownership of the object.\n\n```\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n\n// Dynamic fields\npublic fun color_hat(sui_fren: &mut SuiFren, color: String) {\n    if (dynamic_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n        let hat = dynamic_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n        hat.color = color;\n    } else {\n        dynamic_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), Hat { color });\n    }\n}\n\n// Dynamic object fields\npublic fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n    if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n        let hat = dynamic_object_field::borrow_mut(&mut sui_fren.id, string::utf8(HAT_KEY));\n        hat.color = color;\n    } else {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n    }\n}\n```\n\nTo choose how to compose objects, developers should pay attention to:\n1. Whether the field should be explicitly defined in the struct. This is a drawback of using dynamic fields as they are not easily seen from looking at the object struct definition. This means other developers will need to read through the entire module's code to find all possible dynamic fields that can be added. It's generally not recommended to add more than 10 separate dynamic fields.\n2. Whether the object should be removed from global storage and thus not visible to web UI."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n\n    public fun update_hat_color(sui_fren: &mut SuiFren, hat: Receiving<Hat>, color: String, ctx: &mut TxContext) {\n        let hat = transfer::receive(&mut sui_fren.id, hat);\n        hat.color = color;\n        transfer::transfer(hat, object::uid_to_address(&sui_fren.id));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "4",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    // Update\n    public fun color_hat(sui_fren: &mut SuiFren, color: String, ctx: &mut TxContext) {\n        let hat = Hat {\n            id: object::new(ctx),\n            color,\n        };\n        dynamic_object_field::add(&mut sui_fren.id, string::utf8(HAT_KEY), hat);\n    }\n}",
            "title": "Objects owning Objects",
            "quizTitle": "1. Rewrite the color_hat function to transfer the Hat object to the SuiFren object instead of using dynamic object fields.\nNote that if the hat already exists, we can't easily change its color without adding a Receiving<Hat> to the color_hat function, which doesn't make sense and conflicts with the case when the SuiFren doesn't have a hat!\n2. Instead, add a separate public function update_hat_color that updates the color of an existing hat.",
            "content": "Yet another way to compose objects is to have objects own other objects. With the other three approaches - object wrapping, dynamic fields, dynamic object fields, ownership is forfeited or set to a hidden object (dynamic field object). In some cases, it can be desired to have the parent object own the child object (for example SuiFren owning the Hat it wears). This can be seen as a clear indication of object hierarchy in a complex application design with multiple types of objects.\n\nAnother interesting use case for objects owning objects is composable NFTs - exactly like SuiFrens owning their Hats. This allows for powerful composition of NFTs together that make natural sense to users and is often seen in Web 3 Games that use NFTs.\n\nOne drawback that makes objects owning objects less commonly used compared to the other 3 approaches is that it's harder to remove the owned object later. Therefore, objects owning objects is generally more useful if the relationship is rarely or never changed.\n\n```\nstruct Laptop has key {\n    id: UID,\n}\n\nstruct Sticker has key, store {\n    id: UID,\n    image_url: String,\n}\n\npublic fun add_sticker(laptop: &Laptop, sticker: Sticker) {\n    transfer::public_transfer(sticker, object::uid_to_address(&laptop.id));\n}\n```\nIn the example above, we explicitly transfer the Sticker object to the Laptop. It's now owned by the Laptop. In order to remove it later, we'd need to use Receiving<T>:\n```\npublic fun remove_sticker(laptop: &mut Laptop, sticker: Receiving<Sticker>) {\n    let sticker = transfer::public_receive(&mut laptop.id, sticker);\n    // Do something with the sticker\n}\n```\nIn order to extract the Sticker object that was transferred to the Laptop object earlier, we need the owner of the Laptop to call the remove_sticker function with a mutable reference to the Laptop and a variable of type Receiving<Sticker>. When sending the transaction, the owner can specify the Sticker object's address, and the Sui VM will automatically convert it into the Receiving<Sticker> type. We can then call transfer::public_transfer to get the underlying Sticker. As you can see, this is a bit harder to do than object wrapping or dynamic fields.\n\nNote that extracting an object owned by another object is also subject to the Transfer Policy (see the corresponding lesson from the previous course):\n1. If the inner object has the store ability, transfer::public_receive can be call to extract it outside of the module where its struct is defined\n2. If the inner object has no store ability, transfer::public_receive cannot be called. Only transfer::receive can be called inside the module where the struct is defined."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Because dynamic object fields removes the structs from object storage",
                "isCorrect": false
              },
              {
                "answer": "B. Because the struct fields don't have to be objects",
                "isCorrect": true
              },
              {
                "answer": "C. Because dynamic fields are faster to read and write than dynamic object fields",
                "isCorrect": false
              }
            ],
            "lessonId": "5",
            "codeDef": "",
            "title": "Using Dynamic Fields for Managing Contract States",
            "quizTitle": "Why do we want to use dynamic fields for the different laptop store configs instead of dynamic object fields?",
            "content": "Another useful application of dynamic fields is to manage contracts states. You might be tempted to use multiple shared objects for each state struct. For example, we can have the following set up for the laptop store's configs:\n```\nstruct PriceConfigs has key {\n    id: UID,\n    price_range: vector<u64>,\n}\n\nstruct StoreHours has key {\n    id: UID,\n    open_hours: vector<vector<u8>>,\n}\n\nstruct SpecConfigs has key {\n    id: UID,\n    specs_range: vector<u64>,\n}\n\nfun init(ctx: &mut TxContext) {\n    let price_configs = PriceConfigs {\n        id: object::new(ctx),\n        price_range: vector[1000, 5000],\n    };\n    let store_hours = StoreHours {\n        id: object::new(ctx),\n        open_hours: vector[vector[9, 12], vector[1, 5]],\n    };\n    let spec_configs = SpecConfigs {\n        id: object::new(ctx),\n        specs_range: vector[1000, 10000],\n    };\n    transfer::share_object(price_configs);\n    transfer::share_object(store_hours);\n    transfer::share_object(spec_configs);\n}\n```\nIt's not a lot of work to create the shared objects. Each object is shared so it can be accessed and/or modified by users when they purchase a laptop for example:\n```\npublic fun purchase_laptop(price_configs: &PriceConfigs, store_hours: &SotreHours, spec_configs: &SpecConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n}\n```\nAs you can see, this function's signature is too long and hard to read. Furthermore the web UI that submits the transactions on the user's behalf would need to track all of these shared objects' addresses. Imagine what would happen if we have 5 or even 10 shared objects! It's also overkill as these different structs are never separated and live independently so they don't really need to be objects.\n\nIt's much cleaner to instead create a single state config object and add dynamic fields there:\n```\nstruct StateConfigs has key {\n    id: UID,\n}\n\nconst PRICE_CONFIGS: vector<u8> = b\"PRICE_CONFIGS\";\nstruct PriceConfigs has store {\n    price_range: vector<u64>,\n}\n\nconst STORE_HOURS: vector<u8> = b\"STORE_HOURS\";\nstruct StoreHours has store {\n    open_hours: vector<vector<u8>>,\n}\n\nconst SPEC_CONFIGS: vector<u8> = b\"SPEC_CONFIGS\";\nstruct SpecConfigs has store {\n    specs_range: vector<u64>,\n}\n\nfun init(ctx: &mut TxContext) {\n    let state_configs = StateConfigs {\n        id: object::new(ctx),\n    };\n    dynamic_fields::add(&mut state_configs.id, PRICE_CONFIGS, PriceConfigs {\n        id: object::new(ctx),\n        price_range: vector[1000, 5000],\n    });\n    dynamic_fields::add(&mut state_configs.id, STORE_HOURS, StoreHours {\n        id: object::new(ctx),\n        open_hours: vector[vector[9, 12], vector[1, 5]],\n    });\n    dynamic_fields::add(&mut state_configs.id, SPEC_CONFIGS, SpecConfigs {\n        id: object::new(ctx),\n        specs_range: vector[1000, 10000],\n    });\n    transfer::share(state_configs);\n}\n```\nThe user transactions would then only need to track and pass a single object's address:\n```\npublic fun purchase_laptop(state_configs: &StateConfigs, laptop: String, price: u64, ctx: &mut TxContext) {\n}\n```\nAs you can see, this is much cleaner!"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    const EXTENSION_1: u64 = 1;\n\n    struct HatExtension1 has store {\n        description: String,\n        duration: u64,\n    }\n\n    public fun extend_hat(sui_fren: &mut SuiFren, description: String, duration: u64) {\n        if (dynamic_object_field::exists_(&sui_fren.id, string::utf8(HAT_KEY))) {\n            let hat: &mut Hat = dynamic_object_field::borrow_mut(sui_fren, string::utf8(HAT_KEY));\n            dynamic_field::add(&mut hat.id, EXTENSION_1, HatExtension1 {\n                description,\n                duration,\n            });\n        };\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "6",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use std::string::String;\n    use sui::dynamic_field;\n    use sui::dynamic_object_field;\n    \n    struct SuiFren has key, store {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    const HAT_KEY: vector<u8> = b\"HAT\";\n\n    struct Hat has key, store {\n        id: UID,\n        color: String,\n    }\n\n    // Add the new struct here\n\n    // Add the new function here\n}",
            "title": "Dynamic Fields for Extensibility and Upgradability",
            "quizTitle": "We want to ExtendHat to also add a description field of type String and duration of type u64.\n1. Add a new struct for the extension, named HatExtension1\n2. Add a new public function extend_hat that takes a SuiFren, a description, a duration and extend the SuiFren's hat if it exists",
            "content": "In earlier lessons on Dynamic Fields and Dynamic Object Fields, we have discussed adding new fields dynamically to an existing object. This is a powerful ability that can be used to extend an existing object especially when upgrading an existing Move module.\n\nWhat is upgrading? When a Move module is deployed to the Sui blockchain, its package is assigned an address as discussed in the first course. If we want to add more code and overriding the code at the address we deployed to, we'd need to upgrade the code instead. Upgrading, however, is subject to specific rules depending on which compatibility policy was specified when you deploy the code the first time:\n\n[Compatibility Policies and Rules from Sui's official documentation](https://docs.sui.io/concepts/sui-move-concepts/packages/custom-policies)\n1. Immutable\tNo one can upgrade the package.\n2. Dependency-only\tYou can modify the dependencies of the package only.\n3. Additive\tYou can add new functionality to the package (e.g., new public functions or structs) but you can't change any of the existing functionality (e.g., the code in existing public functions cannot change).\n4. Compatible\tThe most relaxed policy. In addition to what the more restrictive policies allow, in an upgraded version of the package:\n- You can change all function implementations.\n- You can remove the ability constraints on generic type parameters in function signatures.\n- You can change, remove, or make public any private, public(friend), and entry function signatures.\n- You cannot change public function signatures (except in the case of ability constraints mentioned previously).\n- You cannot change existing types (structs).\n\nAs you can see, when upgrading existing code, you cannot change any existing structs! This means if you cannot add new fields or change the names of existing fields. Dynamic fields are the only way you can dynamically extend existing objects/structs so you just need to add new functions or update existing functions to do this.\n\nAs discussed in a previous lesson, it's generally not recommended to add more than 10 dynamic fields as they can be scattered throughout the code and hard to find. There's a good way to fix this and still be able to easily extend existing objects - Group the newly added fields into a single struct:\n```\nuse sui::dynamic_field;\n\nstruct Laptop has key {\n    id: Id,\n}\n\nconst EXTENSION_1: u64 = 1;\n\nstruct PurchaseDetails has store {\n    customer_name: String,\n    street_address: String,\n    price: u64,\n}\n\npublic fun add_purchase_details(laptop: &mut Laptop, customer_name: String, street_address: String, price: u64) {\n    dynamic_field::add(&mut laptop.id, EXTENSION_1, PurchaseDetails {\n        customer_name,\n        street_address,\n        price,\n    });\n}\n```\nWe're extending an existing Laptop struct with PurchaseDetails with 3 new fields. This means we only need to add a single new dynamic field. Note that:\n1. PurchaseDetails is not an object. We don't intend it to ever live separately outside of Laptop so it doesn't make sense to make it an object.\n2. We use the extension number as the key. This will increment if we need to extend the Laptop object multiple times. You can also use a string or other types if desired. \n\nWe can also use the same pattern to augment an object that has been added as a dynamic object field on another object as well:\n```\nuse sui::dynamic_object_field;\nuse sui::dynamic_field;\n\nstruct Laptop has key {\n    id: Id,\n}\n\nstruct Sticker has key, store {\n    id: Id,\n}\n\nconst EXTENSION_1: u64 = 1;\n\nstruct StickerPurchaseDetails has store {\n    customer_name: String,\n    street_address: String,\n    price: u64,\n}\n\npublic fun add_sticker_purchase_details(laptop: &mut Laptop, sticker_name: String, customer_name: String, street_address: String, price: u64) {\n    let sticker: &mut Sticker = dynamic_object_field::borrow_mut(laptop, sticker_name);\n    dynamic_field::add(&mut sticker.id, EXTENSION_1, StickerPurchaseDetails {\n        customer_name,\n        street_address,\n        price,\n    });\n}\n```"
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    struct GiftBox has key {\n        id: UID,\n        object_bag: ObjectBag,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            object_bag: object_bag::new(ctx),\n        };\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, fren);\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, hat);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "7",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren, Hat};\n    use sui::tx_context;\n    use sui::object_bag::{Self, ObjectBag};\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Update\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}",
            "title": "Object Data Structure - Bag of Mixed Objects",
            "quizTitle": "1. Update the GiftBox struct to use ObjectBag instead of a single field of type SuiFren.\n2. Update wrap_fren to work with the ObjectBag.\n3. Add a wrap_hat entry function that adds a Hat to a GiftBox's ObjectBag.\n\nThe ObjectBag should use an index as the key (first object added has index 0, second has index 1, etc.)",
            "content": "In the previous course, we covered how to wrap a SuiFren object into a GiftBox object.\n```\nstruct GiftBox has key {\n    id: UID,\n    inner: SuiFren,\n}\n\nentry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n    let gift_box = GiftBox {\n        id: object::new(ctx),\n        inner: fren,\n    };\n    transfer::transfer(gift_box, tx_context::sender(ctx));\n}\n```\n\nLet's say we want to make the GiftBox even more of a pleasant surprise by allowing users who open it to potentially receive between 1 and 5 Frens. You might be tempted to create 5 SuiFren fields:\n```\nstruct GiftBox has key {\n    id: UID,\n    inner_1: SuiFren,\n    inner_2: SuiFren,\n    inner_3: SuiFren,\n    inner_4: SuiFren,\n    inner_5: SuiFren,\n}\n```\nThis just looks messy and doesn't really work! This would force a GiftBox to always contain exact 5 SuiFrens. What if we also allow a GiftBox to be a miss and possibly contain no SuiFrens? A better way would be to use a vector:\n```\nstruct GiftBox has key {\n    id: UID,\n    frens: vector<SuiFren>,\n}\n```\nThis is much cleaner! Now each GiftBox can contain any number of SuiFrens, including zero (empty vector). But what if we want to make it even more fun - each GiftBox can contain some number of Hats as well? We can create a second vector of Hats. But you see where we're going with this. If we want a GiftBox to contain a mixed collection of different types of objects, and vector wouldn't work here as it can only contain a single type of objects. It's better to use Object Bag instead!\n```\nuse sui::object_bag::{Self, ObjectBag};\n\nstruct MyBag has key {\n    id: UID,\n    object_bag: ObjectBag,\n}\n\npublic fun create_bag(ctx: &mut TxContext) {\n    transfer::transfer(MyBag {\n        id: object::new(ctx),\n        object_bag: object_bag::new(ctx),\n    }, tx_context::sender(ctx));\n}\n\npublic fun add_to_bag<SomeObject>(my_bag: &mut MyBag, key: String, object: SomeObject) {\n    object_bag::add(&mut my_bag.object_bag, key, object);\n}\n```\nUnder the hood, an ObjectBag uses dynamic object fields to store the objects of different types. The syntax is very similar to dynamic fields - to add an object to a Bag, you need a key of primitive type (such as index of type u64) or structs with copy/drop/store abilities and a value of struct type with key ability (object struct).\n\nThe object_bag module also offers other functions as well such as borrow, borrow_mut, contains (similar to dynamic_field::exists_), length (returns the number of objects in the bag) and is_empty."
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_table::{Self, ObjectTable};\n\n    struct GiftBox has key {\n        id: UID,\n        sui_frens: ObjectTable<u64, SuiFren>,\n        hats: ObjectTable<u64, Hat>,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            sui_frens: object_table::new(ctx),\n            hats: object_table::new(ctx),\n        };\n        let index = object_table::length(&gift_box.sui_frens);\n        object_table::add(&mut gift_box.sui_frens, index, fren);\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_table::length(&gift_box.hats);\n        object_table::add(&mut gift_box.hats, index, hat);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "8",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::object_table::{Self, ObjectTable};\n\n    // Update\n    struct GiftBox has key {\n        id: UID,\n        object_bag: ObjectBag,\n    }\n\n    entry fun wrap_fren(fren: SuiFren, ctx: &mut TxContext) {\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            object_bag: object_bag::new(ctx),\n        };\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, fren);\n    }\n\n    entry fun wrap_hat(gift_box: &mut GiftBox, hat: Hat) {\n        let index = object_bag::length(&gift_box.object_bag);\n        object_bag::add(&mut gift_box.object_bag, index, hat);\n    }\n}",
            "title": "Object Data Structures - ObjectTable",
            "quizTitle": "Using ObjectBag is still better, but just for the sake of practice:\n1. Replace ObjectBag in GiftBox with two separate ObjectTables, one for SuiFrens and one for Hats. The keys are string u64 (index).\n2. Update all functions to work with ObjectTables",
            "content": "Another cool data structure you can use to store objects is ObjectTable. This is different from ObjectBag and only allows a single type of objects. Although ObjectTable is more limited, it can be still be useful when user wants to assign specific key name for the different objects of the same type in the table.\n```\nuse sui::object_table::{Self, ObjectTable};\n\nstruct MyObject has key, store {\n    id: UID,\n}\n\nstruct MyTable has key {\n    id: UID,\n    table: ObjectTable<String, MyObject>,\n}\n\npublic fun create_table(ctx: &mut TxContext) {\n    transfer::transfer(MyTable {\n        id: object::new(ctx),\n        table: object_table::new(ctx),\n    }, tx_context::sender(ctx));\n}\n\npublic fun add_to_table(my_bag: &mut MyBag, key: String, object: MyObject) {\n    object_table::add(&mut my_bag.object_bag, key, object);\n}\n```\nUnder the hood, ObjectTable also uses dynamic object fields, similar to ObjectBag. When defining the object table field, we also need the exact types for the key and value.\n\nObjectTable also offers the same functions as ObjectHat: add, contains, remove, borrow, borrow_mut, length, and is_empty."
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    entry fun create_gift(ctx: &mut TxContext) {\n        let sui_fren = sui_fren::create_random(ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            sui_fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n\n    friend 0x123::fren_summer;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    public(friend) fun create_random(ctx: &mut TxContext): SuiFren {\n        let object_id = object::new(ctx);\n        let bytes = object::uid_to_bytes(&object_id);\n        let power = bcs::peel_u64(&mut bcs::new(bytes));\n        SuiFren {\n            id: object_id,\n            power,\n        }\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "9",
            "codeDef": "module 0x123::fren_summer {\n    use 0x123::sui_fren;\n\n    struct GiftBox has key {\n        id: UID,\n        inner: SuiFren,\n    }\n\n    // Add the new function here\n}\n\nmodule 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        power: u64,\n    }\n\n    // Add the new function here\n}",
            "title": "Object ids and address",
            "quizTitle": "Let's make the giftbox a bit more fun. Instead of wrapping an existing SuiFren, let's create one randomly when the GiftBox is created!\n1. Add a create_random public friend function to the sui_fren module that generates a SuiFren with a randomly generated power. create_random takes a single context param and returns the SuiFren object created.\n2. Add a new entry function create_gift to fren_summer module to create a gift box, call sui_fren::create_random to create the wrapped SuiFren object, and sends it the transaction's sender.\n3. Only fren_summer::create_gift can call sui_fren::create_random",
            "content": "We have been learning a lot of cool tricks we can do with objects. One fundamental aspect of object that we want to dive deeper into is object id.\n\nHave you wondered how an object's id and address are created? Technically an object's id and address are one and the same - they are unique identifiers that can allow developers to identify and fetch data from the objects. This is the case both on-chain (in Move) and off-chain (via web UI querying all data and fields for an object):\n```\npublic fun get_object_id_from_address(object_addr: address): ID {\n    object::id_from_address(address)\n}\n\npublic fun get_object_address(object: &MyObject): address {\n    object::id_to_address(&object.id)\n}\n```\nNote that the returned type for object's id is ID, which is different from the UID field that every object struct has. However, you can use object::uid_to_inner to convert a UID reference to ID. This allows comparing to check if an object is the same as a stored address.\n\nWhen an object is created, its id field is generated via object::new(ctx) where ctx is a mutable reference of type TxContext passed to the transaction by the Sui Virtual Machine (VM). Here's the code for it:\n```\npublic fun new(ctx: &mut TxContext): UID {\n    UID {\n        id: ID { bytes: tx_context::fresh_object_address(ctx) },\n    }\n}\n```\nAs you can see, behind the scene, a unique address is first generated with tx_context::fresh_object_address(ctx), then converted into bytes to create the object's id. fresh_object_address is a special type of function in Move - native function. Native functions are special as their implementation is written in Rust as part of the Move VM. This allows the function to run faster and have access to inner constructs of the VM. In this case, fresh_object_address can see the user's <b>transaction payload<b> and use it to generate a special address for the object. It also uses a counter that tracks how many objects have been created so far in the same transaction. fresh_object_address then hashes the tx payload and the counter and ensures that the result is unique even among the multiple objects created in the same transaction.\n\nOne interesting use case of the address generation process is to potentially use it as a source of randomness - the bytes generated from a newly created object's id can be used as a random value. This is typically because the hash of the transaction payload and counter often seems random (not following any pattern):\n```\nuse sui::bcs;\n\npublic fun get_random_value(ctx: &mut TxContext): u64 {\n    let object_id = object::new(ctx);\n    let bytes = object::uid_to_bytes(&object_id);\n    let random_number = bcs::peel_u64(&mut bcs::new(bytes));\n    object::delete(object_id);\n    random_number\n}\n```\nget_random_value can be called multiple times to create pseudo-random numbers (seemingly random). This could be used generally as a source of random values depending on use case, but is potentially dangerous to use as it could be manipulated by the user. They can change the expiration timestamp and other fields in the transaction in order to generate desired object ids and the resulting random number (for example to win an on-chain lottery). It could be safer to include the timestamp (from the system object Clock) but this still has risks:\n1. The user can still manipulate the random value to some extend (not as much as before as they have no control over the Clock object).\n2. The validators can partially manipulate the random value as well as they can set the timestamp of the Clock object to a specific value within a small range of margin of error.\n\nWe'll cover safer ways to generate random values in later courses."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Dynamic Fields and Objects owning Objects",
                "isCorrect": false
              },
              {
                "answer": "B. Objects owning Objects and Objects data structures",
                "isCorrect": false
              },
              {
                "answer": "C. Objects data structures and Dynamic Fields",
                "isCorrect": true
              }
            ],
            "lessonId": "10",
            "codeDef": "",
            "title": "Object Design Pitfall: Too Many Objects",
            "quizTitle": "What are some good approaches to reduce the number of objects an application creates?",
            "content": "Similar to what was discussed earlier regarding too many contract state objects, a common pitfall that some developers run into is to create too many objects. For example, in the case of a Laptop, you can technically create a separate object for each Laptop component such as screen, keyboard, hard drive, etc.:\n\n```\nstruct Laptop has key {\n    id: UID,\n    screen: Screen,\n    keyboard: Keyboard,\n    hard_drive: HardDrive,\n}\n\nstruct Screen has key, store {\n    id: UID,\n}\n\nstruct Keyboard has key, store {\n    id: UID,\n}\n\nstruct HardDrive has key, store {\n    id: UID,\n}\n```\nAs you can see, every component is a separate object. This is not necessary as Screen, Keyboard, and HardDrive objects are always wrapped into the Laptop object. They are never separated out into standalone objects. This kind of design only makes sense if we intentionally want to sell Keyboard as a separate component that can be integrated into another Laptop. This could be desired if we're running a hardware store, but this is a laptop store only.\n\nSome other issues with a Move module creating too many objects:\n1. It's hard to understand a transaction if it creates and changes too many objects. To users who view these transactions on an explorer UI, all they see is a very long list of all objects that are updated or have been created, and all of their associated fields/data. This can be overwhelming if the list has 10+ objects.\n2. If users need to interact with multiple of these objects, it can make the transaction complex to construct as the UIs would then need to find and pass the addresses for all of the objects involved.\n\nBeside using dynamic fields similar to what we covered in the lesson on managing state objects, developers can also use data structures such as ObjectBag and ObjectTable as covered earlier to store multiple objects if they really want to create many different types of objects. These can collect many objects into a single container object that can be easily understood and passed around."
          },
          {
            "codeSol": "",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "11",
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "",
            "content": "Different approaches to combine objects \n1. **Object wrapping**\n- Store objects within another objects (for example SuiFrens in GiftBoxes). This removes the wrapped objects (SuiFrens) from global storage. Off-chain web UI cannot look them up after wrapping. The object no longer has any owner. You can think of this almost as converting an object into a normal non-object struct instance.\n\n2. **Dynamic Fields** could be understood as invisible fields that are not explicitly defined on an object struct.\n- Can be used to store objects as well. This also removes the object from global storage. Ownership is also removed. Very similar to object wrapping, except that the field is added dynamically instead of explicitly defined in the struct.\n- In order to add dynamic fields to an object, you need a mutable reference to that object. Adding a dynamic field can be done simply via dynamic_field::add with the mutable object's id, the key and the value.\n- To read or modify a dynamic field, you need an immutable and mutable references to the object respectively and the field name (key). If the field name is a struct, you need the struct value itself, which is why the structs used as keys must have copy and drop abilities.\n- Dynamic object fields are preferred over dynamic fields to store objects dynamically. You should only use dynamic fields if you intentionally want to remove the objects from global storage.\n\n3. **Dynamic Object Fields**\n- Does not remove the object from global storage. Ownership is transferred to the special \"dynamic field object\" that is generally not easy to look up for Web UIs. In most cases, this has almost the same effect as forfeiting ownership of the object.\n\n4. **Objects own other objects**\n- Perfect use case is composable NFTs. This allows for powerful composition of NFTs together that make natural sense to users and is often seen in Web 3 Games that use NFTs.\n- Use when there is clear indication of object hierarchy in a complex application design with multiple types of objects.\n- There is a drawback which is it's harder to remove the owned object later. Therefore, objects owning objects is generally more useful if the relationship is rarely or never changed.\n\nInteresting object data structures: \n1. **Object bag**: a versatile data structure for storing a mixed collection of different object types - useful for applications requiring flexible and varied object compositions, such as randomized or composite NFTs.\n2. **Object table**: a data structure for storing collections of a single object type with specific key names - beneficial for applications that require structured and named collections of similar objects."
          }
        ]
      }
    ]
  },
  {
    "title": {
      "en": "Sui Standards",
      "vi": "Sui Standards"
    },
    "description": {
      "en": "This course dives into the standards on Sui such as NFTs and Coins, Sui’s own ERC-20 and ERC-1155 equivalents, and shows learners how to combine them into their applications. Different design patterns regarding managing NFTs from manual (creator-based) to automated (shared object based) are discussed with hand-on exercises to build a deeper understanding and intuition. This course will help both new developers and those already familiar with similar concepts on other networks to quickly pick up the unique concepts on Sui and how to build rich and flexible applications. This also sets the foundation for learners to later dive into courses that cover full e2e development and how to take a full application on other chains (Solidity/EVM, Sui/Move) and build similar yet much simpler applications on Sui, thanks to the expressibility and simplicity of the Object model.",
      "vi": "This course dives into the standards on Sui such as NFTs and Coins, Sui’s own ERC-20 and ERC-1155 equivalents, and shows learners how to combine them into their applications. Different design patterns regarding managing NFTs from manual (creator-based) to automated (shared object based) are discussed with hand-on exercises to build a deeper understanding and intuition. This course will help both new developers and those already familiar with similar concepts on other networks to quickly pick up the unique concepts on Sui and how to build rich and flexible applications. This also sets the foundation for learners to later dive into courses that cover full e2e development and how to take a full application on other chains (Solidity/EVM, Sui/Move) and build similar yet much simpler applications on Sui, thanks to the expressibility and simplicity of the Object model."
    },
    "modules": [
      {
        "title": "Coin",
        "lesson": [
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Coin has more functions",
                "isCorrect": false
              },
              {
                "answer": "B. Coin has built-in tracking",
                "isCorrect": false
              },
              {
                "answer": "C. Coin offers full implementation developers can use without writing much code",
                "isCorrect": true
              }
            ],
            "lessonId": "1",
            "codeDef": "",
            "title": "Introduction to Tokens, ERC-20, and Coins",
            "quizTitle": "Why is the Coin standard on Sui better than ERC-20 on EVM chains?",
            "content": "In previous courses, we have covered most of the fundamental concepts that developers need to get started in Move. In this lesson, we will dive into a more practical topic and one of the two most common types of core building blocks in blockchains - Tokens.\n\nTokens play a pivotal role in the world of cryptocurrencies, serving as digital representations of value or assets. They are akin to digital certificates that grant ownership or access to various assets, both tangible and virtual, all recorded securely on a blockchain. One prominent standard for these tokens on the Ethereum blockchain is ERC-20.\n\n**Tokens** These digital assets exist solely in electronic form on blockchains, decentralized digital ledgers. They represent something valuable, whether it's a cryptocurrency, a share in a company, a voting right in a decentralized organization, or even a virtual collectible item in a game. Tokens can be transferred or traded on the blockchain, their ownership and transactions transparently recorded. Some tokens, thanks to smart contracts, automate processes like dividend distribution or access to services within specific ecosystems. Initial Coin Offerings (ICOs) often use tokens as a means of fundraising, where investors purchase them with the expectation of future value appreciation.\n\n**ERC-20** One of the first specifications of how a Token should be implemented, the ERC-20 standard defines a set of interface functions that tokens on the Ethereum blockchain must adhere to. These functions provide a common framework for interacting with tokens and ensure interoperability between different applications and wallets. Here's a summary of the most important ERC-20 interface functions:\n\n1. `totalSupply()`: This function returns the total supply of tokens in circulation.\n2. `balanceOf(address _owner)`: It allows you to check the balance of tokens owned by a specific Ethereum address.\n3. `transfer(address _to, uint256 _value)`: This function enables the transfer of a specified amount of tokens from the sender's address to another address.\n\nAlthough the ERC-20 standard is simple to implement, all developers would need to provide their own implementation and end up writing almost the same code again and again. This is due to a limitation in the Ethereum network (and many other EVM networks) that there are no core smart contracts that can serve as libraries for developers to use, similar to the core libraries in many languages such as Java.\n\nSui Move solves this issue by defining the [Coin standard](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move) directly at 0x2 and allowing developers to directly define and manage tokens easily without having to rewrite the implementation every time. A Token on the Sui network is called a Coin.\n\nAnother key design principle in how Coin is designed is to reflect the natural design of money in the real word. When someone receives $1 for example, they can put this $1 into their pocket and retrieve it later. This is not the case with token balances in EVM chains where the balances are all recorded inside the smart contract that defines the USDC token (dollar-pegged token). This centralized balance design more resembles a bank deposit system where all balances are only defined in the bank system. This creates a lot of confusion for users who are new to crypto as they think their wallets (e.g. hardware wallets) actually hold the various tokens inside them.\n\nIn Sui Move, **Coin** is more natural and easier to understand - when a user receives Coins, the Coins are actually stored in an object (can be thought of as a wallet) that belongs to that user. They can later easily retrieve Coins from this object and use them however they want."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "2",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    // Add the new struct here\n\n    // Update\n    fun init(ctx: &mut TxContext) {\n    }\n}",
            "title": "SuiFren Candy - Creating a new Coin type",
            "quizTitle": "Let's make SuiFrens more fun and introduce a Candies as a coin that can be fed to SuiFrens to increase their fighting power.\n1. Add a new Candy coin type to the `sui_fren` module\n2. Update the init to create the new Candy Coin. For now, let's send both the metadata and TreasuryCap objects to the sender\nThe Candy coin's metadata is as follows:\n* \"CANDY\" as the symbol\n* SuiFren Candy\" as the name\n* \"Candies to level up SuiFren\" as the description\n* No logo (option::none())",
            "content": "In Sui Move, there's only a single module (smart contract) that developers need to call from their call to create and manage their coins. In order to differentiate between different types of coins that different developers create, Coin uses generics (type arguments):\n\n```\n/// Get immutable reference to the balance of a coin.\npublic fun balance<T>(coin: &Coin<T>): &Balance<T> {\n    &coin.balance\n}\n```\nThe above function is used to check the balance of a user's owned Coin wallet object. Note that there's a ```<T>``` at the end of the function name. This is a type argument that specifies which coin wallet the function is being called for, which can be ```Coin<MYCOIN>``` or ```Coin<YourCoin>```.\n\n In order to create a coin, developers first need to define this Coin type as a struct in their module:\n```\nmodule my_coin::my_coin {\n    struct MYCOIN has drop {}\n}\n```\nThis is similar to [how the SUI coin is also defined](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/sui.move).\n\nThe developers can then create the new coin by calling `coin::create_currency`, usually as part of the init function because you need a one-time witness (otw) object of the Coin type (MYCOIN in this case):\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n```\n`coin::create_currency` returns a metadata object that stores information about the coin: Symbol (what the Coin will be displayed shortly as), name, description and logo URL. This allows off-chain components such as Web UI to look this information up and display them. The developers can choose to freeze the metadata object, which no longer allows the name/symbol/etc. to change or keep it owned and transfer to an account for later management (More on this in a later lesson).\n\n`coin::create_currency` also returns the TreasuryCap object that can be used to manage the coins. We'll talk more about this in a later lesson.\n\nWith the Coin now created, developers can use ```NYCOIN``` as the Coin type argument when calling coin functions, for example:\n \n```\npublic fun my_coin_balance(coin: &Coin<MYCOIN>): &Balance<MYCOIN> {\n    // <MYCOIN> is technically not required here as the type can be inferred.\n    // It's just included explicitly for demonstration purposes.\n    coin::balance<MYCOIN>(coin)\n}"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    entry fun mint(treasury_cap: &mut TreasuryCap<CANDY>, amount: u64, ctx: &mut TxContext) {\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "3",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    // Add the mint function here\n}",
            "title": "Minting SuiFren Candies with the TreasuryCap object",
            "quizTitle": "Add a `mint_candy` entry function to the `sui_fren` module that mints Candy coins to the sender. For now only the `TreasuryCap<Candy>` owner can call it. The mint function should takes the treasury cap object, an amount of type `u64` and any other system object arguments as needed.",
            "content": "In the previous lesson, we created our first `Coin` and temporarily transfer to the `TreasuryCap` object to the sender (deployer of the module). With this `TreasuryCap`, this account can now mint `MYCOIN` coins:\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",\n        option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n\nentry fun mint(treasury_cap: &mut TreasuryCap<MYCOIN>, ctx: &mut TxContext) {\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nThere are four important things to call out:\n1. `coin::mint` creates a new Coin (wallet) object. This means that existing balances in other wallets of the user will not change.\n2. If you recall, owned objects are verified when passed in as arguments to transaction and only their owners can do so. In this case, only the account that owns `TreasuryCap<MYCOIN>` can call mint.\n3. `TreasuryCap` has a type argument too (`MYCOIN`). This specifies which coin type the treasury cap manages.\n4. `coin::mint` doesn't need to specify MyCoin as the type argument as the compiler can infer that from the `treasury_cap` (of type `TreasuryCap<MYCOIN>`).\n\nAlso note that the type of the `TreasuryCap` is a fully qualified type name - `0x123::my_coin::MYCOIN` if our module's address is `0x123` in the example. This means if someone else creates a `MYCOIN` struct in their module, that would be treated as a completely different coin even if the struct name is the same. Beside `coin::mint`, developers can also use `coin::mint_and_transfer` to directly mint to a specific account.\n\nAnother common pattern is to mint the initial allocation of coins in the `init` function:\n```\nuse std::string;\nuse sui::url;\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    coin::mint_and_transfer(treasury_cap, 1000000, tx_context::sender(ctx), ctx);\n    \n    transfer::public_freeze_object(metadata);\n    transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n}\n```\nThis allows developers to create an initial amount of coins for circulation. They can optionally implement a mint function to create more coins later."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "4",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    // Add the new struct here\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    entry fun mint(treasury_cap: &mut TreasuryCap<Candy>, amount: u64, ctx: &mut TxContext) {\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n}",
            "title": "Programmatic Coin minting",
            "quizTitle": "Create a `CandyTreasuryCapHolder` object struct and update `sui_fren::init` and mint functions to use it to allow users to freely mint candies.",
            "content": "We have learnt how to use the generated `TreasuryCap<CoinType>` object to mint the coins. However, only the `TreasuryCap` owner can call it. What if we want to allow users to freely mint coins (may be up to a certain limit)? How would this work?\n\nIf you look at how the `TreasuryCap` object struct is defined, it has the store ability:\n```\n/// Capability allowing the bearer to mint and burn\n/// coins of type `T`. Transferable\nstruct TreasuryCap<phantom T> has key, store {\n    id: UID,\n    total_supply: Supply<T>\n}\n```\nThis means, it can be stored in other structs and objects! So the solution here would be to wrap it in a shared object that anyone can access and provide as an argument to the mint function:\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct TreasuryCapHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n}\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    transfer::public_freeze_object(metadata);\n    \n    let treasury_cap_holder = TreasuryCapHolder {\n        id: object::new(ctx),\n        treasury_cap,\n    };\n    transfer::share_object(treasury_cap_holder);\n}\n\nentry fun mint(treasury_cap_holder: &mut TreasuryCapHolder, ctx: &mut TxContext) {\n    let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nIn the example above, we wrap `TreasuryCap<MYCOIN>` inside a shared `TreasuryCapHolder` object. Anyone can now passes `&mut TreasuryCapHolder` to the mint function and mint `MYCOIN` coins freely. In practice, the developers should add some restrictions such as how many coins can be minted in total, how many each user can mint, allowlist-based control, etc.\n\nAs discussed in the `Object` courses, beside wrapping the `TreasuryCap` object into another holder object, we can also leverage dynamic fields, dynamic object fields or even object ownership to retain the `TreasuryCap`. However, wrapping is generally preferred because of its simplicity when accessing."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    entry fun transfer_half_candies(from: &mut Coin<CANDY>, to: &mut Coin<CANDY>, ctx: &mut TxContext) {\n        let half_coins = coin::take(coin::balance_mut(from), coin::balance(from) / 2, ctx);\n        coin::put(coin::balance_mut(to), half_coins);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "5",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<Candy>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    // Add the new function here\n}",
            "title": "Coin vs Balance - take, put, transfer, zero, destroy_zero",
            "quizTitle": "Add a `transfer_half_candies` entry function that transfers half of the candies in a `Coin` object (named from) to another `Coin` object (named to)",
            "content": "One of the common confusions new developers often have about `Coin` in Sui is that there's a `Balance` object that looks similar:\n```\nstruct Coin<phantom T> has key, store {\n    id: UID,\n    balance: Balance<T>\n}\n\n/// Storable balance - an inner struct of a Coin type.\n/// Can be used to store coins which don't need the key ability.\nstruct Balance<phantom T> has store {\n    value: u64\n}\n```\nWhat exactly is the difference between `Coin` and `Balance` and when should we use either? The best comparison here is:\n1. `Coin` object is more like a wallet. The `Coin` wallet has an inner balance and cash (`Balance`) can be taken out of it and deposited into another `Coin` wallet object.\n2. `Balance` is like cash only. It cannot be stored alone and needs to be put into wallets or pockets. Developers can choose to create their own \"pocket\" objects to store Balance\n\nTechnically, since the `Coin` object  also has the store ability, developers can put the entire `Coin` wallet into their own custom objects as well. However, it is quite strange to do so and `Balance` should be used in that case as `Coin` is already like a container. Furthermore, putting (wrapping Coin wallet objects) into another object effectively removes it from object global storage like we discussed in the `Object` courses. This is generally not desired as it can make wallets \"disappear\".\n\n```\nentry fun transfer_coins(from_wallet: &mut Coin<MYCOIN>, amount: u64, to_wallet: &mut Coin<MYCOIN>, ctx: &mut TxContext) {\n    let cash = coin::take(coin::balance_mut(from_wallet), amount, ctx);\n    coin::put(coin::balance_mut(to_wallet), cash);\n}\n```\nIn the example above, we take some coins from the `from_wallet` Coin object and deposit it into the `to_wallet` Coin object. Note that only the owner of both `from_wallet` and `to_wallet` can call `transfer_coins`. We need to use `coin::balance_mut` to get to the inner balance of a `Coin` object as a struct fields are not visible outside of the defining module (coin in this case).\n\nThe `Coin` module in Sui doesn't offer direct transfer from one `Coin` object to another. Developers would need to manually use take + put to accomplish a transfer.\n\nSome other functions of notes in the coin module are:\n1. `balance(&Coin)`: returns the balance of a `Coin` object.\n2. `zero()` which creates a Coin object with zero balance (empty wallet)\n3. `destroy_zero()` - destroys an empty wallet. A wallet with non-zero balance cannot be destroyed and you'd need to move the coins there somewhere else first."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Coin can be a standalone object but Balance cannot",
                "isCorrect": true
              },
              {
                "answer": "B. Coin doesn't have the store ability while Balance does",
                "isCorrect": false
              },
              {
                "answer": "C. Balance has the key ability while Coin doesn't",
                "isCorrect": false
              }
            ],
            "lessonId": "6",
            "codeDef": "",
            "title": "More Balance functions",
            "quizTitle": "What's the technical difference between `Coin` and `Balance`?",
            "content": "The `sui::balance` module where `Balance` object is defined also offers a few functions of note:\n\nvalue returns the number of coins in a `Balance` object:\n```\n/// Get the amount stored in a `Balance`.\npublic fun value<T>(self: &Balance<T>): u64 {\n    self.value\n}\n```\n\njoin takes a mutable balance and another balance and added the second balance to the first:\n```\n/// Join two balances together.\npublic fun join<T>(self: &mut Balance<T>, balance: Balance<T>): u64 {\n    let Balance { value } = balance;\n    self.value = self.value + value;\n    self.value\n}\n```\n\n`split` extracts an amount of coins from a mutable balance and creates a second balance:\n```\n/// Split a `Balance` and take a sub balance from it.\npublic fun split<T>(self: &mut Balance<T>, value: u64): Balance<T> {\n    assert!(self.value >= value, ENotEnough);\n    self.value = self.value - value;\n    Balance { value }\n}\n```\n\n`withdraw_all` is similar to split but extracts all of the coins from the mutable balance, leaving it empty:\n```\n/// Withdraw all balance. After this the remaining balance must be 0.\npublic fun withdraw_all<T>(self: &mut Balance<T>): Balance<T> {\n    let value = self.value;\n    split(self, value)\n}\n```\n\nWith these different functions, developers can create more complex operations on balances after they're taken from a user's owned `Coin` object. Balances can be split and joint to divide an amount of coins into smaller portions and send them to different wallets. This is commonly seen when processing fees for example:\n\n```\n/// Withdraw all balance. After this the remaining balance must be 0.\npublic fun trade(wallet: &mut Coin<Sui>, amount: u64) {\n    let coins_to_trade = balance::split(coin::balance_mut(wallet), amount);\n    // 1% fee.\n    let fees = balance::split(&mut coins_to_trade, amount / 100);\n    // Deposit the fee somewhere and continue with the trade.\n}\n```"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n        power: u64\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    entry fun feed_candies(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, sui_fren: &mut SuiFren, candies: Coin<CANDY>) {\n        let amount = coin::value(&coins);\n        sui_fren.power = sui_fren.power + amount;\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::burn(treasury_cap, coins);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "7",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n        power: u64\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun mint(treasury_cap_holder: &mut CandyTreasuryCapHolder<CANDY>, amount: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n    }\n\n    // Add the new function here\n}",
            "title": "Burning Coins",
            "quizTitle": "Add a feed_candies function that take a `SuiFren`, a `Coin<CANDY>`, add the amount to the `SuiFren`'s power, and burn the candies.",
            "content": "In the previous lessons, we have discussed how `Coins` can be minted with the `TreasuryCap`.\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct TreasuryCapHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n}\n\nentry fun mint(treasury_cap_holder: &mut TreasuryCapHolder, ctx: &mut TxContext) {\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    let coins = coin::mint(treasury_cap, 1000, ctx);\n    // Do something with the coins\n}\n```\nWe can burn using `TreasuryCap` as well:\n```\nentry fun burn(treasury_cap_holder: &mut TreasuryCapHolder, coins: Coin<MYCOIN>) {\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    coin::burn(treasury_cap, coins);\n}\n```\n\n`coin::burn` will burn all coins in the given `Coin` object and also destroys the `Coin` object itself. This is equivalent to burning the entire wallet. If developers instead just want to burn a specific amount from a Coin object, they need to extract that amount out first and just burn those specific coins:\n```\nentry fun burn(treasury_cap_holder: &mut TreasuryCapHolder, coins: &mut Coin<MYCOIN>, amount: u64, ctx: &mut TxContext) {\n    let coins_to_burn = coin::take(coin::balance_mut(coins), amount);\n    let treasury_cap = &mut TreasuryCapHolder.treasury_cap;\n    coin::burn(treasury_cap, coins_to_burn);\n}\n```"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n        metadata: CoinMetadata<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun update_icon_url(holder: &mut CandyTreasuryCapHolder, new_icon_url: String) {\n        let metadata = &mut holder.metadata;\n        let treasury_cap = &holder.treasury_cap;\n        coin::update_icon_url(treasury_cap, metadata, new_icon_url);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "8",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::string::String;\n    use std::vector;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_transfer(metadata, tx_context::sender(ctx));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n}",
            "title": "Updating Coin metadata",
            "quizTitle": "Add a metadata field to the `CandyTreasuryCapHolder` object and update the `init` function accordingly. Add a `update_icon_url` entry function that allows changing the Candy coin's icon url.\nHint: You can use `option`",
            "content": "When we created `MyCoin` earlier, we froze the metadata object returned. This would not allow for any changes to the metadata (decimals/symbol/name/description/logo url) in the future.\n\nSpeaking of decimals, we never really explained what it's for. `Decimals` are often used for Coins/tokens in order to reduce rounding errors. Most smart contract languages, including Move, do not have fractional numbers and all math operations are integer-based. This means 5 / 2 = 2 in Move, leading to a rounding error of 1. If there are no decimals, people would be losing a lot of money left and right. A decimals of at least 6 is often used in crypto and can be sometimes as high as 18 (1 coin = 10^18 units). In most cases, 9 is more than sufficient to make the rounding error small and negligible to users.\n\nBack to the metadata object, if you think there could be a chance you might want to change the coin's metadata in the future, you should not freeze it and instead transfer to an admin account for safekeeping. In the future, you can then leverage the different functions in coin to update the metadata you want:\n\n```\n/// Update name of the coin in `CoinMetadata`\npublic entry fun update_name<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, name: string::String\n) {\n    metadata.name = name;\n}\n\n/// Update the symbol of the coin in `CoinMetadata`\npublic entry fun update_symbol<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, symbol: ascii::String\n) {\n    metadata.symbol = symbol;\n}\n\n/// Update the description of the coin in `CoinMetadata`\npublic entry fun update_description<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, description: string::String\n) {\n    metadata.description = description;\n}\n\n/// Update the url of the coin in `CoinMetadata`\npublic entry fun update_icon_url<T>(\n    _treasury: &TreasuryCap<T>, metadata: &mut CoinMetadata<T>, url: ascii::String\n) {\n    metadata.icon_url = option::some(url::new_unsafe(url));\n}\n```\nNote that decimals is a special case and there's no update function for it. This is because decimals is a fundamental property of a coin and can change everyone's balance if it's updated. Therefore, for safety and simplicity, Sui's Coin standard doesn't allow modifying decimals.\n\nIn order to call an update function such as `coin::update_symbol`, the caller needs to have access to both `TreasuryCap` and `metadata` object. Note that both `TreasuryCap` and `Metadata` structs have the store ability so we can store them somewhere that allows programmatic access and modification later on:\n\n```\nuse std::string;\nuse sui::url;\n\nstruct MYCOIN has drop {}\n\nstruct CoinDataHolder has key {\n    id: UID,\n    treasury_cap: TreasuryCap<MYCOIN>,\n    metadata: CoinMetadata<MYCOIN>,\n}\n\nfun init(otw: MYCOIN, ctx: &mut TxContext) {\n    let (treasury_cap, metadata) = coin::create_currency(\n        otw,\n        9,\n        b\"MYC\",\n        b\"MyCoin\",\n        b\"My Coin description\",                       option::some(url::new_unsafe(string::utf8(bb\"https://mycoin.com/logo.png\"))),\n        ctx,\n    );\n    \n    let treasury_cap_holder = TreasuryCapHolder {\n        id: object::new(ctx),\n        treasury_cap,\n        metadata,\n    };\n    transfer::share_object(treasury_cap_holder);\n}\n\nentry fun update_symbol(holder: &mut CoinDataHolder, new_symbol: String) {\n    let metadata = &mut holder.metadata;\n    let treasury_cap = &holder.treasury_cap;\n    coin::update_symbol(treasury_cap, metadata, new_symbol);\n}\n```\nIn the example above, we wrap both the `TreasuryCap` and the `Metadata` objects into a shared object that can be accessed by anyone later to update coin metadata. In practice, developers can add logic that require the sender to be a specific admin address to make sure suers don't arbitrarily update coin metadata."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Balances cannot be joint while Coins can",
                "isCorrect": false
              },
              {
                "answer": "B. Coins cannot be joint while Balances can",
                "isCorrect": false
              },
              {
                "answer": "C. Newly created Coins can be sent to accounts while Balances have to be merged",
                "isCorrect": true
              }
            ],
            "lessonId": "9",
            "codeDef": "",
            "title": "Managing multiple Coin objects - join and split",
            "quizTitle": "What's the difference between `Coin` and `Balance` when it comes to merging and splitting?",
            "content": "Image that each time you interact with an application and it creates a new `Coin` object to store the refund or payment to your account. After a day of interacting with them, you end up with 100 different `Coin` objects. Now your coins are both split into 100 different parts and you no longer have enough coins to do more interactions. What do you do now?\n\nThere are two solutions to this:\n1. Applications and developers avoid creating new coins as much as possible unless needs be. They should instead make an attempt to take an existing Coin from the user to combine the refunds/payments into.\n2. Users can merge the coins together, as part of the last step in their PTB (Programmable Transaction Block).\n\nIn Move, coins can also be easily split and joint with `coin::split` and `coin::join`\n```\npublic fun trade(input_coins: &mut Coin<SUI>) {\n    let refund_coins - ...;\n    coin::join(input_coins, refund_coins);\n}\n```\nCoins and also be split. However, remember the created `Coin` either has to merged into some other coins or they need to be sent to an account. This is because `Coin` doesn't have the store ability and cannot be dropped at the end of the function.\n```\npublic fun split_and_send(input_coins: &mut Coin<SUI>, ctx: &TxContext) {\n    let refund_coins = coin::split(input_coins, 1000);\n    transfer::public_transfer(refund_coins, tx_context::sender(ctx));\n}\n```\nYou might also notice that this is similar to `balance::split` and `balance::join` that we learnt about in previous lessons. Except for of course that these functions deal with different types - Coin and Balance, they are almost identical in behavior in Move. However, coin's functions are used more in PTB (Programmable Transaction Blocks) as applications often return Coins instead of Balances while `balance::split` and `balance::join` are used more as part of Move flows."
          },
          {
            "codeSol": "module 0x123::candy_drop {\n    struct CANDY has drop {}\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    struct MintCandiesEvent has copy, drop {\n        user: address,\n        amount: u64,\n    }\n\n    fun init(otw: CANDY, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            otw,\n            9,\n            b\"CANDY\",\n            b\"SuiFren Candy\",\n            b\"Candies to level up SuiFren\"\n            option::none(),\n            ctx,\n        );\n        transfer::public_freeze(metadata));\n\n        let treasury_cap_holder = CandyTreasuryCapHolder {\n            id: object::new(ctx),\n            treasury_cap,\n        };\n        transfer::share_object(treasury_cap_holder);\n    }\n\n    entry fun mint(holder: &mut CandyTreasuryCapHolder, amount: u64) {\n        let sender = tx_context::sender(ctx);\n        assert!(is_allowlisted(sender), ENOT_NOT_ALLOWLISTED);\n        let treasury_cap = &mut treasury_cap_holder.treasury_cap;\n        coin::mint_and_transfer(treasury_cap, 1000, tx_context::sender(ctx), ctx);\n        event::emit(MintCandiesEvent {\n            sender,\n            amount,\n        })\n    }\n\n    fun is_allowlisted(user: address, ctx: &mut TxContext): bool {\n        // You don't need to implement this\n    } \n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "10",
            "codeDef": "module 0x123::candy_drop {\n    // Implement here\n\n    fun is_allowlisted(user: address): bool {\n        // You don't need to implement this\n    } \n}",
            "title": "Candy drop - a simple Coin airdrop module",
            "quizTitle": "Let's put this all into a simple airdrop module for our `SuiFren` candies:\n1. Create a new module `candy_drop` that defines the `Candy` coin (we'll keep it here instead of in `sui_fren`)\n2. Implement an init function to create the coin and store the `TreasuryCap`. `Metadata` should be frozen as we'd not change anything later.\n3. Add a mint entry function that allows users to freely mint a given amount (`u64`) of candies if they're added to an allowlist of where the airdrop can be added in. You don't have to implement the allowlist, just assume there's an existing function called `is_allowlisted` that takes an address and returns true if the address is on the allowlist. We'll cover how to implement this in a later lesson.\nYou can use `assert!(condition, ENOT_NOT_ALLOWLISTED);`\n5. The mint function should also emit an event at the end of type `MintCandiesEvent` with two fields - `user` (set to the transaction sender) and `amount`.",
            "content": "We have gone through a lot of useful concepts about Coins in the previous lessons:\n1. Creating a new coin with `coin::create_currency` returns the `TreasuryCap` used to mint/burn/update metadata and the metadata objects.\n2. `Coins` are like wallets and can split, joint. Balances are like cash and can be moved from one `Coin` to another\n3. `TreasuryCap` and `Metadata` objects can both be stored for programmatic access without the need for a single owner account to keep having to sign transactions"
          },
          {
            "codeSol": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n    use sui::coin::{Self, Coin};\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n        candies: Balance<CANDY>,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let treasury_cap = &mut holder.treasury_cap;\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n            candies: coin::mint(treasury_cap, amount, ctx),\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n\n    entry fun open_gift(gift_box: GiftBox, ctx: &mut TxContext) {\n        let GiftBox { id, sui_fren, candies } = gift_box;\n        object::delete(id);\n        transfer::public_transfer(sui_fren, tx_context::sender(ctx));\n        let candy_coins = coin::from_balance(candies, ctx);\n        transfer::public_transfer(candy_coins, tx_context::sender(ctx));\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "11",
            "codeDef": "module 0x123::fren_summer {\n    use sui::object::{Self, UID};\n    use 0x123::sui_fren::{Self, SuiFren};\n    use sui::tx_context;\n\n    struct CANDY has drop {}\n\n    struct GiftBox has key {\n        id: UID,\n        sui_fren: SuiFren,\n    }\n\n    struct CandyTreasuryCapHolder has key {\n        id: UID,\n        treasury_cap: TreasuryCap<CANDY>,\n    }\n\n    entry fun create_gift(holder: &mut CandyTreasuryCapHolder, generation: u64, birthdate: u64, attributes: vector<String>, num_coins: u64, ctx: &mut TxContext) {\n        let fren = sui_fren::create(generation, birthdate, attributes, ctx);\n        let gift_box = GiftBox {\n            id: object::new(ctx),\n            inner: fren,\n        };\n        transfer::transfer(gift_box, tx_context::sender(ctx));\n    }\n}",
            "title": "Storing Balance and Coin in custom objects",
            "quizTitle": "1. Update the `GiftBox` object we created in the previous course to contain a single `SuiFren` and an amount of `candies (coins)` as `Balance<CANDY>`\n2. Update `create_gift` function to generate the indicated amount of candies in the gift box\n3. Add a `open_gift` function that destroys the gift box and sends both the `SuiFren` and the candies to the sender.",
            "content": "As discussed in previous lessons, both `Coin` and `Store` objects have the store ability and can be embedded inside other structs (\"wrapped\" in Coin's case since it's an object struct).\n```\nstruct MyObjectWithBalance has key {\n    id: UID,\n    balance: Balance<MYCOIN>,\n}\n\nstruct MyObjectWithCoin has key {\n    id: UID,\n    coins: Coin<MYCOIN>,\n}\n```\nAs discussed in the previous lesson, it might be more common to store `Balance` instead of `Coin`. But why would someone store `Balance` in a custom struct? The most common reason for this structure is to have coins that are programmatically owned by a smart contract or module. For example, users can be building a marketplace where users can list their own `Coins` to trade against other `Coins`. In this case, when a buyer comes along, we don't want the seller to also have to sign the buy transaction. It's a lot smoother if the buyer just signs and the trade automatically happens - they receive the coins they're buying and the coins they're paying with are taken out of their wallet (`Coin` object).\n```\nstruct Listing<phantom CoinType> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<CoinType>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<CoinType>(listing: Listing<CoinType>, payment: Coin<SUI>): Balance<CoinType> {\n    let Listing<CoinType> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nIn the example above, the seller can create a listing to include the coins they want to sell directly as a shared object. The listed coins are included in the listing object. Once a buyer comes along with the payment, the listing can be destroyed to return the inner listed coins as `Balance<CoinType>`. In the PTB (Programmable transaction block), the seller can choose to merge `Balance<CoinType>` into any of the Coin objects of the same type they own.\n\nNote that `CoinType` is preceded by the phantom keyword. This is required because none of Listing's fields is directly of type CoinType. We see `Balance<CoinType>` but `CoinType` is used as a generic here instead of a direct type. In short, the phantom keyword is required for a struct if the type is only used as a generic in one or more of its fields.\n\nNote that we use the generic `<CoinType>` here so this system would work for any coin types!"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Coin has more functions",
                "isCorrect": false
              },
              {
                "answer": "B. Coin has built-in tracking",
                "isCorrect": false
              },
              {
                "answer": "C. Coin offers full implementation developers can use without writing much code",
                "isCorrect": true
              }
            ],
            "lessonId": "12",
            "codeDef": "",
            "title": "The SUI Coin and paying gas and Sponsored Transaction",
            "quizTitle": "What can a user do if they don't have enough Sui balance to pay for gas for their transaction?",
            "content": "We only briefly covered Coin<SUI> in the previous lessons but didn't delve much into it. Let's explore what SUI coin is in this lesson. In short, the main purpose of SUI on the Sui network is to pay \"gas\" for transactions and as a currency.\n\nThe SUI coin's `TreasuryCap` is kept inside the Sui framework for the purpose of issuing rewards to the network as part of their [tokenomics](https://docs.sui.io/concepts/tokenomics). No single user or account has access to the `TreasuryCap` and minting/burning of the Sui coins is governed by the Sui network via the \"system\" smart contracts deployed at `0x3`.\n\n# Gas\nIn the blockchain world, **gas** refers to the fee required for performing actions, like transactions or smart contracts, on the network. It's a vital concept because it ensures that resources are allocated efficiently and helps prioritize activities by attaching costs to them. Users pay gas fees to compensate for the computational resources needed to execute their operations, and miners prioritize transactions with higher gas fees for processing. This mechanism maintains the blockchain's reliability and security.\n\nGas costs for transactions in blockchain differ significantly from the way cloud infrastructure costs are handled in the web 2.0 (centralized) world. Here are the key distinctions:\n\n1. **Decentralization vs. Centralization**: Blockchain operates in a decentralized manner, with no single entity or company controlling the network. In contrast, web 2.0 services typically rely on centralized cloud infrastructure provided by companies like Amazon Web Services (AWS), Google Cloud, or Microsoft Azure.\n2. **User-Paid vs. Company-Paid**: In blockchain, users pay gas fees directly when they perform actions on the network, such as making transactions or interacting with smart contracts. These fees ensure that users bear the costs of their activities. In web 2.0, companies usually cover the expenses of their cloud infrastructure, and users access services without direct cost for most operations.\n3. **Incentives**: Gas fees in blockchain serve as incentives for miners (or validators) to process transactions and maintain the network's security and integrity. In web 2.0, cloud infrastructure costs are typically covered by companies as part of their operational expenses, and there's no direct financial incentive for users or third parties to participate in infrastructure maintenance.\n4. **Transparency and Control**: Blockchain gas fees are transparent and can be controlled by users based on the urgency of their transactions. Users can adjust gas prices to prioritize faster confirmation times or lower costs. In web 2.0, cloud infrastructure costs are often hidden from end-users, and they have limited control over the underlying infrastructure.\n5. **Resource Allocation**: Gas fees in blockchain allocate computational resources fairly and efficiently by ensuring that users who consume more resources pay higher fees. In web 2.0, resource allocation is typically managed by centralized cloud providers, and users don't have direct visibility into or control over resource allocation decisions.\n\nIn summary, gas in blockchain represents a user-centric, cost-bearing mechanism that maintains the decentralized and transparent nature of blockchain networks. In contrast, web 2.0 relies on centralized cloud infrastructure, where companies absorb the costs, and users have less control and transparency over the underlying infrastructure.\n\n# Other uses for SUI token\nBeside gas, a network token (main token of a network) such as SUI on the Sui blockchain can also act as a form of currency as it's likely the currency with the most liquidity (amount of funds) available. This means it can be:\n1. An intermediate value to exchange between other application-specific coins or tokens.\n2. A value for users to hold their funds\n3. Participate in securing the Sui network by staking (locking) Sui and running a validator node\n\nThe total supply of SUI is capped at 10,000,000,000 (ten billion tokens). A share of SUI total supply became liquid at Mainnet launch, with the remaining tokens vesting over the coming years, or distributed as future stake reward subsidies.\n\n# Paying for gas\nWhen sending transactions on the Sui network, users have to specify the Coin object where gas would be paid from. We talked about how users can have multiple Coin objects and can use `coin::split` and `coin::join` in combination with `transfer::public_transfer` to manage them. In the context of gas, users can also use `pay::split` which combines `coin::split` and `transfer::public_transfer` for users' convenience:\n\n```\n/// Split coin `self` to two coins, one with balance `split_amount`,\n/// and the remaining balance is left is `self`.\npublic entry fun split<T>(\n    self: &mut Coin<T>, split_amount: u64, ctx: &mut TxContext\n) {\n    keep(coin::split(self, split_amount, ctx), ctx)\n}\n```\nUIs can just use a combination of these when constructing the transactions on behalf of the users to effectively manage their SUI balances to pay for gas:\n1. If users have their SUI funds split between multiple Coin objects and no single one has enough to pay for gas, they can combine them.\n2. If users want to explicitly designate a Coin object as their gas fund, they can split it from where most of their funds are held.\n\n# Sponsored transactions\n\nA Sui sponsored transaction is one where a Sui address (the sponsor's) pays the gas fees for a transaction that another address (the user's) initializes. You can use sponsored transactions to cover the fees for users on your site or app so that they don't get charged for them. This removes a significant obstacle that web 2.0 users encounter when entering web3, as they often have to purchase tokens to perform a transaction on chain. For example, you could sponsor gamers' early transactions to increase conversion rates.\n\nMore details can found [here](https://docs.sui.io/concepts/transactions/sponsored-transactions)."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Coin has more functions",
                "isCorrect": false
              },
              {
                "answer": "B. Coin has built-in tracking",
                "isCorrect": false
              },
              {
                "answer": "C. Coin offers full implementation developers can use without writing much code",
                "isCorrect": true
              }
            ],
            "lessonId": "13",
            "codeDef": "",
            "title": "Advanced: Handling multiple coin types",
            "quizTitle": "Why is the keyword phantom required in the `Listing` object?",
            "content": "In a previous lesson, we implemented a simple `Coin` market where sellers list the coins they want to sell and buyers can buy from the listings automatically with SUI and without the seller having to be involved or signing the transaction.\n```\nstruct Listing<phantom CoinType> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<CoinType>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<CoinType>(listing: Listing<CoinType>, payment: Coin<SUI>): Balance<CoinType> {\n    let Listing<CoinType> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\n\nWhat if we want to allow sellers to specify which coins they accept as payment instead of always requiring Sui? This means we'd have to use two different types of coins as type arguments to both the `Listing` object and the `buy_coins` function:\n```\nstruct Listing<phantom ListedCoin, phantom PaymentCoin> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<ListedCoin>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<ListedCoin, PaymentCoin>(listing: Listing<ListedCoin, PaymentCoin>, payment: Coin<PaymentCoin>): Balance<CoinType> {\n    let Listing<ListedCoin, PaymentCoin> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nWe made the following changes:\n1. `Listing` now has two separate (phantom) types. We can name types so here we make the names very explicit to not mix up the types - ListedCoin and PaymentCoin.\n2. `buy_coins` now accepts two coin types as well. The payment now has to be of type `Coin<PaymentCoin>` instead of `Coin<SUI>`.\n3. The logic inside `buy_coins` didn't change much. We don't need to explicitly verify that the payment is of the right type as the payment coin's type is already specified directly in the `Listing<ListedCoin, PaymentCoin>`. Buyers have to provide the right payment or they wouldn't be able to call this function at all!\n\nType correctness is guaranteed  both by the Move compiler and the Sui VM when transactions are executed.\n\nIn very complex situations such as exchanges that allow 3 or 4-way trades between many different coin types, you might see very long functions such as:\n```\npublic fun buy_coins<Coin1, Coin2, Coin3, Coin4>(...) {\n}\n```\nThe `CoinTypes` always have to be explicitly declared as type arguments. This can lead to some complexity if we want to use the same function above to support trades of 1, 2, 3, or 4 types as users cannot leave the missing types empty when calling this function. To get around this, one solution can be to define a \"Null\" Coin type that users can pass if they don't need:\n```\nuse std::type_name;\n\nstruct Null has drop {}\n\npublic fun buy_coins<Coin1, Coin2, Coin3, Coin4>(...) {\n    if (type_name::into_string<Coin3>() == type_name::into_string<Null>()) {\n        // Coin3 is not specified and should be ignored\n    }\n}\n```\nAs shown above, developers can compare the types with `type_name::into_string` to know which types are not specified."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Mint more SUI to pay for gas",
                "isCorrect": false
              },
              {
                "answer": "B. Still submit the transaction and not pay for gas",
                "isCorrect": false
              },
              {
                "answer": "C. Buy SUI from an exchange to fund their account for gas",
                "isCorrect": true
              }
            ],
            "lessonId": "14",
            "codeDef": "",
            "title": "Coin Type orders in struct type arguments",
            "quizTitle": "What happens when users specify the types in the wrong order for an object?",
            "content": "In the previous marketplace example, we created market listings of type `Listing<ListedCoin, PaymentCoin>`. The `buy_coins` function then requires `Listing<ListedCoin, PaymentCoin>` as an argument to know which listing the buyer wants to buy from.\n```\nstruct Listing<phantom ListedCoin, phantom PaymentCoin> has key {\n    id: UID,\n    seller: address,\n    listed_coins: Balance<ListedCoin>,\n    amount_asked: u64,\n}\n\npublic fun buy_coins<ListedCoin, PaymentCoin>(listing: Listing<ListedCoin, PaymentCoin>, payment: Coin<PaymentCoin>): Balance<CoinType> {\n    let Listing<ListedCoin, PaymentCoin> { id, seller, listed_coins, amount_asked } = listing;\n    object::delete(id);\n    assert!(coin::value(&payment) == amount_asked, EINSUFFICIENT_PAYMENT);\n    transfer::public_transfer(payment, seller);\n    listed_coins\n}\n```\nLet's say someone made a listing for `Listing<MyCoin, SUI>` but a buyer mistakes the order and specifies the listing as `Listing<Sui, MyCoin>`, what would happen? When this transaction is sent to the Sui network, the validation layer would error out because `Listing<SUI, MyCoin>` is invalid at the same address provided (SUI is the listed coin and `MyCoin` is the payment). There's no concern that this might accidentally refer to another Listing for SUI as each object's address is unique and can only have a single type. If another seller does create a `Listing<SUI, MyCoin>`, this listing object's address would be different.\n\nThis can be a common problem that users run into especially for complex marketplaces/exchanges that have many different types of listings with different pairs of coins. Different from our Listing example above, in most exchanges on Sui, the order of the Coins actually doesn't matter for the core objects themselves:\n```\nstruct Market<phantom Coin1, phantom Coin2> has key {\n    id: UID,\n    reserves_1: Balance<Coin1>,\n    reserves_2: Balance<Coin2>,\n}\n```\nIn this Market, `Coin1` and `Coin2` have similar role - buyers can buy `Coin1` with `Coin2` or `Coin2` with `Coin1`. Here the order doesn't technically matter, but unfortunately when the Market object is created, we still need to choose which Coin is the first first type (Coin1). Behind the scene, the object is still created with the `Market<Coin1, Coin2>` in that order. So when users interact with this market, they still need to specify the Coins in the right order that they were created with.\n\nOne solution here to make it easier for users can be to ensure `Coin1` and `Coin2` are also sorted in alphabetic order when the `Market` objects are created. This is currently not easy to do yet in Sui Move due to lack of string comparison."
          },
          {
            "codeSol": "",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "15",
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "",
            "content": "**Sui Coin standard** is the equivalent concept of ERC-20 on Ethereum network on Sui network but it is easier to use.\n* `coin::create_currency` creates a new coin, returns a metadata object storing information about the coin (symbold, name, description, and logo URL), and returns the Treasury Cap object to manage the coins.\n* `coin::mint` create a new coins and doesn't need to specify MyCoin as the type argument as the compiler can infer that.\n* We could use `TreasuryCap<CoinType>` object to mint the coins. However, only the `TreasuryCap` owner can call it. If we want to allow users to freely mint coins, we could wrap `TreasuryCap` object in a shared object.\n* We could also use `TreasureyCap` to burn coins by calling `coin::burn` function. This  also destroys the `Coin` object itself. \n\n**Coin vs Balance**\n1. `Coin` object is more like a wallet. The Coin wallet has an inner balance and cash (Balance) can be taken out of it and deposited into another Coin wallet object. Coins can also be easily split and joint with `coin::split` and `coin::join`.\n2. `Balance` is like cash only. It cannot be stored alone and needs to be put into wallets or pockets. Developers can choose to create their own \"pocket\" objects to store `Balance`. A few important `Balance` function to remember are `sui::balance`, `split`, and `withdraw_all`.\n\n**Decimals** are often used for Coins/tokens in order to reduce rounding errors. Decimals is a special case and there's no update function for it because decimals is a fundamental property of a coin and can change everyone's balance if it's updated. Therefore, for safety and simplicity, Sui's Coin standard doesn't allow modifying decimals.\n\n**Gas** is the fee required for performing actions, like transactions or smart contracts, on the network. It represents a user-centric, cost-bearing mechanism that maintains the decentralized and transparent nature of blockchain networks.\nApplications could accept SUI tokens as gas fee for their application or they could accept other types of coins as their payment. In the latter case, use `Listing` object and the `buy_coins` function.\n\n"
          }
        ]
      },
      {
        "title": "NFT - Kiosk Standards",
        "lesson": [
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Each token is unique while each NFT is not",
                "isCorrect": false
              },
              {
                "answer": "B. Each NFT is unique while each token is not",
                "isCorrect": true
              },
              {
                "answer": "C. NFTs cannot be objects",
                "isCorrect": false
              }
            ],
            "lessonId": "1",
            "codeDef": "",
            "title": "Intro to NFT",
            "quizTitle": "What is the difference between NFTs and Tokens (Coins on Sui)?",
            "content": "In recent years, a groundbreaking technology has taken the art, entertainment, and digital collectibles world by storm - Non-Fungible Tokens, or NFTs. These digital assets have revolutionized the way we think about ownership and authenticity in the digital age.\n\nNFTs are unique digital tokens that are built on blockchain technology, which is the same underlying technology behind cryptocurrencies like Bitcoin and Ethereum. What sets NFTs apart is their individuality; each token represents a one-of-a-kind item, whether it's a piece of digital art, music, video clips, virtual real estate, in-game items, or even tweets and memes. This uniqueness is achieved through cryptographic signatures that verify the token's authenticity and ownership, making it tamper-proof and verifiable on a public ledger.\n\nNFTs have opened up exciting opportunities for artists, creators, and collectors, enabling them to monetize and trade digital creations like never before. They have also sparked discussions about the intersection of technology, ownership, and the future of digital culture. As NFTs continue to evolve and expand into various industries, they are reshaping the way we perceive and interact with digital assets, offering a glimpse into the potential of blockchain technology beyond cryptocurrencies.\n\nNFTs (Non-Fungible Tokens) are represented on the blockchain through a combination of smart contracts and unique identifiers. Here's how it works:\n\n1. Smart Contracts: NFTs are created and managed using smart contracts, which are self-executing agreements with predefined rules and conditions. Smart contracts on blockchain platforms like Ethereum, Binance Smart Chain, and others are responsible for the creation, transfer, and ownership of NFTs. These contracts contain the logic that governs the behavior of NFTs, such as how they can be created, bought, sold, and transferred.\n2. Unique Identifiers: Each NFT has a unique identifier that distinguishes it from all other tokens on the blockchain. This identifier is typically a long string of characters that is associated with the specific NFT. It is often referred to as the \"token ID\" or \"token index.\" This identifier ensures the uniqueness of the NFT and allows it to be easily tracked on the blockchain.\n3. Metadata: NFTs often include metadata, which is additional information about the digital asset linked to the token. Metadata can include details about the creator, a description of the asset, its properties, and a link to the actual digital file (e.g., an image, video, or audio file). Metadata is typically stored off-chain (outside the blockchain) due to size limitations, and a reference to this metadata is included within the NFT's smart contract. This allows users to access and display information about the NFT without storing the entire content on the blockchain.\n4. Ownership and Transfer: The ownership of an NFT is tracked on the blockchain. When an NFT is created, the smart contract records the initial owner's wallet address. When the NFT is transferred to another party, the ownership information in the smart contract is updated to reflect the new owner's wallet address. This transfer process is secure and transparent, as it is recorded on the public ledger of the blockchain.\n5. Interoperability: NFTs are often created and traded on various blockchain platforms, each with its own set of standards (e.g., ERC-721 and ERC-1155 on Ethereum, BEP-721 on Binance Smart Chain). To ensure interoperability between different platforms, certain standards and protocols have emerged, allowing NFTs to be recognized and used across multiple ecosystems. For example, the Ethereum-based NFTs can be supported on various NFT marketplaces and platforms that adhere to the same standards.\n\nOn the Sui blockchain, NFTs are easy to create and manage with objects. Each NFT can be an object, which is already unique and can contain any metadata defined by the creators/developers. We'll talk more about how to implement NFTs on Sui in details in the next lessons."
          },
          {
            "codeSol": "module sui::sui_fren {\n    use std::string::String;\n    use sui::object::UID;\n    use sui::url::Url;\n\n    struct SuiFrenCollection has key {\n        id: UID,\n        creator: address,\n        name: String,\n        description: String,\n        limit: u64,\n        url: Url,\n    }\n\n    struct SuiFren has key {\n        id: UID,\n        collection: address,\n        name: String,\n        url: Url,\n        attributes: vector<String>,\n    }\n}",
            "quizType": "CODING",
            "answers": [
              {
                "answer": "Each token is unique while each NFT is not",
                "isCorrect": false
              },
              {
                "answer": "Each NFT is unique while each token is not",
                "isCorrect": false
              },
              {
                "answer": "NFTs cannot be objects",
                "isCorrect": false
              }
            ],
            "lessonId": "2",
            "codeDef": "module sui::sui_fren {\n    // Add the structs here\n}",
            "title": "NFT Standard - Collection and Token Objects",
            "quizTitle": "Let's start easy with this lesson and attempt to create our own simple NFT standard for SuiFrens. Define two separate object structs, one for SuiFrenCollection, and one for SuiFren (as an NFT) with the following fields:\nSuiFrenCollection:\n1. creator of type address\n2. name of type String\n3. description of type String\n4. limit of type u64\n5. url of type sui::url::Url\n\nSuiFren NFT:\n1. collection of type address\n2. name of type String\n3. url of type sui::url::Url\n4. attributes of type vector<String>\n\nHint: Don't forget imports!",
            "content": "To understand how to implement NFTs, let's define the core components of NFTs - creators, collections, tokens (NFTs):\n\n# Creators\nCreators are the individuals or entities responsible for producing and minting NFTs. They can be artists, musicians, game developers, content creators, or anyone who generates unique digital content that can be tokenized into NFTs.\n\nCreators use blockchain platforms and smart contracts to mint NFTs, defining the properties, ownership, and rules associated with each token. They can also specify attributes and metadata for their NFTs to provide additional information and context to buyers and collectors.\n\n# NFT collections\nare groups or sets of non-fungible tokens (NFTs) that share a common theme, style, or creator. They are curated collections of unique digital assets, often organized around a specific genre, artist, project, or category.\n\nFor example, a collection might be centered around digital art, featuring NFTs created by various artists. Another collection could revolve around virtual real estate, offering unique parcels of virtual land in a virtual world. Each NFT within a collection is distinct, but they are grouped together based on a common theme or affiliation.\n\n# NFT tokens\nNFT tokens are grouped into collections. Once a creator creates a collection, they can allow users to mint NFT tokens in the same collection, each one having unique identifier and attributes. Whether there's a limit to how many NFT tokens can be minted for a single collection can be defined by the creator via how they implement the smart contracts.\n\n# Implementation\nIn Sui Move, we can represent both NFT Collection and Token as objects. A Collection object can have the following fields:\n1. creator: The address of the collection's creator\n2. name: Collection's name such as \"SuiFrens\"\n3. description: Description of the collection\n4. limit: The number of tokens that can minted in the collection\n5. url: Collection's url\n\nAn NFT token usually has the following fields:\n1. collection: The address of the collection object\n2. name: Token's name e.g. \"SuiFren #1234\"\n3. url: Url of the token's image\n4. attributes: A list of attributes for the token such as birthdate, generation, etc. like we've seen in the previous course.\n\nNFT tokens can also have other attributes such as display info, royalty, etc. that we'll discuss more in later lessons. \n\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "They would override each other's NFT data",
                "isCorrect": false
              },
              {
                "answer": "Web UIs, wallets and marketplaces would not be able to support so many different standards",
                "isCorrect": true
              },
              {
                "answer": "Creating a new NFT standard is not allowed by the Sui network",
                "isCorrect": false
              }
            ],
            "lessonId": "3",
            "codeDef": "",
            "title": "Community NFT Standards",
            "quizTitle": "Why is it bad if every developer/creator creates their own NFT standard and functionalities?",
            "content": "Although our simple standard from earlier should work for creating our own SuiFren collections and NFTs, there are two problems with it:\n1. It's not a standard used by other developers/creators. Without an agreed upon standard such as how an NFT's attributes are defined, it'd be hard for wallets (used by users to sign and send transactions to the Sui network) and UIs to know how to display the data correctly.\n2. Developers can't reimplement all the functionalities  every time they create their own NFT collections.\n\nBecause of the above reasons, it makes sense for the community to have a common standard and functionality set for NFTs to make it easier for creators to create collections and have them displayed well by both UIs and wallets without having to do a lot of manual work.\n\nMost of the NFT collections on the Sui network currently use two main standards:\n1. OriginByte: https://github.com/Origin-Byte/nft-protocol. This has the most marketshare of the NFT standards on Sui\n2. Suiet: https://std.suiet.app/\n\nFor the remainder of this course, we'll dive into the OriginByte standard as they have the most functionalities while still allowing very flexible NFT design for game builders and artists. In their own words:\n\n```\nOrigin-Byte is an ecosystem of tools, standards, and smart contracts designed to make life easier for Web3 Game Developers and NFT creators. From simple artwork to complex gaming assets, we want to help you reach the public, and provide on-chain market infrastructure.\n\nThe ecosystem is partitioned into three critical components:\n\nThe NFT standard, encompassing the core Nft, Collection, and Safe types, controlling the lifecycle and properties of each NFT.\nPrimary markets, encompassing Marketplace, Listing, and numerous markets which control the initial minting and sale of NFTs.\nSecondary markets, encompassing principally the Orderbook which allows you to trade existing NFTs.\n```\n\nThese library contracts are all deployed in all Sui networks (testnet, mainnet). The address can be seen in their [Move.toml](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol). In order to develop with these standard, developers just need to copy the [nft_protocol](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol) and [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) directories over into their source code, and directly use the modules/functions/struct types provided there. In the next few lessons, we'll give a thorough introduction to all of the functionalities they offer.\n\nCommunity builders are always encouraged to improve and suggest adding functionalities to the existing standards such as OriginByte. Through exploring one specific standard, we hope to show you the \"basic\" set of all functionalities commonly used to construct rich and powerful NFTs in art collections, games and many other types of applications. Even if there are new standards adopted by the community in the feature, most of the concepts and functionalities should still apply and developers should be able to more easily switch to those new standards."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: vector<String>,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "4",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    // Add new imports here\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    // Add new structs here\n\n    // Update\n    fun init() {\n\n    }\n}\n",
            "title": "Creating a Collection and Display attributes",
            "quizTitle": "Update the sui_fren module to create an NFT collection for SuiFrens using the OriginByte standard. Make sure you don't forget any imports. Also remember the main one time witness type has to be named in a specific way (check out the first course if you forgot).\nThe SuiFren collection should have the following display attributes:\n1. name: \"SuiFrens\"\n2. description: \"A collection of SuiFrens who hangout together\"\n\nFor now we'll not share the MintCap object.",
            "content": "Using the OriginByte standard, developers can easily create a collection. The first step is to include the  [nft_protocol](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/nft_protocol) and [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) packages from OriginByte as mentioned in the previous lesson. Afterward, a collection can be created using the collection module:\n```\nmodule my_nft::kite {\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use std::string::String;\n    use sui::url::Url;\n    \n    /// One time witness is only instantiated in the init method\n    struct KITE has drop {}\n    \n    struct KiteNFT has key, store {\n        id: UID,\n        name: String,\n        description: String,\n        url: Url,\n        attributes: Attributes,\n    }\n    \n    fun init(otw: KITE, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n```\nA Collection can only be created as part of the init function as it requires a witness object (discussed in the first course). collection::create_with_mint_cap needs to be called with two type arguments:\n1. The witness object type. In the example above, that's KITE.\n2. The type of the NFT in the Collection. We created a KiteNFT type for this. Will discuss the fields in more details in the next lessons.\n\ncollection::create_with_mint_cap returns two objects - the collection object of type Collection<Kite> and the mint_cap which can be used to programmatically require it for minting tokens (to be discussed later). Both of these are made shared objects because they cannot be modified anyway and can only be read. We'll talk more about whether MintCap can be an owned object later.\n\nAfter the collection has been created, attributes such as name/description can be added:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n}\n```\nIn order to set the name/description for the collection, we need a few things:\n1. Import the ob_permissions::witness from the [permissions](https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/permissions) package provided by OriginByte.\n2. A new struct Witness {} declared in the same package\n3. Create a \"delegated witness\" object with witness::from_witness\n4. Call collection::add_domain with the right DisplayInfo object with the name and description. More attributes can be added as a separate domain."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n\n    public fun mint_nft(\n        mint_cap: &MintCap<SuIFren>,\n        generation: u64,\n        birthdate: u64,\n        ctx: &mut TxContext,\n    ) {\n        let nft = SuiFren {\n            id: object::new(ctx),\n            generation,\n            birthdate,\n            attributes: attributes::from_vec(vector[], vector[])\n        };\n        transfer::public_transfer(nft, tx_context::sender(ctx));\n        \n        mint_event::emit_mint(\n            witness::from_witness(Witness {}),\n            mint_cap::collection_id(mint_cap),\n            &nft,\n        );\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "5",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n    }\n\n    // Add the new function here\n}\n",
            "title": "Minting a Token",
            "quizTitle": "1. Update init function to share the MintCap object \n2. Add a new public function mint that takes the MintCap object, generation, birthdate, attributes and create a new SuiFren token. It should also emit the mint event",
            "content": "Now that we've created a collection. Let's talk about minting NFTs. The OriginByte standard only specifies how a Collection should be structured:\n1. Their Collection object is very minimal and all attributes need to be added as display attributes (via collection::add_domain):\n```\nstruct Collection<phantom T> has key, store {\n    id: UID,\n    version: u64,\n}\n```\n2. OriginByte also has common functionalities for Collection such as creators, royalty, etc.\n3. Developers need to define their own NFT struct as we've seen in the previous lesson. OriginByte only offers common functionalities to manage that token: Permissions (MintCap), attributes standard, display standard, etc.\n4. Mint and burn events that tie the NFTs back to the collection.\n\nDevelopers/creators first need to define the NFT object struct, which is needed to create the collection as discussed in the previous lesson:\n```\nmodule my_nft::kite {\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use std::string::String;\n    use sui::url::Url;\n    \n    /// One time witness is only instantiated in the init method\n    struct KITE has drop {}\n    \n    struct KiteNFT has key, store {\n        id: UID,\n        name: String,\n        description: String,\n        url: Url,\n        attributes: Attributes,\n    }\n    \n    fun init(otw: KITE, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    }\n}\n```\nOnce they have a collection, they can mint the NFTs like below:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        name,\n        description,\n        url: url::new_unsafe(url),\n        attributes: attributes::from_vec(vector[], vector[])\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nYou might realize that this doesn't look any different from creating an object! This is correct, there's only one small difference - attributes is a standard provided by OriginByte to store all the token attributes. We'll discuss this more in a later lesson. Developers can also add more logic here that restrict one token mint per user for example and whatever other rules they like.\n\nThe mint function also takes a MintCap object in order to emit a mint event. This is required so that off-chain components can know the KiteNFTs belong in the Kite collection. The mint_event::emit_mint provided by OriginByte also requires the delegated witness object passed when adding display attributes to the collection in the init function. In most cases, MintCap can be a shared object to allow any user to call the mint_nft function.\n\n```\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    transfer::public_share_object(mint_cap);\n}\n```\n\nIf this is not the case and developers want to restrict who can mint, they can make MintCap an owned object and, in the init function, transfer it to the account that can mint. This makes mint_nft a permissioned function that can only called by a specific account.\n\nAnother way off-chain components can recognize NFTs from a collection is to look at their type. The collection object has a type argument so in the example above its type would be Collection<Kite>"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Fields are explicit and thus easier to see while attributes are dynamic and harder to know the full list",
                "isCorrect": true
              },
              {
                "answer": "B. NFT structs are extensible and attributes are not",
                "isCorrect": false
              },
              {
                "answer": "C. NFT struct fields are dynamic and can be renamed or change type of needed",
                "isCorrect": false
              }
            ],
            "lessonId": "6",
            "codeDef": "",
            "title": "NFT Attributes",
            "quizTitle": "Why is using explicit fields in the NFT struct sometimes better than attributes?",
            "content": "As shown in the previous lesson, the best way to add attributes to a token is when it's just minted. The mint_nft function can either take a list of attributes from users or add its own attributes as it sees fit:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nDevelopers have an interesting tradeoff here when deciding how to add attributes to an NFT:\n1. Add directly as fields in the NFT struct (e.g. name, description)\n2. Add via attributes\n\nThe main benefit of using attributes is because new attributes can be added later (post-minting) without having to add new fields to the NFT struct. After the module is deployed, an existing struct cannot be modified or have new fields added:\n\n```\nuse sui::vec_map;\n\npublic fun add_new_attributes(kite_nft: &mut KiteNFT, new_attribute_name: String, new_attribute_value: String) {\n    let new_attributes = vec_map::empty<String, String>();\n    vec_map::insert(&mut new_attributes, new_attribute_name, new_attribute_value);\n    attributes::add_new(&mut kite_nft.id, new_attributes);\n}\n```\nattributes::add_new takes a VecMap (a map of keys to values) so we need to create one before calling the function. The key and value types can be anything (primitives, structs, etc.) as long as the key type is copyable."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "7",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        // Add royalty logic here\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
            "title": "Royalty",
            "quizTitle": "Update init function to charge a 2% royalty for all SuiFrens. All royalty should be sent to the sui_fren module publisher.",
            "content": "NFT royalty is a mechanism that allows creators and artists to earn a percentage of the resale price of their digital assets whenever those assets are sold in secondary markets. It provides a way for creators to continue benefiting from the appreciation of their work even after the initial sale.\n\nHere's how royalties work in NFTs:\n\n1. Initial Sale: When an NFT is initially minted and sold by the creator (often referred to as the \"primary sale\"), the creator can specify a percentage of the sale price that they want to receive as a royalty. This percentage is typically set in the NFT's smart contract during the minting process.\n2. Secondary Sales: After the initial sale, the NFT can be resold or traded by its owner in secondary markets (e.g., NFT marketplaces). When a secondary sale occurs, the creator is automatically entitled to receive the specified percentage (the royalty) of the resale price. The platform or marketplace facilitating the sale automatically deducts this royalty and transfers it to the creator's wallet.\n3. Continuous Earnings: Royalties provide creators with a continuous stream of income as long as their NFTs are being resold. This incentivizes artists and creators to produce high-quality and desirable digital content, as they can participate in the value appreciation of their work over time.\n4. Transparency: Royalties in NFTs are transparent and verifiable on the blockchain. The smart contract associated with the NFT specifies the royalty percentage and ensures that it is automatically enforced during secondary sales. This transparency builds trust between creators and buyers, as both parties can see how royalties are distributed.\n5. Benefits for Collectors: Royalties can also be beneficial for collectors and investors, as they can have confidence that their investment in an NFT may appreciate in value over time. Knowing that a portion of future resale proceeds will go back to the original creator can enhance the perceived value of an NFT.\n\nOne note here is royalty is usually guaranteed to be enforced by standards such as OriginByte. They're commonly enforced by the marketplaces and exchanges that support listing NFTs for sale. This is because payment methods can vary (different types of coins, other NFTs, debt notes, etc.) and the amount is self-reported by the marketplaces.\n\nHowever, standards like OriginByte does offer mechanisms for creators to define policies (\"strategies\" as called by OriginByte) regarding how royalty can be computed and enforced. This offers a standardized format for royalty and makes it much easier for exchanges to charge royalty.\n\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nIn the example above, we added a royalty of 1% that is 100% paid to a single creator (the module's deployer). Note behind the scene, royalty_strategy_bps::create_domain_and_add_strategy effectively adds the royalty as an attribute (\"domain\") via collection::add_domain the same way we added other attributes. It also creates and enforces (via royalty_strategy_bps::enforce) a special transfer policy. We'll cover TransferPolicy in more details in the lesson on Kiosk later as TransferPolicy is a concept introduced by the Kiosk standard.\n\nHow exactly marketplaces enforce royalty via a combination of royalty_strategy_bps, TransferPolicy and TransferRequest is outside the scope of this lesson. Curious learners are encouraged to look at the [source code](https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/nft_protocol/sources/rules/royalty_strategy.move#L65) to understand how this really works behind the scene.\n"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    use nft_protocol::display_info;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_transfer(collection, tx_context::sender(ctx));\n        transfer::public_share_object(mint_cap);\n    }\n\n    public fun update_collection_description(collection: &mut Collection<SuiFren>, new_description: String) {\n        display_info::change_description(collection::borrow_uid_mut(Witness {}, collection), new_description);\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "8",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n\n        let shares = vector[100];\n        let creator = tx_context::sender(ctx);\n        let shares = utils::from_vec_to_map(creator, shares);\n        royalty_strategy_bps::create_domain_and_add_strategy(\n            delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 200, ctx,\n        );    \n\n        let publisher = package::claim(otw, ctx);\n        let (transfer_policy, transfer_policy_cap) =\n            transfer_request::init_policy<SuiFren>(&publisher, ctx);\n        royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n\n    // Add the new function here\n}\n",
            "title": "Add, update and remove Collection's attributes",
            "quizTitle": "1. Update init function to send the Collection object to the module publisher.\n2. Add a new public function update_collection_description that allows the module publisher to update the description to a specified new_description string.",
            "content": "In an earlier lesson, we looked at how NFT collection can be created with a list of predefined attributes:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n}\n```\nThese attributes can also be modified after the collection has already been created. Permission-wise, developers have two options:\n1. Allow anyone to modify a collection's attributes, subject to specific rules (e.g. being a specific account as defined by the protocol). In this case, the Collection object needs to be a shared object.\n2. Keep the collection object as an owned object and transfer it to the account that has the permission to modify the collection's attributes later.\n\nEither way, this would give access to specify a mutable reference to the collection object when calling the functions that add/update/remove collection attributes. To add a group of attributes (domain) later, we just need the delegated witness object and call collection::add_domain again.\n```\npublic fun add_collection_attributes_group(collection: &mut Collection<KiteNFT>, attributes: vector<String>) {\n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        attributes,\n    );\n}\n```\nSince domain can be any type, it can be a single attribute or a group of - you can add a vector, VectorMap or any other containers that contain multiple attributes. Note that each type of domain can only be added once as they're added via dynamic fields behind the scene.\n\nTo modify an existing domain (can be a single attribute or a container of attributes):\n```\npublic fun update_collection_string_attribute(collection: &mut Collection<KiteNFT>, new_value: String) {\n    let string_attribute = collection::borrow_domain_mut<KiteNFT, String>(\n        delegated_witness,\n        &mut collection,\n    );\n    *string_attribute = new_value;\n}\n```\n\nTo modify the name or description that were set for the collection using DisplayInfo:\n```\npublic fun update_collection_name_and_desc(collection: &mut Collection<KiteNFT>, new_name: String, new_desc: String) {\n    display_info::change_name(collection::borrow_uid_mut(Witness {}, collection), new_name);\n    display_info::change_description(collection::borrow_uid_mut(Witness {}, collection), new_desc);\n}\n```\n\nTo delete a domain, including DisplayInfo since it's droppable:\n```\npublic fun delete_collection_display_info(collection: &mut Collection<KiteNFT>) {\n    collection::remove_domain<KiteNFT, DisplayInfo>(Witness {}, collection);\n}\n```"
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "9",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        attributes: Attributes,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n    }\n}\n",
            "title": "NFT's display attributes",
            "quizTitle": "Update init function to also create a display object for the SuiFren NFT. The display object should only print out the generation and birthdate with the following keys/formats:\ngeneration: \"SuiFren generation: {generation}\"\nbirthdate: \"Born on {birthdate}\"\n\nThe display object will be transferred to the module deployer for simplicity.",
            "content": "In previous lessons, we've seen how we can add attributes when minting an NFT:\n```\nuse nft_protocol::attributes::{Self, Attributes};\nuse nft_protocol::mint_cap;\nuse nft_protocol::mint_event;\nuse sui::url;\n\nstruct KiteNFT has key {\n    id: UID,\n    url: Url,\n    attributes: Attributes,\n}\n\npublic fun mint_nft(\n    mint_cap: &MintCap<Kite>,\n    name: String,\n    description: String,\n    url: String,\n    ctx: &mut TxContext,\n) {\n    let attributes = attributes::from_vec(\n        vector[string::utf8(b\"name\"), string::utf8(b\"description\")],\n        vector[name, description],\n    );\n    let nft = KiteNFT {\n        id: object::new(ctx),\n        url: url::new_unsafe(url),\n        attributes,\n    };\n    transfer::public_transfer(nft, tx_context::sender(ctx));\n    \n    mint_event::emit_mint(\n        witness::from_witness(Witness {}),\n        mint_cap::collection_id(mint_cap),\n        &nft,\n    );\n}\n```\nIn the intermediate Object course, we talked about Display object and how it can be used to instruct Web UIs and wallets to display the object to users. It can also allow adding attributes that are for display purposes only without burdening the actual object and can be used for cross-cutting changes that apply to all objects of the same type.\n\nWe can also use Display object to dictate how NFT objects are displayed as well by creating one when the collection is minted:\n```\nuse nft_protocol::display_info;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n    \n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n    \n    let publisher = package::claim(otw, ctx);\n    let display_object = display::new<KiteNFT>(&publisher, ctx);\n    display::add_multiple(\n        &mut display,\n        vector[\n            utf8(b\"All attributes\"),\n            utf8(b\"url\"),\n        ],\n        vector[\n            utf8(b\"All attributes: {attributes}\"),\n            utf8(b\"Image url: {url}\"),\n        ],\n    );\n    display::update_version(&mut display);\n    transfer::public_transfer(display, tx_context::sender(ctx));\n}\n```\nOnce the display object is created, an event is emitted that allows the Sui network nodes to detect the Display object. Subsequently, whenever an object is fetched via the node API, its display attributes are also computed in the exact formatting specified and returned along with the rest of the object's fields.\n\nIn the example above, we also send the display object to the module deployer in case we need to update the display attributes and formatting in the future. If developers are certain the display attributes won't ever change, they can also freeze the object. If they want to have custom logic as to when the display attributes can be added/modified/removed, they can also share the object."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID, ID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    use sui::event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    struct DeleteFrenEvent has copy, drop {\n        fren_id: ID,\n    }\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n\n    entry fun delete_fren(sui_fren: SuiFren) {\n        let SuiFren {id, generation: _, birthdate: _, attributes: _ } = sui_fren;\n        let fren_id = object::uid_to_inner(&id);\n        object::delete(id);\n        event::emit(DeleteFrenEvent { fren_id });\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "10",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::string::String;\n    use nft_protocol::attributes::Attributes;\n    use nft_protocol::collection;\n    use nft_protocol::mint_cap;\n    use nft_protocol::mint_event;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    struct SUIFREN has drop {}\n    \n    struct Witness has drop {}\n\n    // Add the new event here\n\n    fun init(otw: SUIFREN, ctx: &mut TxContext) {\n        let (collection, mint_cap) =\n            collection::create_with_mint_cap<SUIFREN, SuiFren>(&otw, option::none(), ctx);\n        let delegated_witness = witness::from_witness(Witness {});\n        \n        collection::add_domain(\n            delegated_witness,\n            &mut collection,\n            display_info::new(\n                string::utf8(b\"SuiFrens\"),\n                string::utf8(b\"A collection of SuiFrens who hangout together\"),\n            ),\n        );\n        transfer::public_share_object(collection);\n        transfer::public_share_object(mint_cap);\n\n        let publisher = package::claim(otw, ctx);\n        let display_object = display::new<SuiFren>(&publisher, ctx);\n        display::add_multiple(\n            &mut display,\n            vector[\n                utf8(b\"generation\"),\n                utf8(b\"birthdate\"),\n            ],\n            vector[\n                utf8(b\"SuiFren generation: {generation}\"),\n                utf8(b\"Born on {birthdate}\"),\n            ],\n        );\n        display::update_version(&mut display);\n        transfer::public_transfer(display, tx_context::sender(ctx));\n    }\n\n    // Add the new function here\n}\n",
            "title": "Burning NFTs",
            "quizTitle": "1. Add a new event DeleteFrenEvent that just has the id (of type ID) of the SuiFren NFT that was deleted, named fren_id. Check out https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/object.move for how to create an ID from the object's UID field. \n2. Add a new entry function delete_fren that can delete a SuiFren NFT",
            "content": "Similar to normal objects, NFTs can also be burnt (destroyed). This is a common feature for games that can be used to:\n1. Implement item crafting. Users can burn a few ingredient items to craft a weapon or concoct a potion.\n2. Represent item loss. When an armor is broken, it's burnt and disappears from the user's inventory.\n\nApplications can also burn consumable NFTs such as concert or raffle tickets.\n```\nuse nft_protocol::mint_event;\n\nstruct Witness has drop {}\n\nstruct Ticket has key {\n    id: UID,\n    expiration: u64,\n}\n\npublic fun clip_ticket(\n    collection: &mut Collection<Ticket>,\n    ticket: Ticket,\n) {\n    let Ticket {id, expiration: _ } = ticket;\n    object::delete(id);\n    \n    // Update collection's supply\n}\n```\nThis will destroy the NFT - it'll be removed from object storage after the transaction is executed. Note that if the collection tracks a supply of tickets (how many tickets are currently available), the supply attribute needs to be updated. See the earlier lesson on update collection's attributes for more details how."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. To make it clear on-chain or off-chain who the creators are",
                "isCorrect": true
              },
              {
                "answer": "B. For royalty payment split",
                "isCorrect": false
              },
              {
                "answer": "C. Because it's required by the OriginByte standard",
                "isCorrect": false
              }
            ],
            "lessonId": "11",
            "codeDef": "",
            "title": "Multiple creators",
            "quizTitle": "Why should the list of creators added to the collection as an attribute?",
            "content": "We've seen from previous lessons how the creator, usually the module deployer, can hold multiple permissions:\n1. Creator can own the Collection object for adding, updating, or deleting attributes.\n2. Creator can own the Display object for NFTs in the collection to control how they can be displayed in UIs.\n3. Creator can receive the royalty payments when the NFTs are traded on marketplaces\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Single creator account receiving all royalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nFor some collections, especially in games, there can be multiple creators, either because there are multiple different people involved or just for splitting the royalty payments into multiple accounts for safety reason. OriginByte provides a simple creators module interface that allows adding multiple creators. This can be used to:\n1. Add a creators attribute to the collection to keep track of all the creator addresses.\n2. Split royalty payment with specified percentages for these different creators accounts\n```\nuse nft_protocol::creators;\nuse ob_utils::utils;\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n    \n    // List of all creators\n    let creators = vector[\n        @0xA01, @0xA05, @0xA06, @0xA07, @0x08\n    ];\n    collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        creators::new(utils::vec_set_from_vec(&creators)),\n    );\n \n    // Royalty payment is split between 5 accounts at 20% each.\n    let shares = vector[2_000, 2_000, 2_000, 2_000, 2_000];\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nCreators can also be added or removed with control over the Collection object (either as owned or shared object)."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Because users wouldn't be able to list without the owner being involved",
                "isCorrect": false
              },
              {
                "answer": "B. Because anyone can directly delist another user's listing and take the NFT for themselves",
                "isCorrect": true
              },
              {
                "answer": "C. Because KioskOwnerCap cannot be shared",
                "isCorrect": false
              }
            ],
            "lessonId": "12",
            "codeDef": "",
            "title": "Kiosk Standard - Trading NFTs",
            "quizTitle": "When creating a permissionless kiosk, why is it bad to make the KioskOwnerCap a shared object?",
            "content": "# Intro to NFT marketplaces\nNFT (Non-Fungible Token) marketplaces are vital hubs in the NFT ecosystem, enabling the buying, selling, and trading of unique digital assets. They matter for several key reasons:\n\n1. Accessibility: NFT marketplaces make it easy for people to enter the world of digital collectibles and unique content.\n2. Discoverability: These platforms provide tools for users to find NFTs that match their interests, fostering exploration and connection.\n3. Trust and Security: Blockchain technology ensures transparency, authenticity, and secure transactions.\n4. Secondary Sales: NFT marketplaces facilitate reselling, allowing creators to earn royalties, and investors to potentially profit.\n5. Community and Engagement: They build communities around NFTs, fostering interaction and collaboration.\n6. Monetization for Creators: Artists and creators can monetize their work directly on these platforms.\n\n# Kiosk - Sui's marketplace standard\nSui Kiosk is a standard for object marketplaces that support listing and selling. This is available as part of the Sui framework deployed at 0x2 and has a lot of powerful features that can support NFT trading well.\n\nKiosk modules can be found [here](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/kiosk) and offer the following features (also works for non-NFT objects):\n* Create and manage a new NFT marketplace (a kiosk)\n* Transfer ownership of the NFT marketplace\n* Listing and delisting NFTs\n* Purchasing listed NFTs\n* TransferPolicy allowing the NFT type owners (creators) to define custom rules for every trade of their NFT, including royalty enforcement (what we've seen with OriginByte in a previous lesson) and allowlisting\n\nKiosk currently only supports using SUI coins as payment but developers can deploy their own version of Kiosk to support other Coins if they want to.\n\n# Trading on Kiosk\nFirst a kiosk needs to be created:\n```\nstruct KioskManagement has key {\n    id: UID,\n    owner_cap: KioskOwnerCap,\n}\n\npublic fun create_kiosk(ctx: &mut TxContext) {\n    let (kiosk, owner_cap) = kiosk::new(ctx);\n    transfer::public_share_object(kiosk);\n    let kiosk_management = KioskManagement {\n        id: object::new(ctx),\n        owner_cap,\n    };\n    transfer::public_share_object(kiosk_management);\n}\n```\nIn the above example, we called kiosk::new to create the kiosk. Since it returns 2 objects that are both not droppable, we need to either share or transfer them. If developers choose to transfer and keep these objects, these kiosks can be considered \"personal kiosks\" as all listings and purchases require mutable access to the kiosk and/or the owner cap which only the owner has.\n\nIn the above example, we made the kiosk object shared and add the owner cap to a shared KioskManagement object. This would make the kiosk permissionless - anyone can list on it, subject to any rules we want in the list function:\n```\npublic fun list_on_kiosk<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft: T,\n) {\n    // Any validation we want of the NFT being listed.\n    kiosk::place(kiosk, &kiosk_management.owner_cap, nft);\n    // Keep track of the lister.\n}\n```\nkiosk::place requires a reference to the KioskOwnerCap object, which can be obtained from the shared kiosk_management object. Users have to call our list_on_kiosk function and cannot call kiosk::place directly as they don't have direct access to the owner cap object inside KioskManagement. Another note here is for an NFT to be listed for sale, the NFT type must have store ability.\n\nSellers can also delist the NFT. Note that we need to make sure whoever calls delist is the same person who created the listing originally. This can be tracked via a shared object with dynamic fields.\n```\npublic fun delist<T: key + store>(\n    kiosk: &mut Kiosk,\n    kiosk_management: &KioskManagement,\n    nft_id: ID,\n) {\n    let sender = tx_context::sender(ctx);\n    // Validate that the sender is the same person who created the listing.\n    let nft = kiosk::take<T>(kiosk, &kiosk_management.owner_cap, nft_id);\n    transfer::public_transfer(nft, sender);\n}\n```\n\nSince the kiosk is a shared object, anyone can call sui::kiosk::purchase directly to purchase an NFT from a listing:\n```\n/// Make a trade: pay the owner of the item and request a Transfer to the `target`\n/// kiosk (to prevent item being taken by the approving party).\n///\n/// Received `TransferRequest` needs to be handled by the publisher of the T,\n/// if they have a method implemented that allows a trade, it is possible to\n/// request their approval (by calling some function) so that the trade can be\n/// finalized.\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {\n    let price = df::remove<Listing, u64>(&mut self.id, Listing { id, is_exclusive: false });\n    let inner = dof::remove<Item, T>(&mut self.id, Item { id });\n\n    self.item_count = self.item_count - 1;\n    assert!(price == coin::value(&payment), EIncorrectAmount);\n    df::remove_if_exists<Lock, bool>(&mut self.id, Lock { id });\n    coin::put(&mut self.profits, payment);\n\n    event::emit(ItemPurchased<T> { kiosk: object::id(self), id, price });\n\n    (inner, transfer_policy::new_request(id, price, object::id(self)))\n}\n```\nNote that while this returns the NFT purchased, it also does return a TransferRequest that cannot be dropped and needs to be \"validated\" before the transaction ends. We'll talk more about this as part of TransferPolicy in the next lesson."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Because buying an item off the Kiosk returns an undroppable TransferRequest",
                "isCorrect": true
              },
              {
                "answer": "B. Because money can be obtained from the user's account later if they refuse to pay",
                "isCorrect": false
              },
              {
                "answer": "C. Because TransferPolicy cannot be dropped",
                "isCorrect": false
              }
            ],
            "lessonId": "13",
            "codeDef": "",
            "title": "Kiosk Standard - Transfer Policy",
            "quizTitle": "Why can't users ignore TransferPolicy?",
            "content": "Kiosk has a very powerful functionality that allows NFT creators to dictate the rules for trading their NFTs such as royalty as we've seen in previous lessons: TransferPolicy. In the previous lesson, we've seen how purchasing an NFT first returns a TransferRequest that cannot be dropped:\n```\npublic fun purchase<T: key + store>(\n    self: &mut Kiosk, id: ID, payment: Coin<SUI>\n): (T, TransferRequest<T>) {...}\n```\nIn order to resolve this TransferRequest, users need to call sui::transfer_policy::confirm_request:\n```\n/// Allow a `TransferRequest` for the type `T`. The call is protected\n/// by the type constraint, as only the publisher of the `T` can get\n/// `TransferPolicy<T>`.\n///\n/// Note: unless there's a policy for `T` to allow transfers,\n/// Kiosk trades will not be possible.\npublic fun confirm_request<T>(\n    self: &TransferPolicy<T>, request: TransferRequest<T>\n): (ID, u64, ID) {\n    let TransferRequest { item, paid, from, receipts } = request;\n    let completed = vec_set::into_keys(receipts);\n    let total = vector::length(&completed);\n\n    assert!(total == vec_set::size(&self.rules), EPolicyNotSatisfied);\n\n    while (total > 0) {\n        let rule_type = vector::pop_back(&mut completed);\n        assert!(vec_set::contains(&self.rules, &rule_type), EIllegalRule);\n        total = total - 1;\n    };\n\n    (item, paid, from)\n}\n```\nAs you can see transfer_policy::confirm_request goes through a list of \"rules\" that are completed in the request and check if all rules are satisfied. Note that confirm_request requires a TransferPolicy which can only be obtained by calling transfer_policy::new as we've seen earlier in the royalty lesson:\n```\nuse nft_protocol::royalty;\nuse nft_protocol::royalty_strategy_bps;\nuse ob_permissions::witness;\nuse std::string::{Self, String};\nuse sui::package;\n\n/// Can be used for authorization of other actions post-creation. It is\n/// vital that this struct is not freely given to any contract, because it\n/// serves as an auth token.\nstruct Witness has drop {}\n\nfun init(otw: KITE, ctx: &mut TxContext) {\n    let (collection, mint_cap) =\n        collection::create_with_mint_cap<KITE, KiteNFT>(&otw, option::none(), ctx);\n    let delegated_witness = witness::from_witness(Witness {});\n     collection::add_domain(\n        delegated_witness,\n        &mut collection,\n        display_info::new(\n            string::utf8(b\"Kites\"),\n            string::utf8(b\"A NFT collection of Kites on Sui\"),\n        ),\n    );\n \n    // Define the loyalty\n    let shares = vector[100];\n    let creator = tx_context::sender(ctx);\n    let shares = utils::from_vec_to_map(creator, shares);\n    // 100 BPS (Basis points) == 1%\n    royalty_strategy_bps::create_domain_and_add_strategy(\n        delegated_witness, &mut collection, royalty::from_shares(shares, ctx), 100, ctx,\n    );    \n\n    // Make sure loyalty can be easily enforced.\n    let publisher = package::claim(otw, ctx);\n    let (transfer_policy, transfer_policy_cap) =\n        transfer_request::init_policy<KiteNFT>(&publisher, ctx);\n    royalty_strategy_bps::enforce(&mut transfer_policy, &transfer_policy_cap);\n}\n```\nThis means the TransferPolicy can only be created by the creator and thus the creator can store it somewhere and add a function that confirms/resolves TransferRequest after checking that the royalty has been paid. They can add more rules to the policy by calling transfer_policy::add_rule as well\n```\nstruct TransferPolicyHolder<phantom T> has key {\n    id: UID,\n    transfer_policy: TransferPolicy<T>,\n}\n\npublic fun confirm_request(holder: &TransferPolicyHolder, request: TransferRequest<T>) {\n    // Verify our rules and add receipts for each confirmed rule to the request.\n    \n    transfer_policy::confirm_request(&holder.transfer_policy, request);\n}\n```\nTransferPolicyHolder is a shared object and users can always add it as an argument as the last step in the PTB (Programmable Transaction Block) after purchasing an NFT in the previous step.\n\nOverall, TransferPolicy is a very powerful primitive that allows for building very rich NFT collections and marketplaces."
          },
          {
            "codeSol": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    use std::option::{Self, Option};\n    use std::string::String;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n        hat: Option<Hat>,\n        sunglasses: Option<SunGlasses>,\n    }\n\n    struct Hat has key {\n        id: UID,\n        diameter: u64\n    }\n\n    struct SunGlasses has key {\n        id: UID,\n        color: String,\n    }\n\n    entry fun wear_hat(sui_fren: &mut SuiFren, hat: Hat) {\n        option::fill(&mut sui_fren.hat, hat);\n    }\n\n    entry fun wear_sunglasses(sui_fren: &mut SuiFren, sun_glasses: SunGlasses) {\n        option::fill(&mut sui_fren.sun_glasses, sun_glasses);\n    }\n}\n",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "14",
            "codeDef": "module 0x123::sui_fren {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n    \n    struct SuiFren has key {\n        id: UID,\n        generation: u64,\n        birthdate: u64,\n    }\n\n    // Add the new structs and new functions here.\n}\n",
            "title": "Composable NFTs",
            "quizTitle": "1. Add a new Hat NFT with a diameter field of type u64.\n2. Add a new SunGlasses NFT with a color of type String.\n3. Update the SuiFren NFT to allow it to optionally wear a hat and sunglasses\n4. Add two new entry functions wear_hat and wear_sunglasses that allows the SuiFren to wear a hat and sunglasses, respectively",
            "content": "Similar to objects, NFTs can be combined together (\"composed\") using the different object techniques we've learnt in previous courses:\n1. Wrapping - Adding an NFT that has store ability as a field on another NFT. This removes the child NFT from storage.\n2. Dynamic object fields - Add the child NFT as a dynamic object field. Doesn't remove it from storage.\n3. Dynamic fields: Similar to dynamic object fields but the child NFT is removed from storage.\n4. Objects owning objects: Similar to dynamic object fields but have different syntax for accessing the child NFT (Receiving<T>) and maintain strict ownership chain.\n\nAmong these different approaches, it's the most straightforward to use object wrapping. A strong benefit here is that it's clear to UIs and games what NFTs can be added to an NFT such as adding weapons, armors, etc. to a hero NFT. Child NFTs can also be used to represent \"Traits\" of an NFT such as background.\n```\nstruct Background has key, store {\n    id: UID,\n    type: String,\n}\n\nstruct Eyewear has key, store {\n    id: UID,\n    type: String,\n}\n\nstruct Armor has key, store {\n    id: UID,\n    defense: u64,\n    durability: u64,\n}\n\nstruct Weapon has key, store {\n    id: UID,\n    num_uses: u64,\n    power: u64,\n}\n\nstruct Hero has key {\n    id: UID,\n    background: Background,\n    eyewear: Eyewear,\n    armor: Armor,\n    weapon: Weapon,\n}\n```\nIn the example above, Hero is a single NFT that wraps other NFTs as specific fields. The way it's currently written, a Hero must always have all of the child NFTs - background, eyewear, armor, weapon. If we want to make armor optional for example (a hero can wear or not wear armors), we can use the Option type:\n```\nuse std::option::Option;\n\nstruct Hero has key {\n    id: UID,\n    background: Background,\n    eyewear: Eyewear,\n    armor: Option<Armor>,\n    weapon: Weapon,\n}\n\npublic fun wear_armor(hero: &mut Hero, armor: Armor) {\n    option::fill(&mut hero.armor, armor);\n}\n\npublic fun take_off_armor(hero: &mut Hero) {\n    let armor = option::extract(&mut hero.armor);\n    transfer::public_transfer(armor, tx_context::sender(ctx));\n}\n```\nWe can then use ```option::fill``` and ```option::extract``` to add or remove the armor.\n\nThe benefit of using composable NFTs like this is if we sell the Hero NFT on a marketplace, all of the wrapped items also come with it. We can also freely remove the items if they're optional and transfer them between the different Hero NFTs we have. Composable NFT can be a very powerful primitive to build rich games and applications."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Checking if a large vector contains an item can be slow due to linear scan",
                "isCorrect": true
              },
              {
                "answer": "B. Adding to a large vector is slow",
                "isCorrect": false
              },
              {
                "answer": "C. Vectors are bad and should be avoided in all situations",
                "isCorrect": false
              }
            ],
            "lessonId": "15",
            "codeDef": "",
            "title": "Efficiency of NFT mints and Effect on Sui network",
            "quizTitle": "Why does using a large vector affect the efficiency of the Sui network?",
            "content": "With the object model, specifically owned objects, the Sui network is built to handle hundreds of thousands of TPS as transactions that only modify specific owned objects can be executed in parallel without conflicting with one another:\n1. Alice adds an armor to her hero NFT. She owns both the armor and the hero NFTs.\n2. Bob sends some SUI as a gift to Alice, which modifies both of their primary Coin objects.\n\nThe two transactions above don't touch the same objects and can be run in parallel, significantly reducing the execution time. Furthermore, transactions involving owned objects don't need to go through the full consensus process that are usually heavy and slow for most networks.\n\nThe general rule of thumb for building scalable applications that can perform well on the Sui network and also reduce contention - if too many applications are built incorrectly, they can take up more execution time and resources on the Sui network and thus potentially lead to a lower scale than the Sui network is designed to achieve.\n\nThere's a few mistakes that developers should avoid as much as possible:\n1. Use modifiable shared objects when there are no reasons to. This can manifest during an NFT mint for example, where the Collection object has a supply field that's increased every time a new NFT is minted. This supply can also be used to generate an incrementing id for each NFT (e.g. SuiFren #124). This should be avoided if possible.\n2. Use a vector to keep track of which addresses have minted an NFT. This is common with allowlist features where only specific accounts that have been allowlisted can mint an NFT. The minting module then keeps track of who has minted so an account can only mint one NFT at maximum. Allowlist can be implemented incorrectly if developers use a vector or vec_set/vec_map (both use vectors underneath). If the allowlist is large enough (e.g. > 10k items), checking whether an address has minted before can be very expensive for the network as it'd take a long time to execute. In thse cases, it'd be better to use table instead.\n3. Freeze objects as much as possible instead of sharing if they are never changed."
          }
        ]
      }
    ]
  },
  {
    "title": {
      "en": "Sui Framework Deepdive",
      "vi": "Sui Framework Deepdive"
    },
    "description": {
      "en": "This course dives into the various libraries and data structures that developers have access to on Sui. After this course, learners will be able to choose the right data structures for their applications and find the right balance between complexity, convenience, and design simplicity. In addition, this course will discuss antipatterns and pitfalls with misusing the Sui Framework. Lastly, this course covers unit testing and how to properly set up tests in Sui Move for ease and maximum test coverage.",
      "vi": "This course dives into the various libraries and data structures that developers have access to on Sui. After this course, learners will be able to choose the right data structures for their applications and find the right balance between complexity, convenience, and design simplicity. In addition, this course will discuss antipatterns and pitfalls with misusing the Sui Framework. Lastly, this course covers unit testing and how to properly set up tests in Sui Move for ease and maximum test coverage."
    },
    "modules": [
      {
        "title": "Data structures",
        "lesson": [
          {
            "codeSol": "public fun remove_duplicates(v: &mut vector<u64>) {\n    let i = 0;\n    while (i < vector::length(v)) {\n        if (borrow(v, i) == borrow(v, i + 1)) {\n            remove(v, i);\n        } else {\n            i = i + 1;\n        }\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "1",
            "codeDef": "public fun remove_duplicates(v: &mut vector<u64>) {\n    // Write the code here\n}",
            "title": "Vectors",
            "quizTitle": "Remove duplicates from a sorted `vector` using while loop\n",
            "content": "*Vector* in Move is a dynamic array that can grow and shrink in size. It is a generic type, meaning it can hold any type of data, from primitive types to complex structs. It is similar to the `Vec` type in Rust or `ArrayList` in Java.\nThe `vector` module in Move has several native functions that allow you to create, access, and manipulate vectors. The native functions are directly written in Rust and invoked through the Sui Move VM and thus are faster and more efficient than writing the same functions in Move.\nIn order to create a vector, there are two ways:\n1. Use a `vector` literal:\n```\nlet v = vector[1, 2, 3, 4];\n```\n2. Use the empty function:\n```\nlet v = vector::empty<u64>();\n```\nNote that the type hint `<u64>` might not be required if elements are added to this vector in the same function.\n```\nlet v = vector::empty();\nvector::push_back(&mut v, 1);\n```\n\nTo read a value from a vector, use the borrow function:\n```\nlet v = vector[1, 2, 3, 4];\nlet x = vector::borrow(&v, 2);\n```\nNote that x is a reference type which means it cannot be modified. If the values in the vector are copiable (have the copy ability), you can make a copy by dereferencing:\n```\nlet v = vector[1, 2, 3, 4];\nlet x = *vector::borrow(&v, 2);\n```\n\nTo modify a value of a vector in-place, use the borrow_mut function:\n```\nlet v = vector[1, 2, 3, 4];\nlet x = vector::borrow_mut(&mut v, 2);\n*x = *x + 1;\n```\n\nTo remove the last element from a vector, use the pop_back function:\n```\nlet v = vector[1, 2, 3, 4];\nlet x = vector::pop_back(&mut v);\n```\n\nYou can also remove a specific occurrence of an element from a vector by using `index_of` and `swap_remove` functions:\n```\nlet v = vector[1, 2, 3, 4];\nlet (found, i) = vector::index_of(&v, 3);\nif (found) {\n    vector::swap_remove(&mut v, i);\n}\n```\n\n`Arrays` can be combined and reversed:\n```\nlet v1 = vector[1, 2, 3];\nlet v2 = vector[4, 5, 6];\nvector::append(&mut v1, v2);\nvector::reverse(&mut v1);\n```"
          },
          {
            "codeSol": "module exercise::whitelist {\n    use sui::table::{Self, Table};\n    use sui::tx_context::TxContext;\n\n    // Create a new whitelist\n    public fun new(ctx: &mut TxContext) -> Table<u64, bool> {\n        table::new(ctx)\n    }\n\n    // Add an address to the whitelist\n    public fun add(table: &mut Table<u64, bool>, address: u64) {\n        table::add(table, address, true)\n    }\n\n    // Remove an address from the whitelist\n    public fun remove(table: &mut Table<u64, bool>, address: u64) {\n        table::remove(table, address)\n    }\n\n    // Check if an address is in the whitelist\n    public fun contains(table: &Table<u64, bool>, address: u64) -> bool {\n        table::contains(table, address)\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "2",
            "codeDef": "module exercise::whitelist {\n    use sui::table::{Self, Table};\n    use sui::tx_context::TxContext;\n\n    // Create a new whitelist\n    public fun new(ctx: &mut TxContext) -> Table<u64, bool> {\n    }\n\n    // Add an address to the whitelist\n    public fun add(table: &mut Table<u64, bool>, address: u64) {\n    }\n\n    // Remove an address from the whitelist\n    public fun remove(table: &mut Table<u64, bool>, address: u64) {\n    }\n\n    // Check if an address is in the whitelist\n    public fun contains(table: &Table<u64, bool>, address: u64) -> bool {\n    }\n}",
            "title": "Table",
            "quizTitle": "Exercise: Add functions to create, add, and remove address from a whitelist.",
            "content": "Tables are a map-like collection. They use dynamic fields underneath and just store the keys and values in the object system. This allows for an efficient and flexible data structure that can store up to a thousand entries, which is also the limit of dynamic fields. Tables are not stored in the object system, but are just handles into the object system.\nWhen developers need to store a lot of data, such as for an allowlist, they should use a table.\nOne caveat here is that there are restrictions on the types of keys and values that can be used in a table. The key type must be copy, drop, and store, and the value type must be store. This is because the table needs to be able to copy the keys, and the values need to be stored in the object system.\nIn general, all primitive types (numbers, bools, etc.) can be used as keys and values. Custom structs need to follow the above rules to be usable as keys or values in a table.\nNote that tables are also objects as the Table struct has a UID field and key ability. This means they can exist independent of other objects or wrapped in other objects.\n\nTo create a table:\n```\nlet table = table::new<u64, bool>();\n```\n\nThe type specification `<u64, bool>` is not required if an entry is added to the table immediately after creation. The type of the key and value will be inferred from the first entry added to the table.\n```\nlet table = table::new();\n// A table of type <string, u64> is created\ntable::add(&mut table, string::utf8(b\"My key\"), 1);\n```\n\nTo read a value from a table:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\nlet value = table::borrow(&table, 0);\n```\nValue is a reference type and can be copied by dereferencing if it has copy ability.\n```\nlet value = *table::borrow(&table, 0);\n```\n\nTo modify a value from the table directly:\n```\nlet value = table::borrow_mut(&table, 0);\n*value = true;\n```\n\nTo remove a value from the table, we need the key:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\nlet value = table::remove(&mut table, 0);\n```\nNote that remove returns the value in case it needs to be used after removal or doesn't have the drop ability (and thus can't be dropped automatically).\n\nA table doesn't have the drop ability and has to be explicitly destroyed when all items are removed:\n```\nlet table = table::new<u64, bool>();\ntable::add(&mut table, 0, false);\ntable::remove(&mut table, 0);\ntable::destroy_empty(table);\n```\n\nTables can also be destroyed when not empty if values have the drop ability. However, take caution here as dropping a large table with a lot of values can cost a lot of gas.\n```\nlet table = table::new<u64, MyStruct>();\ntable::add(&mut table, 0, MyStruct());\ntable::drop(table);\n```"
          },
          {
            "codeSol": "public fun remove_duplicates<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>) {\n    let mut current = *option::borrow(&table.head);\n    while (option::is_some(&linked_table::next(table, current))) {\n        let next = *option::borrow(&linked_table::next(table, current));\n        if (linked_table::borrow(table, current) == linked_table::borrow(table, next)) {\n            linked_table::remove(table, next);\n        } else {\n            current = next;\n        }\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "3",
            "codeDef": "public fun remove_duplicates<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>) {\n    // Your code here\n}",
            "title": "Linked Table (LinkedList)",
            "quizTitle": "Exercise: Implement a function to remove duplicates from a linked table where all elements are already sorted.",
            "content": "Linked list is a data structure that consists of a sequence of elements where each element points to the next element.\nLinked lists are useful data structures to implement more sophisticated protocols such as Order book and offer the following benefits:\n- Dynamic size: Linked lists are dynamic data structures that can grow and shrink as needed.\n- Insertion and removal are one operation each instead of removing an element from a vector which requires shifting all the elements after it.\n- Insertion order: Elements are stored in the order they are inserted. This can be very useful for specific programs.\n\nLinked lists in Sui Move can be created using Linked Table and offer the following extra benefits:\n- *Scaling*: `Linked Table` can be used to store a large number of elements as it uses dynamic fields to store the elements.\n- `LinkedTable` can also be a standalone object or a field in another object.\n- Iteration outside of loops: `Linked Table` can be iterated using the `prev` and `next` functions to traverse the list.\n\nTo create a `Linked Table`:\n```\nlet mut table = linked_table::new::<u64, u64>(ctx);\n```\n\nType specification <u64, u64> is technically not required if insertion is done immediately after creation:\n```\nlet mut table = linked_table::new(ctx);\nlinked_table::push_back(&mut table, 1, 10);\n```\n\nTo insert a key-value pair at the front of the table:\n```\nlinked_table::push_front(&mut table, 2, 20);\n```\n\nTo insert a key-value pair at the back of the table:\n```\nlinked_table::push_back(&mut table, 3, 30);\n```\nNote that keys added to the linked table must have copy, drop, and store abilities. Values must have store ability.\n\nTo remove the key-value pair in the table and return the value:\n```\nlet value = linked_table::remove(&mut table, 2);\n```\n\nLinked Table can be traversed using the `prev` and `next` functions:\n```\nlet current = linked_table::front(&table);\nwhile option::is_some(current) {\n    let key = option::unwrap(current);\n    let value = linked_table::borrow(&table, key);\n    current = linked_table::next(&table, key);\n}\n```\nCurrent key can be passed to other function to iterate without using a loop (e.g. with recursion).\n\nSimilar to Table, Linekd Table cannot be dropped automatically as it doesn't have the drop ability. It can only be destroyed explicitly in two ways:\n- `linked_table::destroy_empty(table)` can be used to destroy an empty table.\n- `linked_table::drop(table)` can be used to drop a possibly non-empty table. Take caution as this can be very expensive gas-wise if the table is large.\n"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. TableVec can be created with literal with vector cannot",
                "isCorrect": false
              },
              {
                "answer": "B. TableVec scales better than vector with large amount of items",
                "isCorrect": true
              },
              {
                "answer": "C. vector is fixed-sized while TableVec is not",
                "isCorrect": false
              }
            ],
            "lessonId": "4",
            "codeDef": "",
            "title": "Table vec (Large vectors)",
            "quizTitle": "What's the difference between `vector` and `TableVec`?",
            "content": "The standard vector is not efficient when there's a large number of items to be added (more than a few tens). This is because the bigger the vector is, the more gas it would be to update it such as adding a new element as this leads to more I/O cost to execute such transactions.\nGenerally, developers should use table-based vectors (`TableVec`) to store a large number of items. `TableVec` is a scalable vector that is implemented using the `Table` module. It is efficient for adding, removing, and accessing elements.\nTo create a `TableVec`:\n```\nlet t = table_vec::empty::<u64>(ctx);\n```\nNote that TableVec can only be used to store values that have the store ability. This includes all primitive types and structs that have the store ability.\n\nTo add an element to the end of the TableVec:\n```\ntable_vec::push_back(&mut t, 10);\n```\n\nTo get the length of the TableVec:\n```\nlet len = table_vec::length(&t);\n```\n\nTo get the element at a particular index:\n```\nlet element = table_vec::borrow(&t, 0);\n```\n\nTo remove the last element from the `TableVec`:\n```\nlet last_element = table_vec::pop_back(&mut t);\n```\n\nTo remove an element at a particular index:\n```\nlet element = table_vec::swap_remove(&mut t, 0);\n```\n\nSimilar to Table and LinkedTable, TableVec cannot be dropped automatically and has to be destroyed explicitly:\n1. If the `TableVec` is empty, it can be destroyed using `table_vec::destroy_empty(t)`.\n2. If the `TableVec` is non-empty, it can be dropped using `table_vec::drop(t)`. Take caution when using this function as it can take a lot of gas to execute if the `TableVec` is large.\n\nTo modify an element at a particular index:\n```\nlet mut element = table_vec::borrow_mut(&mut t, 0);\n*element = 20;\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. TableVec can be created with literal with vector cannot",
                "isCorrect": false
              },
              {
                "answer": "B. TableVec scales better than vector with large amount of items",
                "isCorrect": true
              },
              {
                "answer": "C. vector is fixed-sized while TableVec is not",
                "isCorrect": false
              }
            ],
            "lessonId": "5",
            "codeDef": "",
            "title": "Bag of heterogeneous data",
            "quizTitle": "What's the difference between `Bag` and `Table`?",
            "content": "Different from vector and table-based data structures which can only store elements of the same type, a bag can store elements of different types. This is because a bag is a collection of key-value pairs, where the key is a unique identifier and the value is the data associated with the key. The key can be of any type, and the value can be of any type. This makes a bag a very flexible data structure, but also a bit more complex to work with than a vector or table.\nBoth table-based data structures and Bag use dynamic fields under the hood. Bags are especially useful for situation where developers want to accept different types of payment Coins or miscellaneous objects.\nNote that since Bag also uses dynamic fields, it can only store up to 1000 items (limit on number of dynamic fields).\n\nTo create a Bag:\n```\nlet bag = bag::new();\n```\n\nTo add a key-value pair to a bag:\n```\nbag::add(&mut bag, b\"name\", b\"John Doe\");\nbag::add(&mut bag, b\"age\", 25);\n```\nPairs with the same keys cannot exist in the same Bag.\nOnly keys that have the copy, drop, and store abilities can be added to a Bag. Only values that have the store ability can be added.\n\nTo retrieve a value from a bag:\n```\nlet name = bag::borrow(&bag, b\"name\");\nlet age = bag::borrow(&bag, b\"age\");\n```\n\nTo modify a value in a bag:\n```\nlet age = bag::borrow_mut(&mut bag, b\"age\");\n*age = 26;\n```\n\nThere are two ways to check if an element is in a Bag:\n1. Check if a specific key exists in the Bag:\n```\nif (bag::contains(&bag, b\"name\")) {\n    // do something\n}\n```\n2. Check if a key exists and that the value is of specific type:\n```\nif (bag::contains_with_type::<vector<u8>, u64>(&bag, b\"age\")) {\n    // do something\n}\n```\n\nTo remove a value from a bag:\n```\nlet age = bag::remove(&mut bag, b\"age\");\n```\n\nA Bag cannot be destroyed automatically. It must be empty before it can be destroyed:\n```\nbag::destroy_empty(bag);\n```"
          },
          {
            "codeSol": "public fun sort<T: copy>(v: vector<T>): vector<T> {\n    let pq = priority_queue::new(vector[]);\n    let i = 0;\n    while (i < vector::length(&v)) {\n        priority_queue::insert(&mut pq, vector::borrow(&v, i), vector::borrow(&v, i));\n        i = i + 1;\n    };\n    let res = vector[];\n    while (vector::length(&pq.entries) > 0) {\n        let (_, value) = priority_queue::pop_max(&mut pq);\n        vector::push_back(&mut res, value);\n    };\n    res\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "6",
            "codeDef": "public fun sort<T: copy>(v: vector<T>): vector<T> {\n    // Implement\n}",
            "title": "Priority queue",
            "quizTitle": "Exercises: Given a vector of elements, sort it using a priority queue.",
            "content": "Priority queue is a data structure that allows you to insert elements with a priority and then pop the element with the highest priority. It's a very useful data structure and is used in many algorithms and applications.\nPriority queues are great for keeping items sorted and quickly finding the item with the highest priority.\n\nIn Sui Move, PriorityQueue can be created with custom priority for each entry. Comparison functions might be added in later evolutions of Sui Move.\n\nTo create a new PriorityQueue:\n```\nlet h = priority_queue::new(create_entries(vector[3,1,4,2,5,2], vector[10, 20, 30, 40, 50, 60]));\n```\nThe types of elements can be inferred from the entries created.\n\nTo insert a single new entry:\n```\npriority_queue::insert(&mut h, 7, 70);\n```\n\nTo pop the entry with the highest priority:\n```\nlet (priority, value) = priority_queue::pop_max(&mut h);\n```\nCurrently, the priority queue does not allow changing the priority or value of an existing entry. Nor does it allow removing an arbitrary entry. These features might be added in later evolutions of Sui Move."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Table should be used to store many items while VecMap is good for a small number",
                "isCorrect": true
              },
              {
                "answer": "B. Table cannot be dropped automatically while VecMap can",
                "isCorrect": false
              },
              {
                "answer": "C. VecMap is fix-sized",
                "isCorrect": false
              }
            ],
            "lessonId": "7",
            "codeDef": "",
            "title": "Vector-based map",
            "quizTitle": "What's the difference between VecMap and Table?",
            "content": "VecMap a simple map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries are *not* sorted by key--entries are included in insertion order.\nSimilar to vectors, VecMap should not be used when there's a large number of elements as this can lead to higher gas cost for access and updates. Tables should be used when there's a large number of elements.\n\nVecMap allows access either by key or by index (based on insertion order).\nTo create a new VecMap:\n```\nlet map = vec_map::empty<u64, u64>();\n```\n\nTo insert a new key-value pair:\n```\nvec_map::insert(&mut map, 1, 2);\n```\n\nTo remove a key-value pair:\n```\nvec_map::remove(&mut map, &1);\n```\n\nTo access element by key:\n```\nlet value = vec_map::get(&map, &1);\n```\nIn case you're not sure if the key exists and don't want to get an error which would abort the entire transaction, you can use `try_get`:\n```\nlet value_opt = vec_map::try_get(&map, &1);\nif (option::is_some(&value_opt)) {\n    let value = option::unwrap(value_opt);\n}\n```\n\nTo access element by index:\n```\nlet (key, value) = vec_map::get_entry_by_idx(&map, 0);\n```\n\nTo modify an element by key:\n```\n*vec_map::get_mut(&mut map, &1) = 3;\n```\n\nTo modify an element by index:\n```\n*vec_map::get_entry_by_idx_mut(&mut map, 0).1 = 3;\n```\n\nTo unpack the map into vectors of its keys and values:\n```\nlet (keys, values) = vec_map::into_keys_values(map);\n```\n\nVecMap cannot be automatically dropped. All elements must be explicitly removed first before the VecMap can be destroyed:\n```\nvec_map::destroy_empty(map);\n```\n\nOther useful functions include:\n- `size` to get the number of elements in the map\n- `is_empty` to check if the map is empty\n- `keys` to get a list of keys in the map"
          },
          {
            "codeSol": "public fun remove_duplicates(v: vector<u64>): vector<u64> {\n    let set = vec_set::empty();\n    let i = 0;\n    while (i < vector::length(&v)) {\n        let x = vector::get(&v, i);\n        if (!vec_set::contains(&set, &x)) {\n            vec_set::insert(&mut set, x);\n        }\n        i = i + 1;\n    };\n    vec_set::into_keys(set)\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "8",
            "codeDef": "public fun remove_duplicates(v: vector<u64>): vector<u64> {\n    // Implement\n}",
            "title": "Vector-based Set",
            "quizTitle": "Use a VecSet to remove duplicates from a vector",
            "content": "Similar to VecMap, VecSet is a vector-based set data structure. Sets are useful for the following use cases:\n- Deduplicate an input vector of elements\n- Avoid duplicates when inserting elements into a collection\n\nNote that VecSet's insertion and removal are O(n) instead of O(1) like HashSet or O(log n) like tree-based sets. This is because VecSet is backed by a vector, and it needs to scan the entire vector to check for duplicates.\nAnother limitation is that VecSet should not be used to store large numbers of elements, as the gas cost will be high for all operations.\n\nTo create a VecSet:\n```\nlet mut set = vec_set::empty<u64>();\n```\n\nTo insert an element into the set:\n```\nvec_set::insert(&mut set, 1);\n```\nElements inserted into a VecSet must have copy and drop abilities.\n\nTo remove an element from the set:\n```\nvec_set::remove(&mut set, &1);\n```\n\nTo check if an element is in the set:\n```\nvec_set::contains(&set, &1);\n```\n\nTo get the number of elements in the set:\n```\nvec_set::size(&set);\n```\n\nTo check if the set is empty:\n```\nvec_set::is_empty(&set);\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. ObjectTable can store only objects while Table can store anything that has the right abilities",
                "isCorrect": true
              },
              {
                "answer": "B. Table cannot store objects",
                "isCorrect": false
              },
              {
                "answer": "C. ObjectTable is bounded",
                "isCorrect": false
              }
            ],
            "lessonId": "9",
            "codeDef": "",
            "title": "Object data structures: Object bag, Object table",
            "quizTitle": "What's the difference between ObjectTable and Table?",
            "content": "ObjectBag and ObjectTable are similar data structures to Bag and Table, respectively and can store elements of different types. The difference is that ObjectBag and ObjectTable are designed to store objects, and the objects are stored in the storage. This is important for external tools to be able to access the objects. The difference is not observable from within Move.\n\nTo create an ObjectBag or ObjectTable:\n```\nlet bag = object_bag::new::<T>(ctx);\nlet table = object_table::new::<K, V>(ctx);\n```\n\nTo add an object to the bag or table:\n```\nobject_bag::add(&mut bag, obj);\nobject_table::add(&mut table, key, obj);\n```\n\nTo borrow an object from the bag or table:\n```\nlet obj = object_bag::borrow(&bag, id);\nlet obj = object_table::borrow(&table, key);\n```\n\nTo modify an object from the bag or table:\n```\nlet obj = object_bag::borrow_mut(&mut bag, id);\nobj.property = value;\nlet obj = object_table::borrow_mut(&mut table, key);\nobj.property = value;\n```\n\nTo remove an object from the bag or table:\n```\nlet obj = object_bag::remove(&mut bag, id);\nlet obj = object_table::remove(&mut table, key);\n```\n\nTo check if an object exists in the bag or table:\n```\nlet exists = object_bag::contains(&bag, id);\nlet exists = object_table::contains(&table, key);\n```\n\nTo get the number of objects in the bag or table:\n```\nlet len = object_bag::length(&bag);\nlet len = object_table::length(&table);\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "VecMap is fix-sized",
                "isCorrect": false
              },
              {
                "answer": "LinkedTable is based on Table so it's always better than vector",
                "isCorrect": false
              },
              {
                "answer": "LinkedTable is more gas efficient and has more functionalities",
                "isCorrect": true
              }
            ],
            "lessonId": "10",
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "Why use `LinkedTable` over `VecMap`?",
            "content": "In summary, when choosing which data structure to use, consider the following:\n1. **Gas cost**: Table-based data structures and bags have lower gas costs when used to store a large number of objects. This is because the cost of accessing an object in a table or bag is independent of the number of objects stored in the table or bag. In contrast, the cost of accessing an object in a vector is proportional to the number of objects stored in the vector.\n2. **Protocol needs**: Using the right data structure that offers the operations and functionalities a protocol needs is more efficient than using raw data structures and implementing the functionalities from scratch. PriorityQueue and LinkedTable for example are more efficient than using a vector and implementing the functionalities of a priority queue or a linked list.\n\n"
          }
        ]
      },
      {
        "title": "Libraries",
        "lesson": [
          {
            "codeSol": "public fun split(s: String): vector<String> {\n    let result = vector[];\n    let delimiter = string::utf8(b\",\");\n    let len = string::length(s);\n    while (string::index_of(s, delimiter) < len) {\n        let i = string::index_of(s, delimiter);\n        let part = string::sub_string(s, 0, i);\n        result.push(part);\n        s = string::sub_string(s, i + 1, len);\n    };\n    result\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "1",
            "codeDef": "public fun split(s: String): vector<String> {\n    // ...\n}",
            "title": "String",
            "quizTitle": "Split a string with \",\" as the delimiter\nHint: Use index_of and a while loop",
            "content": "Strings are not technically a primitive type in Move but are implemented as a module in the standard library. Strings, different from other structs, come with a lot of support from the VM and API. Strings can be passed as-is as a transaction argument, via the SDK, and behind the scene, it will be properly serialized/deserialized into the String struct.\nFunctions in Move can directly accept a String argument:\n```\npublic fun do_something(s: String) {\n    // ...\n}\n```\n\nIn Move, since String is not a primitive type, it has no direct literal syntax. Instead, you can create a string using the `utf8` function from the `string` module:\n```\nlet s = std::string::utf8(b\"Hello, World!\");\n```\nb\"Hello, World!\" is a byte array literal (vector<u8>), and the `utf8` function converts it into a string. The `utf8` function will error out if the byte array is not a valid UTF-8 string.\n\nStrings cannot be directly be set as a constant since constant expressions do not support function calls. You'd need to assign to the constant the bytes value first before converting it into a string:\n```\nconst HELLO_WORLD: vector<u8> = b\"Hello, World!\";\npublic fun hello_world(): String {\n    std::string::utf8(HELLO_WORLD)\n}\n```\nThis will create a UTF-8 string.\n\nMove also supports ASCII strings, which is a different module:\n```\nlet s = std::ascii::from_asciistring(b\"Hello, World!\");\n```\nHowever, UTF-8 strings are more commonly used and ASCII strings are much rarer.\n\nStrings are mutable. You can also append strings together:\n```\nlet s1 = std::string::utf8(b\"Hello, \");\nlet s2 = std::string::utf8(b\"World!\");\nstd::string::append(&mut s1, s2);\n```\n\nOr take a substring:\n```\nlet s = std::string::utf8(b\"Hello, World!\");\nlet sub = std::string::sub_string(&s, 0, 5);\n```\n\nYou can also insert a string into another string at a specific index:\n```\nlet s = std::string::utf8(b\"Hello, World!\");\nlet s2 = std::string::utf8(b\"Brave \");\nstd::string::insert(&mut s, 7, s2);\n```\n\nYou can also find the index of a substring:\n```\nlet s = std::string::utf8(b\"Hello, World!\");\nlet s2 = std::string::utf8(b\"World\");\nlet index = std::string::index_of(&s, &s2);\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Optional arguments to a function",
                "isCorrect": false
              },
              {
                "answer": "B. Optional fields in a struct",
                "isCorrect": false
              },
              {
                "answer": "C. Optional type arguments for a function",
                "isCorrect": true
              }
            ],
            "lessonId": "2",
            "codeDef": "",
            "title": "Option",
            "quizTitle": "What should Option not be used for?",
            "content": "The Option type is a common pattern in Rust and other languages. It is used to represent a value that may or may not be present. In Move, the Option type is implemented using a vector of size zero or one element.\nOptions are useful for:\n1. Optional arguments that are passed to functions\n2. Optional fields in structs\n3. Optional return values from functions\n\nThe Option type is defined in the std::option module. The Option type is a generic type, meaning it can hold any type of value. The Option type has two variants: Some and None. The Some variant holds a value, while the None variant does not hold a value.\nAn optional value can be created with:\n```\nlet absent = option::none();\nlet some_value = option::some(42);\n```\nOptions can be used on both primitive and structs:\n```\nstruct MyStruct {\n    value: u64\n}\nlet some_struct = option::some(MyStruct{value: 42});\nlet value = option::borrow(&some_struct).value;\n```\n\nThe Option type has several methods to work with optional values:\n\nis_none: returns true if the Option is None\n```\nlet absent = option::none();\nassert!(option::is_none(&absent), 0);\n```\n\nis_some: returns true if the Option is Some\n```\nlet some_value = option::some(42);\nassert!(option::is_some(&some_value), 0);\n```\n\ncontains: returns true if the Option contains a specific value\n```\nlet some_value = option::some(42);\nassert!(option::contains(&some_value, &42), 0);\n```\n\nA value can be read from an Option. This will abort if the Option is None:\n```\nlet some_value = option::some(42);\nlet value = option::borrow(&some_value);\n```\n\nA value can be read from an Option with a default value if the Option is None:\n```\nlet absent = option::none();\nlet value = option::borrow_with_default(&absent, &42);\n```\n\nA mutable reference to the value can be obtained from the Option and used to modify the value:\n```\nlet some_value = option::some(42);\nlet value = option::borrow_mut(&some_value);\n*value = 43;\n```\n\nThe value inside an Option can be replaced with a new value:\n```\nlet some_value = option::some(42);\nlet old_value = option::swap(&some_value, 43);\n```\n\nValues can also be filled in or extracted from an Option:\n```\nlet absent = option::none();\noption::fill(&absent, 42);\nlet value = option::extract(&absent);\n```\n\nThe Option type can be destroyed and its value extracted:\n```\nlet some_value = option::some(42);\nlet value = option::destroy_some(some_value);\n```"
          },
          {
            "codeSol": "public fun get_rand_number(ctx: &mut TxContext): u64 {\n    let id = fresh_object_address(ctx);\n    let epoch = epoch(ctx);\n    let timestamp = epoch_timestamp_ms(ctx);\n    let rand = (id + epoch + timestamp) % 100;\n    rand\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "3",
            "codeDef": "public fun get_rand_number(ctx: &mut TxContext): u64 {\n    // Implement\n}",
            "title": "Transaction context",
            "quizTitle": "Exercise: Use unique_id generated from fresh_object_address and epoch timestamp to generate random value",
            "content": "As we have seen in previous courses on objects and more advanced Move, transaction context (tx_context) is useful for many things:\n1. Create new objects. This requires a mutable tx_context\n2. Access the sender of the transaction\nTx_context is considered a special system object and automatically passed to a function:\n```\npublic fun my_function(ctx: &mut TxContext) {\n    let sender = ctx.sender();\n    let new_object = object::new(ctx);\n}\n```\nWhen calling my_function, the sender doesn't need to explicitly pass tx_context. It's automatically appended by the VM when the transaction is executed. This is also why transaction context should always be the last argument in a function signature.\n```\npublic fun my_function(arg1: u64, arg2: u64, ctx: &mut TxContext) {\n    // ...\n}\n```\n\nYou'd also see some library functions or functions from someone else's contract you might depend on requiring a transaction context. In most cases, this is for creating objects inside those functions.\nThere are other useful transaction context functions you can use:\n- `ctx.epoch()` returns the current epoch number\n```\nlet epoch = tx_context::epoch(ctx);\n```\nThe Sui blockchain is organized into non-overlapping epochs, each 24 hours long.\n\n- `ctx.epoch_timestamp_ms()` returns the start time of the current epoch in milliseconds since the Unix epoch\n```\nlet epoch_start = tx_context::epoch_timestamp_ms(ctx);\n```\n\n- `ctx.fresh_object_address()` returns a new, unique object address. This is useful for creating new objects.\n```\nlet new_object = object::new(ctx);\n```\nNote that this unique object address can be used as a unique id even for items that are not objects. These ids are guaranteed to be unique across all transactions and all objects.\n\n- `ctx.digest()` returns the hash of the current transaction. This is useful for creating deterministic randomness.\n```\nlet random_number = std::hash::digest(ctx.digest());\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. 2.5 in fixed_point32",
                "isCorrect": false
              },
              {
                "answer": "B. 3",
                "isCorrect": false
              },
              {
                "answer": "C. 2",
                "isCorrect": true
              }
            ],
            "lessonId": "4",
            "codeDef": "",
            "title": "Math and fixed_point32",
            "quizTitle": "What is the result of 5 / 2 in Move?",
            "content": "# Math\nThe math module provides useful math functions for working with unsigned integers in Move. This is different from the EVM world where users need to deploy their own math libraries.\n\nThe math module provides the following functions:\n- max: Return the larger of x and y\n```\nlet max = math::max(5, 10);\nassert!(max == 10, 0);\n```\n\n- min: Return the smaller of x and y\n```\nlet min = math::min(5, 10);\nassert!(min == 5, 0);\n```\n\n- diff: Return the absolute value of x - y\n```\nlet diff = math::diff(5, 10);\nassert!(diff == 5, 0);\n```\n\n- pow: Return the value of a base raised to a power\n```\nlet pow = math::pow(2, 3);\nassert!(pow == 8, 0);\n```\n\n- sqrt: Get a nearest lower integer Square Root for x\n```\nlet sqrt = math::sqrt(9);\nassert!(sqrt == 3, 0);\n```\n\n- sqrt_u128: Similar to math::sqrt, but for u128 numbers\n```\nlet sqrt = math::sqrt_u128(9);\nassert!(sqrt == 3, 0);\n```\n\n- divide_and_round_up: Calculate x / y, but round up the result\n```\nlet divide_and_round_up = math::divide_and_round_up(5, 2);\nassert!(divide_and_round_up == 3, 0);\n```\n\n# fixed_point32\nMove doesn't have native floating point numbers. All numbers are unsigned integers. This can make it hard to implement sophisticated math calculations such as in Defi protocols.\nThe standard libraries in Sui Move however provides a Move-based implementation of fixed-point numbers with 32 fractional bits. This is a binary representation, so decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so be careful about using floating-point to convert these values to decimal.\nThis however comes with extra gas cost due to Move expressions vs a native implementation in Rust in the Move language.\nCurrently only fixed point numbers with 32 bits on the fractional and integer part are supported.\n\nTo create a fixed point number:\n```\nlet one_half = fixed_point32::create_from_rational(1, 2);\nlet two = fixed_point32::create_from_raw_value(2);\n```\n\nTo perform arithmetic operations on fixed point numbers:\n```\nlet sum = fixed_point32::add(one_half, two);\nlet product = fixed_point32::multiply(one_half, two);\nlet quotient = fixed_point32::divide(one_half, two);\n```\n\nTo convert a fixed point number to a u64:\n```\nlet value = fixed_point32::get_raw_value(one_half);\n```\n\nTo check if a fixed point number is zero:\n```\nlet is_zero = fixed_point32::is_zero(one_half);\n```"
          },
          {
            "codeSol": "public fun deserialize(bytes: vector<u8>): Info {\n    use sui::bcs::{Self, BCS};\n\n    let prepared: BCS = bcs::new(bytes);\n    let (a, b, c, d, k, s) = (\n        bcs::peel_bool(&mut prepared),\n        bcs::peel_u8(&mut prepared),\n        bcs::peel_u64(&mut prepared),\n        bcs::peel_u128(&mut prepared),\n        bcs::peel_vec_bool(&mut prepared),\n        bcs::peel_address(&mut prepared)\n    );\n\n    Info { a, b, c, d, k, s }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "5",
            "codeDef": "public fun deserialize(bytes: vector<u8>): Info {\n    // your code here\n}",
            "title": "BCS",
            "quizTitle": "Exercise: Write a function that can extract the values to reconstruct a given struct from BCS bytes:\n```\nstruct Info {\n    a: bool,\n    b: u8,\n    c: u64,\n    d: u128,\n    k: vector<bool>,\n    s: address\n}\n```\n\nThe function should take a vector of bytes and return the struct.",
            "content": "Not to be confused with the bcs module from std::bcs, this lesson covers the sui::bcs module, which has a lot more functionalities.\nBCS is the default serialization format for Sui and Move. It is a binary format that is used to serialize data for storage and transmission. The BCS format is used to serialize data for storage and transmission.\nWhen values are passed as arguments in a transaction, they're serialized into BCS format. When the transaction is executed, the values are deserialized from BCS format into actual values in Move. This serialization and deserialization come with a cost for the Sui blockchain that developers should be mindful of.\nBy default, transactions cannot take non-object structs as arguments with the exception of Strings.\n\nThe BCS module can provide a workaround for this allowing developers to pass a struct-like values as a series of BCS-encoded bytes and the Move code can extract the values one by one as long as they're all of primitive types or vectors or options. This allows the FE to serialize a struct (which just generates a sequence of values, one after another) and the sequence of values can be extracted from the bytes one at a time:\n\n```\n/// This function reads u8 and u64 value from the input\nuse sui::bcs;\n\npublic fun deserialize(bytes: vector<u8>): (u8, u64) {\n    let prepared = bcs::new(bytes);\n    let (u8_value, u64_value) = (\n        bcs::peel_u8(&mut prepared),\n        bcs::peel_u64(&mut prepared)\n    );\n\n    (u8_value, u64_value)\n}\n```\n\nVectors can be extracted (or \"peeled\") similarly:\n```\npublic fun deserialize(bytes: vector<u8>): vector<u8> {\n    let prepared = bcs::new(bytes);\n    let u8_vector = bcs::peel_vec_u8(&mut prepared);\n    let u64_vector = bcs::peel_vec_u64(&mut prepared);\n\n    u8_vector\n}\n```\n\nOptions:\n```\npublic fun deserialize(bytes: vector<u8>): Option<u8> {\n    let prepared = bcs::new(bytes);\n    let u8_option = bcs::peel_option_u8(&mut prepared);\n    let u64_option = bcs::peel_option_u64(&mut prepared);\n\n    u8_option\n}\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. They require a lot of operations",
                "isCorrect": true
              },
              {
                "answer": "B. They require users to pay a deposit",
                "isCorrect": false
              }
            ],
            "lessonId": "6",
            "codeDef": "",
            "title": "Cryptography libraries",
            "quizTitle": "Why are cryptography functions expensive gas-wise?",
            "content": "Sui Move offers many cryptography functions that allow many different use cases:\n- bls12381: BLS12-381 signature verification. This can be used for verifying bls12381 signatures. BLS signatures are generally more efficient to verify than ECDSA signatures.\n- ed25519: Ed25519 signature verification. This is the default signature/keypair scheme in Sui.\n- ecdsa_k1 or sep256k1: secp256k1 signature verification. This is the signature scheme used in Bitcoin.\n- ecdsa_r1 or secp256r1: secp256r1 signature verification. This is the signature scheme used in Ethereum and other EVM chains.\n- blake2b (sui::hash module): Blake2b hashing. This is a fast and secure hashing algorithm.\n- keccak256 (sui::hash module): Keccak256 hashing. This is the hashing algorithm used in Ethereum.\n- groth16: Groth16 proof verification. This is used for zero-knowledge proof.\n\nUsing these functions allow developers to build secure and efficient applications on Sui as well as applications that can interop with signatures or proofs generated from other blockchains such as Ethereum.\n```\npublic fun verify_ethereum_signature(\n    signature: vector<u8>,\n    public_key: vector<u8>,\n    msg: vector<u8>,\n    hash: u8,\n): bool {\n    sui::ecdsa_r1::secp256r1_verify(&signature, &public_key, &msg, hash)\n}\n\nIn most flows involving cryptography functions, developers can write functions that take in a signed message or proof along with other params required that are specific to each cryptography mechanism. Then the Move code can do the verification on chain, guaranteeing correctness and decentralization.\nNote that cryptography functions can cost a lot of gas as they require a lot of computation behind the scene, implemented as native functions in Rust. Developers should avoid writing functions that do a lot of verifications."
          },
          {
            "codeSol": "public fun withdraw<CoinType>(coin: CoinType) {\n    let type_name = std::type_name::get<CoinType>();\n    if (type_name == string::utf8(\"0x123::my_module::Coin1\")) {\n        // Withdraw Coin1\n    } else if (type_name == string::utf8(\"0x123::my_module::Coin2\")) {\n        // Withdraw Coin2\n    } else if (type_name == string::utf8(\"0x123::my_module::Coin3\")) {\n        // Withdraw Coin3\n    } else {\n        // Unknown coin type\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "7",
            "codeDef": "public fun withdraw<CoinType>(coin: CoinType) {\n    // Implement\n}",
            "title": "Type name",
            "quizTitle": "Exercise: Given the following 3 coin types and assuming they're deployed at a module located at 0x123, write a function that withdraw these different coins from the user's account:\n```\nmodule 0x123::my_module {\n    struct Coin1 {}\n    struct Coin2 {}\n    struct Coin3 {}\n}\n```\nYou don't need to write the withdraw logic. Just leave a comment in each case similar to // Withdraw Coin1",
            "content": "Types in Move, defined as structs, contain 3 components:\n- Module address: the address of the module that defined the type\n- Module name: the name of the module that defined the type\n- Type name: the name of the struct\n\nTypes in Move are also passed as type arguments between functions. In some cases, developers might want to inspect the types in order to apply different logic.\nThis is where type_name module comes in. It provides a way to convert Move types into values. This is useful for debugging, logging, and other use cases where the type of a value needs to be inspected at runtime.\n```\n// Example usage\npublic fun process<T>(val: T) {\n    let type_name = type_name::get<T>();\n    let type_name_str = type_name::into_string(type_name);\n    if (type_name_str == utf8(b\"0xdeadbeef::my_module::MyStruct\")) {\n        // do something\n    } else if (type_name_str == \"0xdeadbeef::my_module::MyOtherStruct\") {\n        // do something else\n    } else {\n        abort 0;\n    }\n}\n```\n\nThe different components can be extracted from a type as well:\n```\nlet type_name = type_name::get<T>();\nlet module_name = type_name::get_module(&type_name);\nlet address = type_name::get_address(&type_name);\n```\n\nType name should be used with caution as comparing type names is not a reliable way to determine the type of a value. It is recommended to use Move's type system to determine the type of a value whenever possible."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Url has validation that the provided string is a valid url",
                "isCorrect": false
              },
              {
                "answer": "B. Url is more explicit and indicates to developers that a valid url is expected. No validation is performed",
                "isCorrect": true
              },
              {
                "answer": "C. Url is more gas efficient",
                "isCorrect": false
              }
            ],
            "lessonId": "8",
            "codeDef": "",
            "title": "Url",
            "quizTitle": "Why should developers use Url instead of String",
            "content": "Url is a convenient type provided in the Sui Move libraries to explicitly mark a field in a struct or a function's argument as a URL. This is useful for the Move language to understand the type of the field and to provide better error messages when the field is used incorrectly.\nDevelopers should use store values as Urls or accept Urls arguments where possible. Note that transactions cannot pass Urls as arguments, so Url should only be used as arguments for functions that are not directly called by users.\n\n```\nstruct MyStruct {\n    url: Url,\n}\n\npublic fun take_url(url: Url) {\n    // ...\n}\n```\n\nUrl can be created using the new_unsafe function, which takes a string as an argument. This function does not validate the string, so it is the responsibility of the developer to ensure that the string is a valid URL. The new_unsafe_from_bytes function can also be used to create a Url from a vector of bytes. This function will abort if the bytes are not valid ASCII.\n```\nuse 0x1::sui::url;\n\npublic fun main() {\n    let url = url::new_unsafe(\"https://example.com\");\n    let url_bytes = vector::from_hex(\"68747470733a2f2f6578616d706c652e636f6d\");\n    let url_from_bytes = url::new_unsafe_from_bytes(url_bytes);\n}\n```\n\nThe inner_url function can be used to get the inner URL from a Url as a String. The update function can be used to update the inner URL of a Url.\n```\nuse 0x1::sui::url;\nlet url = url::new_unsafe(\"https://example.com\");\nlet inner_url = url::inner_url(&url);\n```\n\nA Url can be updated using the update function. This function takes a mutable reference to the Url and a string as arguments. The string will replace the inner URL of the Url.\n```\nuse 0x1::sui::url;\nlet url = url::new_unsafe(\"https://example.com\");\nurl::update(&mut url, \"https://example.org\");\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. id, version number and inner value type",
                "isCorrect": true
              },
              {
                "answer": "B. id and version number",
                "isCorrect": false
              },
              {
                "answer": "C. Just the version number",
                "isCorrect": false
              }
            ],
            "lessonId": "9",
            "codeDef": "",
            "title": "Managing versions with versioned",
            "quizTitle": "What are the fields inside a Versioned object?",
            "content": "Similar to Url, versioned is a convenient library to provide explicit version management. Developers can use raw version numbers (e.g. u64), but versioned is more explicit and self-documenting.\nversioned can be used to manage versions of objects, an application's data or basically anything else.\nA Versioned is an actual object that can be transferred to accounts or kept inside (wrapped or via dynamic fields) of another object.\nA Versioned can also store the actual value inside itself instead of the value being a separate object, which is a more common use case.\n\nTo create a new Versioned object, use the create function. The initial version and value are required. The value must be a store type.\n```\nlet v = versioned::create(1, b\"hello\", &mut ctx);\n```\n\nTo get the current version of the inner type, use the version function.\n```\nlet ver = versioned::version(&v);\n```\n\nTo load the inner value based on the current version, use the load_value function. Caller specifies an expected type T. If the type mismatch, the load will fail.\n```\nlet val = versioned::load_value(&v);\n```\n\nTo take the inner object out for upgrade, use the remove_value_for_upgrade function. To ensure we always upgrade properly, a capability object is returned and must be used when we upgrade.\n```\nlet (val, cap) = versioned::remove_value_for_upgrade(&mut v);\n```\n\nTo upgrade the inner object with a new version and new value, use the upgrade function. Must use the capability returned by calling remove_value_for_upgrade.\n```\nversioned::upgrade(&mut v, 2, b\"world\", cap);\n```\n\nTo destroy this Versioned container, and return the inner object, use the destroy function.\n```\nlet val = versioned::destroy(v);\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "u64, vector, Option, String ",
                "isCorrect": false
              },
              {
                "answer": "u8, u32, bool, all structs",
                "isCorrect": false
              },
              {
                "answer": "u8, u32, bool, String",
                "isCorrect": true
              }
            ],
            "lessonId": "10",
            "codeDef": "",
            "title": "Summary",
            "quizTitle": "Which types can be passed arguments in a transaction?",
            "content": "In this course, we have covered many standard libraries provided by the Sui framework. These libraries cover extra types such as `String`, `Option`, `FixedPoint32`. There are also math libraries and other libraries that help developers write safe and easy to understand code in Move.\n\nMost of the libraries can be found under `std::`, with some exceptions such as `bcs`, `url`, or `versioned` under `sui::`. When writing Move code, developers should use the provided libraries as much as possible, because:\n1. They are written in an efficient way and might receive more optimizations later such as conversion into native Rust code that's even more efficient than Move.\n2. They have been extensively tested, audited, and battle-tested. This ensures that small mistakes are not made that can lead to hard to debug issues.\n\nWe covered the following libraries and their use cases:\n1. `String` - a semi-primitive type that's technically a struct but can be freely passed to functions as arguments as part of a transaction\n2. `Option` - an accessory type provided to represent optional values. Cannot be passed via transactions\n3. `FixedPoint32` - a number type useful for representing fractional numbers in Move as Move doesn't have native support for them. Cannot be passed via transactions\n4. `Transaction` context - a system object automatically passed to a function as a last argument if the function requires it. Useful for getting information about the transaction such as sender/digest or querying system states - current epoch, timestamp or for generating a unique id.\n5. `Math` - useful math functions\n6. `BCS` - Can be used to pass structs as bytes array (vector<u8>) as Sui doesn't by default allow passing custom structs as arguments. The receiving function will need to manually extract values one by one from the given bytes vector.\n7. `Cryptography` functions - Useful for verifying signed messages (with different schemes) or zero knowledge proofs\n8. `Type` name - useful for doing string inspection of types (structs) in Move\n9. `Url` and `Versioned` - useful libraries and types for explicit representation of special values"
          }
        ]
      },
      {
        "title": "Unit testing",
        "lesson": [
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Tests in Move run faster",
                "isCorrect": false
              },
              {
                "answer": "B. Tests in Move are easier to write and can test more deeply all functionalities in a module",
                "isCorrect": true
              },
              {
                "answer": "C. Tests in Move come with built-in formal verification",
                "isCorrect": false
              }
            ],
            "lessonId": "1",
            "codeDef": "",
            "title": "Separate test files for conciseness",
            "quizTitle": "What are the benefits of writing unit tests in Move?",
            "content": "# Why unit tests\nUnit tests are a critical part of the development process. They help ensure that the code behaves as expected and that changes to the code do not break existing functionality.\n\nEspecially in the smart contract world, where bugs can be very costly (millions of dollars at stake!), unit tests are a must-have. In general, developers are recommended to write tests that cover:\n- The happy path: tests that cover the expected behavior of the code.\n- Edge cases: tests that cover the unexpected behavior of the code. Especially cases that lead to errors.\n- E2E tests: tests that cover the full flow of the code, including the interaction with other modules and the blockchain.\n\nIn addition to unit tests, developers can also write integration tests, which would be in Typescript and can test everything end-to-end, including the interaction with the blockchain run locally.\n\n# Unit tests in Move\nUnit tests in Move, different from Solidity, are natively designed to be written directly in Move. This allows for deep integration with the language and the ability to test the full range of Move code.\nMove unit tests can be written in the same file as the module being tested. However, it is recommended to write tests in a separate file to keep the module file clean and focused on the module's implementation.\nThis also reduces the amount of #[test_only] annotations needed to be added for test-only logic. We'll discuss this more in a later lesson in this course.\nThe structure of a Move source code directory is as below:\n- sources/\n  - module1.move\n  - module2.move\n  - module3.move\n- tests/\n  - module1_tests.move\n  - module2_tests.move\n  - module3_tests.move\n- Move.toml\n\nThere should be a separate file for each module's tests. The file name should be the module name followed by _tests.move. For example, if the module name is my_module, the test file should be named my_module_tests.move.\n\nEach test module looks like this:\n```\n#[test_only]\nmodule my_package::my_module_tests {\n}\n\nThe #[test_only] annotation makes sure this module is not deployed when the package is published."
          },
          {
            "codeSol": "#[test_only]\nmodule my_package::math_tests {\n    use my_package::math;\n\n    #[test]\n    fun test_add() {\n        assert!(math::add(1, 2) == 3, 0);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "2",
            "codeDef": "",
            "title": "Writing tests",
            "quizTitle": "Exercise: given the following module:\n\n```\nmodule my_package::math {\n    public fun add(x: u64, y: u64): u64 {\n        x + y\n    }\n}\n```\n\nWrite a test module with a single test that verifies that add works correctly with one assertion that 1 + 2 is 3.",
            "content": "A test module consists of helper functions and test functions. A test module can look like below:\n```\n#[test_only]\nmodule my_package::my_module_tests {\n    use std::string::{String, utf8};\n    use std::vector;\n\n    use my_package::my_module;\n\n    #[test]\n    fun my_test1() {\n        setup();\n        let my_struct = my_module::new_struct();\n        assert!(my_module.do_something(my_struct) == 0, 0);\n    }\n\n    #[test]\n    fun my_test2() {\n        setup();\n        let my_struct = MyStruct::new();\n        assert!(my_module.do_something(my_struct) == 0, 0);\n    }\n\n    fun setup() {\n        // setup code\n    }\n}\n```\nIn the example above, we have a helper setup function that is called at the start of each test. Note that Move doesn't have automatic setup functions so tests would need to do this manually.\nEach test is accompanied by a #[test] annotation so they will be run when developers execute a test run\n```\nsui move test\n```\nin the tests direction. Developers can additionally run `sui move test --coverage` to get a coverage report - how many % of the code is covered by the tests.\n\nTests can use assertion! statements to check the expected behavior of the code under test. assert! takes 2 arguments:\n- the first is a boolean expression that should evaluate to true if the test passes\n- the second is error message to help indicate which assertion failed in case there are many assertions in the test\n\nThere can be as many tests in the same module. The test module can also import any other modules. Note that everything written in the test module is not deployed to the blockchain so developers don't need to worry about security issues here/\nHelper functions can also be created in a separate test module that has no actual tests:\n```\n#[test_only]\nmodule my_package::test_helper {\n    public fun setup() {\n        // setup code\n    }\n}\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. #[testonly]",
                "isCorrect": false
              },
              {
                "answer": "B. #[test-only]",
                "isCorrect": false
              },
              {
                "answer": "C. #[test_only]",
                "isCorrect": true
              }
            ],
            "lessonId": "3",
            "codeDef": "",
            "title": "Calling private functions in the tested module",
            "quizTitle": "How do you the test only annotation?",
            "content": "In some cases, developers might want to test private functions or to use a private function to create a private data structure. You can do this by making these private functions public(friend) and friending the test module in the tested module.\nHowever, giving a function higher visibility than necessary is not a good practice. Instead, you can use the #[test_only] attribute to allow a function to be called only from the test module. This attribute is only available in the test module and is not available in the production code.\n\n```\nmodule my_package::my_module {\n    fun private_function() {\n        // ...\n    }\n    \n    #[test_only]\n    fun call_private_function() {\n        private_function();\n    }\n}\n\nmodule my_package::my_module_tests {\n    use my_package::my_module;\n    \n    #[test]\n    fun test_private_function() {\n        my_module::call_private_function();\n        // ...\n    }\n}\n```\n\nA few other things to remember when writing tests:\n- #[test_only] functions are especially useful for calling init function of the tested module as init functions are not called by default when tests are run. They have to call explicitly.\n- Make sure to not mispell #[test_only] such as #[testonly] or #[test_onlyy] as this would make the functions non-test! This can be catastrophic if test code is deployed, for example a function to mint money.\nThis is caught by the compiler nowadays but it's still a good practice in general to make sure the annotations are correct.\n- Developers should not abuse #[test_only] functions if there's no need for them.\n- #[test_only] annocation can also be on imports if there are imports used in test only functions in the tested module. Without this, the compiler might warn there's an unused import."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Because test_scenario is required for all tests",
                "isCorrect": false
              },
              {
                "answer": "B. To set up all aspects of the system before tests run",
                "isCorrect": true
              },
              {
                "answer": "C. Because test_scenario makes tests run faster",
                "isCorrect": false
              }
            ],
            "lessonId": "4",
            "codeDef": "",
            "title": "Test scenario: Managing transactions",
            "quizTitle": "Why is test_scenario needed",
            "content": "If you recall objects, &mut TxContext and the tx_context module, you might ask how are these set up in tests. The answer is by default they aren't. This might lead to baffling failures when writing your tests as these tx_context is often used to create objects or determine the sender of the transaction.\nMove unit tests are run only with the Sui Move VM and does not include any other components of the blockchain. In order to make sure the tx context as well as other parts of the Sui system are functional, developers can use test_scenario:\n\n```\nuse sui::test_scenario::{Self, Scenario};\n\n#[test]\npublic fun my_test() {\n    let scenario_val = test_scenario::begin(@0x123);\n    let scenario = &mut scenario_val;\n\n    test_scenario::next_tx(scenario, @0x123);\n    // your test code here\n\n    test_scenario::end(scenario_val);\n}\n```\n\nThere are 3 functions to call from test_scenario throughout your test:\n- test_scenario::begin: This function initializes the test scenario and returns a Scenario object. This object is used to keep track of the state of the test scenario.\n- test_scenario::next_tx: This function is used to simulate a transaction. It takes a Scenario object and a sender address as arguments. This function is used to simulate a transaction from a specific sender.\n- test_scenario::end: This function is used to end the test scenario. It takes a Scenario object as an argument and cleans up the test scenario.\n\nWith these functions, everything your test needs should already be set up. In some cases, developers might go as far as making the transaction boundary of each block of test code explicit with blocks ({ ... }):\n```\n\n#[test]\nfun my_test {\n    // === Third transaction ===\n    // next transaction - Fran looks in her inventory and finds the book\n    // she decides to return it to Manny and buy another one herself\n    test_scenario::next_tx(&mut scenario, fran);\n    {\n        // objects can be taken from the sender by ID (if there's multiple)\n        // or if there's only one object: `take_from_sender<T>(&scenario)`\n        let book = test_scenario::take_from_sender_by_id<LittleBookOfCalm>(&scenario, book_id);\n        // send the book back to Manny\n        sui::transfer::transfer(book, manny);\n\n        // now repeat the same steps as before\n        let store = test_scenario::take_shared<BlackBooks>(&scenario);\n        let ctx = test_scenario::ctx(&mut scenario);\n        let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n        // same as before - purchase the book\n        let book = purchase(&mut store, coin, ctx);\n        sui::transfer::transfer(book, fran);\n\n        // don't forget to return\n        test_scenario::return_shared(store);\n    };\n\n    // === Fourth transaction ===\n    // last transaction - Bernard collects the proceeds and transfers the store to Fran\n    test_scenario::next_tx(&mut scenario, bernard);\n    {\n        let store = test_scenario::take_shared<BlackBooks>(&scenario);\n        let cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n        let ctx = test_scenario::ctx(&mut scenario);\n        let coin = collect(&mut store, &cap, ctx);\n\n        sui::transfer::public_transfer(coin, bernard);\n        sui::transfer::transfer(cap, fran);\n        test_scenario::return_shared(store);\n    };\n}\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Yes",
                "isCorrect": false
              },
              {
                "answer": "B. No",
                "isCorrect": true
              }
            ],
            "lessonId": "5",
            "codeDef": "",
            "title": "Creating Objects - owned, shared, system",
            "quizTitle": "Do you need to return owned objects borrowed via test_scenario::take_from_sender?",
            "content": "In many cases, you also need to pass owned and shared objects when calling a tested function. But how do we get these objects? The Sui VM does this automatically when execution transactions, but this is in tests.\ntest_scenario provides a few functions to help with this:\n- test_scenario::take_shared: This function is used to take a shared object from the sender of the transaction. It takes a Scenario object as an argument and returns the shared object.\n```\nlet store = test_scenario::take_shared<BlackBooks>(&scenario);\n```\n- test_scenario::take_from_sender: This function is used to take an owned object from the sender of the transaction. It takes a Scenario object as an argument and returns the owned object.\n```\nlet cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n```\nOne note here is that if you take shared objects, you need to return them at the end before ending the scenario:\n```\ntest_scenario::return_shared(store);\n```\n\nYou might also need to pass TxContext to the test function. This can be generated with test_scenario as well:\n```\nlet ctx = &mut tx_context::new_from_hint(\n    @0xC4AD,  // sender\n    0u64,     // hint, used to generate tx hash\n    1,        // epoch\n    0,        // epoch_timestamp_ms\n    0,        // `ids_created` (normally should be `0`)\n);\n```\nThrough this, you can also configure the different data return from the tx_context module:\n* sender\n* hint, used to generate tx hash\n* epoch\n* epoch timestamp, in milliseconds\n* number of object ids already created so far. Testing some functionality might need this.\n\nClock, the other system object, is a shared object so it can taken like that:\n```\nlet clock = test::take_shared<Clock>(&test);\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. When the test function doesn't error out",
                "isCorrect": false
              },
              {
                "answer": "B. When the test function errors out with abort code of 1",
                "isCorrect": true
              },
              {
                "answer": "C. When the test function errors out with abort code of 2",
                "isCorrect": false
              }
            ],
            "lessonId": "6",
            "codeDef": "",
            "title": "Setting up SUI coins and Testing failing cases",
            "quizTitle": "When does a test with #[expected_failure(abort_code = 1)] pass?",
            "content": "# Creating SUI coins in tests\nSome tests might also need to create SUI coins when testing functions. This can be done via a #[test_only] function already defined in the coin module.\n```\nuse sui::coin;\n\n#[test]\npublic fun test() {\n    let coins = coin::mint_for_testing(1000);\n    // continue with the test\n}\n```\nFor custom coins, developers would need to have test_only functions defined in the modules where these Coins are initialized as a TreasuryCap is required to mint custom coins.\n\n# Failing cases\nWhen testing error cases, developers might want to write tests that expect a failure (e.g. the tested function correctly fails due to invalid inputs).\nThis can be done with the #[expected_failure] annotation\n```\n#[test]\n#[expected_failure(abort_code = kiosk::royalty_rule::EInsufficientAmount)]\nfun test_default_flow_0_invalid_amount_fail() {\n}\n```\nWe can use abort_code = to specify which abort code we expect to be returned by the test without having to hardcode. This is probably the closest we can get to public constants in Move for now. There might be updates in the near future to add support for public constants."
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Take b\"Hello\" and print it out as a string",
                "isCorrect": true
              },
              {
                "answer": "B. Print numbers - u8, u32, u64, etc.",
                "isCorrect": false
              },
              {
                "answer": "C. Print bools",
                "isCorrect": false
              }
            ],
            "lessonId": "7",
            "codeDef": "",
            "title": "Debugging",
            "quizTitle": "What can't std::debug::print do?",
            "content": "In unit tests, developers might need to know how to debug when the test fails. This can help with unexpected failures that are hard to debug.\nTo do this, normally developers want to print out different values at different places in the test to give them a better understanding of what is happening.\nYou can also do this in Move:\n\n```\n#[test]\nfun test_my_function() {\n    let a = 1;\n    let b = 2;\n    std::debug::print(&a);\n    std::debug::print(&b);\n    assert(a == b, 101);\n}\n```\nstd::debug::print takes references to any values and prints them out. Note that to print a string literal, you need to do the following:\n```\nstd::debug::print(&std::ascii::string(b\"Hello, world!\"));\n```\n\nstd::debug::print can also print an entire struct:\n```\nstruct MyStruct {\n    a: u64,\n    b: u64,\n}\n\n#[test]\nfun test_my_function() {\n    let my_struct = MyStruct { a: 1, b: 2 };\n    std::debug::print(&my_struct);\n}\n```"
          },
          {
            "codeSol": "",
            "quizType": "ANSWERS",
            "answers": [
              {
                "answer": "A. Loop through the list of test inputs and expected outputs, and run the tested function one for each combination",
                "isCorrect": true
              },
              {
                "answer": "B. Use native support built into Sui Move",
                "isCorrect": false
              },
              {
                "answer": "C. Use the annotation #[parameterized(inputs = ...",
                "isCorrect": false
              }
            ],
            "lessonId": "8",
            "codeDef": "",
            "title": "Writing parameterized tests",
            "quizTitle": "How do you run parameterized tests?",
            "content": "Parameterized tests are tests that are run multiple times with different input values. This is useful when you want to test a function with a range of different inputs, or when you want to test a function with a range of different expected outputs.\nUnit tests in Sui don't have native support for parameterized tests yet. To do this, we'll need to write some boilerplate code to run the same test multiple times with different input values.\n\n```\n#[test]\nfun test_add() {\n    assert_eq!(add(1, 2), 3);\n    assert_eq!(add(2, 2), 4);\n    assert_eq!(add(3, 2), 5);\n}\n```\ncan be rewritten as:\n```\n#[test]\nfun test_add() {\n    let test_cases = vector[(1, 2, 3), (2, 2, 4), (3, 2, 5)];\n    let i = 0;\n    while (i < vector::length(test_cases)) {\n        assert_eq!(add(a, b), expected);\n        i = i + 1;\n    }\n}\n```\n\nThis will become much easier with macro functions coming in Move soon.\n\n```\n#[test]\nfun test_add() {\n    let test_cases = vector[(1, 2, 3), (2, 2, 4), (3, 2, 5)];\n    vector::for_each(test_cases, |test_case| {\n        let (a, b, expected) = test_case;\n        assert_eq!(add(a, b), expected);\n    }\n}\n```"
          },
          {
            "codeSol": "/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::transfer;\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, UID};\n    use sui::balance::{Self, Balance};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin::value(&coin) > 0, ECantBeZero);\n        coin::put(&mut store.balance, coin);\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = balance::value(&store.balance);\n        coin::take(&mut store.balance, amount, ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n    #[test_only] use std::vector;\n    #[test_only] use sui::vec_map;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            let ctx = test_scenario::ctx(&mut scenario);\n            init_for_testing(ctx);\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = test_scenario::next_tx(&mut scenario, manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = test_scenario::created(&prev_effects);\n        let shared_ids = test_scenario::shared(&prev_effects);\n        let sent_ids = test_scenario::transferred_to_account(&prev_effects);\n        let events_num = test_scenario::num_user_events(&prev_effects);\n\n        assert!(vector::length(&created_ids) == 2, 0);\n        assert!(vector::length(&shared_ids) == 1, 1);\n        assert!(vec_map::size(&sent_ids) == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = purchase(&mut store, coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            sui::transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        test_scenario::next_tx(&mut scenario, fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = test_scenario::take_from_sender_by_id<LittleBookOfCalm>(&scenario, book_id);\n            // send the book back to Manny\n            sui::transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = purchase(&mut store, coin, ctx);\n            sui::transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = collect(&mut store, &cap, ctx);\n\n            sui::transfer::public_transfer(coin, bernard);\n            sui::transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        test_scenario::end(scenario);\n    }\n}",
            "quizType": "CODING",
            "answers": [],
            "lessonId": "9",
            "codeDef": "/// This module contains a dummy store implementation where anyone can purchase\n/// the same book for any amount of SUI greater than zero. The store owner can\n/// collect the proceeds using the `StoreOwnerCap` capability.\n///\n/// In the tests section, we use the `test_scenario` module to simulate a few\n/// transactions and test the store functionality. The test scenario is a very\n/// powerful tool which can be used to simulate multiple transactions in a single\n/// test.\n///\n/// The reference for this module is the \"Black Books\" TV series.\nmodule examples::black_books {\n    use sui::transfer;\n    use sui::sui::SUI;\n    use sui::coin::{Self, Coin};\n    use sui::object::{Self, UID};\n    use sui::balance::{Self, Balance};\n    use sui::tx_context::{Self, TxContext};\n\n    /// Trying to purchase the book for 0 SUI.\n    const ECantBeZero: u64 = 0;\n\n    /// A store owner capability. Allows the owner to collect proceeds.\n    struct StoreOwnerCap has key, store { id: UID }\n\n    /// The \"Black Books\" store located in London.\n    /// Only sells one book: \"The Little Book of Calm\".\n    struct BlackBooks has key {\n        id: UID,\n        balance: Balance<SUI>,\n    }\n\n    /// The only book sold by the Black Books store.\n    struct LittleBookOfCalm has key, store { id: UID }\n\n    /// Share the store object and transfer the store owner capability to the sender.\n    fun init(ctx: &mut TxContext) {\n        transfer::transfer(StoreOwnerCap {\n            id: object::new(ctx)\n        }, tx_context::sender(ctx));\n\n        transfer::share_object(BlackBooks {\n            id: object::new(ctx),\n            balance: balance::zero()\n        })\n    }\n\n    /// Purchase the \"Little Book of Calm\" for any amount of SUI greater than zero.\n    public fun purchase(\n        store: &mut BlackBooks, coin: Coin<SUI>, ctx: &mut TxContext\n    ): LittleBookOfCalm {\n        assert!(coin::value(&coin) > 0, ECantBeZero);\n        coin::put(&mut store.balance, coin);\n\n        // create a new book\n        LittleBookOfCalm { id: object::new(ctx) }\n    }\n\n    /// Collect the proceeds from the store and return them to the sender.\n    public fun collect(\n        store: &mut BlackBooks, _cap: &StoreOwnerCap, ctx: &mut TxContext\n    ): Coin<SUI> {\n        let amount = balance::value(&store.balance);\n        coin::take(&mut store.balance, amount, ctx)\n    }\n\n    // === Tests ===\n\n    #[test_only]\n    // The `init` is not run in tests, and normally a test_only function is\n    // provided so that the module can be initialized in tests. Having it public\n    // is important for tests located in other modules.\n    public fun init_for_testing(ctx: &mut TxContext) {\n        init(ctx);\n    }\n\n    // using a test-only attibute because this dependency can't be used in\n    // production code and `sui move build` will complain about unused imports.\n    //\n    // the `sui::test_scenario` module is only available in tests.\n    #[test_only] use sui::test_scenario;\n    #[test_only] use std::vector;\n    #[test_only] use sui::vec_map;\n\n    #[test]\n    // This test uses `test_scenario` to emulate actions performed by 3 accounts.\n    // A single scenario follows this structure:\n    //\n    // - `begin` - starts the first tx and creates the sceanario\n    // - `next_tx` ... - starts the next tx and sets the sender\n    // - `end` - wraps up the scenario\n    //\n    // It provides functions to start transactions, get the `TxContext, pull\n    // objects from account inventory and shared pool, and check transaction\n    // effects.\n    //\n    // In this test scenario:\n    // 1. Bernard opens the store;\n    // 2. Manny buys the book for 10 SUI and sends it to Fran;\n    // 3. Fran sends the book back and buys it herself for 5 SUI;\n    // 4. Bernard collects the proceeds and transfers the store to Fran;\n    fun the_book_store_drama() {\n        // it's a good idea to name addresses for readability\n        // Bernard is the store owner, Manny is searching for the book,\n        // and Fran is the next door store owner.\n        let (bernard, manny, fran) = (@0x1, @0x2, @0x3);\n\n        // create a test scenario with sender; initiates the first transaction\n        let scenario = test_scenario::begin(bernard);\n\n        // === First transaction ===\n\n        // run the module initializer\n        // we use curly braces to explicitly scope the transaction;\n        {\n            // `test_scenario::ctx` returns the `TxContext`\n            let ctx = test_scenario::ctx(&mut scenario);\n            init_for_testing(ctx);\n        };\n\n        // `next_tx` is used to initiate a new transaction in the scenario and\n        // set the sender to the specified address. It returns `TransactionEffects`\n        // which can be used to check object changes and events.\n        let prev_effects = test_scenario::next_tx(&mut scenario, manny);\n\n        // make assertions on the effects of the first transaction\n        let created_ids = test_scenario::created(&prev_effects);\n        let shared_ids = test_scenario::shared(&prev_effects);\n        let sent_ids = test_scenario::transferred_to_account(&prev_effects);\n        let events_num = test_scenario::num_user_events(&prev_effects);\n\n        assert!(vector::length(&created_ids) == 2, 0);\n        assert!(vector::length(&shared_ids) == 1, 1);\n        assert!(vec_map::size(&sent_ids) == 1, 2);\n        assert!(events_num == 0, 3);\n\n        // === Second transaction ===\n\n        // we will store the `book_id` in a variable so we can use it later\n        let book_id = {\n            // test scenario can pull shared and sender-owned objects\n            // here we pull the store from the pool\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(10_000_000_000, ctx);\n\n            // call the purchase function\n            let book = purchase(&mut store, coin, ctx);\n            let book_id = object::id(&book);\n\n            // send the book to Fran\n            sui::transfer::transfer(book, fran);\n\n            // now return the store to the pool\n            test_scenario::return_shared(store);\n\n            // return the book ID so we can use it across transactions\n            book_id\n        };\n\n        // === Third transaction ===\n\n        // next transaction - Fran looks in her inventory and finds the book\n        // she decides to return it to Manny and buy another one herself\n        test_scenario::next_tx(&mut scenario, fran);\n        {\n            // objects can be taken from the sender by ID (if there's multiple)\n            // or if there's only one object: `take_from_sender<T>(&scenario)`\n            let book = test_scenario::take_from_sender_by_id<LittleBookOfCalm>(&scenario, book_id);\n            // send the book back to Manny\n            sui::transfer::transfer(book, manny);\n\n            // now repeat the same steps as before\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = coin::mint_for_testing<SUI>(5_000_000_000, ctx);\n\n            // same as before - purchase the book\n            let book = purchase(&mut store, coin, ctx);\n            sui::transfer::transfer(book, fran);\n\n            // don't forget to return\n            test_scenario::return_shared(store);\n        };\n\n        // === Fourth transaction ===\n\n        // last transaction - Bernard collects the proceeds and transfers the store to Fran\n        test_scenario::next_tx(&mut scenario, bernard);\n        {\n            let store = test_scenario::take_shared<BlackBooks>(&scenario);\n            let cap = test_scenario::take_from_sender<StoreOwnerCap>(&scenario);\n            let ctx = test_scenario::ctx(&mut scenario);\n            let coin = collect(&mut store, &cap, ctx);\n\n            sui::transfer::public_transfer(coin, bernard);\n            sui::transfer::transfer(cap, fran);\n            test_scenario::return_shared(store);\n        };\n\n        // finally, the test scenario needs to be finalized\n        test_scenario::end(scenario);\n    }\n}",
            "title": "Summary",
            "quizTitle": "No Quiz. Here's a complete test might look like:",
            "content": "In summary, unit tests can be easily written in Move:\n- In a separate file/module\n- Start with #[test_only]\n- Can use test_scenario to have all context set up as if the code is executed from a transaction\n- Can take owned and shared objects to call tested functions. Shared objects have to be returned before test_scenario ends or next (test) transaction begins\n- Can create system objects - TxContext and Clock\n- Can validate that an abort happens with the specified error code when the tested function is called\n- Can be parameterized, for now with some boilerplate code\n\n"
          }
        ]
      }
    ]
  }
]
